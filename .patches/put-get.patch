At least reply to Put/Get commands even if no real support
for device infos exists yet. This is necessary because the Synthesis
server keeps the session open without those replies and
then always forces a slow sync.


#
# Patch managed by http://www.holgerschurig.de/patcher.html
#

--- native/src/c++/common/spds/SyncManager.cpp~put-get
+++ native/src/c++/common/spds/SyncManager.cpp
@@ -483,7 +483,27 @@
                 commands->add(*status);
                 deleteStatus(&status);    
             }
-        }  
+        }
+
+        //
+        // Process Put/Get commands
+        //
+        list = syncml->getSyncBody()->getCommands();
+        int cmdindex;
+        for (cmdindex = 0; cmdindex < list->size(); cmdindex++) {
+            AbstractCommand* cmd = (AbstractCommand*)list->get(cmdindex);
+            BCHAR* name = cmd->getName();
+            if (name) {
+                if (!bstrcmp(name, PUT) || !bstrcmp(name, GET)) {
+                    // not currently supported, pretend that it worked anyway
+                    status = syncMLBuilder.prepareCmdStatus(*cmd, 200);
+                    if (status) {
+                        commands->add(*status);
+                        deleteStatus(&status);    
+                    }
+                }
+            }
+        }
         
         //
         // Client Authentication. The auth of the client on the server
@@ -1380,7 +1400,7 @@
                 lastErrorCode = sret;
             }
         }        
-    }         
+    }
             
  finally:
 
--- native/src/c++/common/spds/SyncMLBuilder.cpp~put-get
+++ native/src/c++/common/spds/SyncMLBuilder.cpp
@@ -355,6 +355,35 @@
     return s;
 }
 
+/*
+* Return the status against an arbitrary command.
+*/
+Status* SyncMLBuilder::prepareCmdStatus(AbstractCommand &cmd, int status) {
+    /*
+    <Status>\n
+        <CmdID>2</CmdID>\n
+        <MsgRef>1</MsgRef>
+        <CmdRef>1</CmdRef>
+        <Cmd>cmd</Cmd>\n
+        <Data>status</Data>\n
+    </Status>
+    */
+    
+    ++cmdID;
+
+    CmdID commandID(itow(cmdID));
+    Data d(status);
+    char *msgRefStr = itow(msgRef);
+    ArrayList empty;
+
+    Status* s = new Status(&commandID, msgRefStr, cmd.getCmdID()->getCmdID(), cmd.getName(), &empty, &empty, NULL, NULL, &d, NULL);
+    
+    delete [] msgRefStr;
+    
+    return s;
+}
+
+
 Alert* SyncMLBuilder::prepareRequestAlert(SyncSource& s) {
     
     ++cmdID;
--- native/src/c++/common/spds/SyncMLProcessor.cpp~put-get
+++ native/src/c++/common/spds/SyncMLProcessor.cpp
@@ -195,9 +195,17 @@
             for (k = 0; k < items->size(); k++) {
                 item = (Item*)items->get(k);
                 if (item) {
-                    wchar_t *uri = toWideChar(item->getSource()->getLocURI());
-                    source.setItemStatus(uri, val);
-                    delete [] uri;
+                    Source* itemSource = item->getSource();
+                    if (itemSource) {
+                        wchar_t *uri = toWideChar(itemSource->getLocURI());
+                        source.setItemStatus(uri, val);
+                        delete [] uri;
+                    } else {
+                        // the item might consist of additional information, as in:
+                        // <SourceRef>pas-id-44B544A600000092</SourceRef>
+                        // <Data>200</Data>
+                        // <Item><Data>Conflict resolved by server</Data></Item>
+                    }
                 }
             }
             items = s->getSourceRef();
--- native/src/include/common/spds/SyncMLBuilder.h~put-get
+++ native/src/include/common/spds/SyncMLBuilder.h
@@ -104,6 +104,11 @@
         * Prepare the status for Sync command
         */
         Status*  prepareSyncStatus(SyncSource& source, Sync* sync) EXTRA_SECTION_01;
+
+        /**
+         * Prepare the status for an arbitrary command
+         */
+        Status* prepareCmdStatus(AbstractCommand &cmd, int status) EXTRA_SECTION_01;
                         
         /*
         * Prepare the Sync object. It doesn't contain any items. It is to prepare the insert of items
