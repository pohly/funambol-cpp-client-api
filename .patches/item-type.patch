A SyncSource is allowed to deliver items of different types
as long as the server knows how to deal with them. That the
C++ client library used the configured type instead of the
one from the SyncItem is an unnecessary restriction, removed
by this patch.

For backwards compatibility with (IMHO broken) SyncSources
which do not use SyncItem->setType() the SyncSource's type
is still used as fallback - as far as I am concerned, this
parameter should be removed.

Note that SyncEvolution is affected because it uses different
strings in the configured type to determine which kind of
database backend needs to be accessed (calendar or tasks)
although items from both sources have "text/calendar" as type.
#
# Patch managed by http://www.holgerschurig.de/patcher.html
#

--- native/src/include/common/spds/SyncMLBuilder.h~item-type
+++ native/src/include/common/spds/SyncMLBuilder.h
@@ -1,200 +1,200 @@
-/*
- * Copyright (C) 2005-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef INCL_SYNCML_BUILDER
-#define INCL_SYNCML_BUILDER
-
-#include "spds/DataTransformer.h"
-#include "spds/SyncSource.h"
-#include "spds/SyncMap.h"
-#include "syncml/core/TagNames.h"
-#include "syncml/core/ObjectDel.h"
-#include "syncml/formatter/Formatter.h"
-
-enum DataEncoding {
-    PLAIN  = 0,
-    B64    = 1,
-    DES    = 2,
-    DESB64 = 3
-};
-
-class SyncMLBuilder {
-
-    public:
-        SyncMLBuilder() EXTRA_SECTION_01;
-        ~SyncMLBuilder() EXTRA_SECTION_01;
-        SyncMLBuilder(BCHAR* t, BCHAR* d, unsigned long msgSize) EXTRA_SECTION_01;
-        
-        /*
-         * Convert the SyncML object into an xml message
-         */
-        BCHAR* prepareMsg(SyncML* syncml) EXTRA_SECTION_01;        
-        
-        /*
-         * Convert the SyncML object into an xml message
-         */       
-        SyncML*  prepareSyncML(ArrayList* commands, BOOL final) EXTRA_SECTION_01;
-         
-        /*
-        * Set init parameters
-        */
-        void     set(BCHAR* t, BCHAR* d, unsigned long msgSize) EXTRA_SECTION_01;
-        
-        /*
-        * Prepare the init SyncML* message with credential and db alert to sync
-        */
-        SyncML*  prepareInitObject(Cred* cred, ArrayList* alerts, ArrayList* commands) EXTRA_SECTION_01;
-        
-        /*
-        * Prepare the SyncHdr message with credential if not null
-        */        
-        SyncHdr* prepareSyncHdr(Cred* cred) EXTRA_SECTION_01;
-        
-        /*
-        * Prepare the init alert
-        */
-        Alert*   prepareInitAlert(SyncSource& source) EXTRA_SECTION_01;
-        
-        /*
-        * Prepare the special init alert for Address Change Notification
-        */
-        Alert*   prepareAddrChangeAlert(SyncSource& source) EXTRA_SECTION_01;
-        
-        /*
-        * Prepare alert with 222 code to request the server items
-        */ 
-        Alert*   prepareRequestAlert(SyncSource& source) EXTRA_SECTION_01;
-        
-        /*
-        * Prepare the status for Sync Header
-        */ 
-        Status*  prepareSyncHdrStatus(Chal* chal, int data) EXTRA_SECTION_01;
-        
-        /*
-        * Prepare the status for Alert command
-        */
-        Status*  prepareAlertStatus(SyncSource& s,  ArrayList* alert, int authStatusCode) EXTRA_SECTION_01;
-
-        /*
-        * Prepare the status for Item command. COMMAND could be ADD, REPLACE, DEL
-        */
-        Status*  prepareItemStatus(const BCHAR* COMMAND, const BCHAR* key, const BCHAR* cmdRef, int code) EXTRA_SECTION_01;
-        
-        /*
-        * Add the status to the corrent list of commands. It is responsible to collapse the status if needed
-        */ 
-        void     addItemStatus(ArrayList* previousStatus, Status* status) EXTRA_SECTION_01;
-
-        /*
-        * Prepare the status for Sync command
-        */
-        Status*  prepareSyncStatus(SyncSource& source, Sync* sync) EXTRA_SECTION_01;
-                        
-        /*
-        * Prepare the Sync object. It doesn't contain any items. It is to prepare the insert of items
-        */
-        Sync*    prepareSyncCommand(SyncSource& source) EXTRA_SECTION_01;
-        
-        /*
-        * Prepare the Map object. It doesn't containt anything. It is to prepare the insert of map items
-        */
-        Map*     prepareMapCommand(SyncSource& source)EXTRA_SECTION_01;
-        
-        /*
-        * Prepare the MapItem. It could contain only one MapItem
-        */
-        MapItem* prepareMapItem(SyncMap* syncMap) EXTRA_SECTION_01;
-        
-        ArrayList* prepareItem(SyncItem* syncItem, const BCHAR* type, BCHAR* COMMAND);
-
-        /*
-        * Add the MapItem to the Map command.
-        */
-        void     addMapItem(Map* map, MapItem* mapItem) EXTRA_SECTION_01;
-        
-        /*
-        * Prepare a ADD, REPLACE, DEL command using the syncItem passed by the source
-        */ 
-        ModificationCommand* prepareModificationCommand(BCHAR* COMMAND, SyncItem* item, const BCHAR* type) EXTRA_SECTION_01;
-        
-        /*
-        * Add a SyncItem into the modificationCommand. It is responsible to collapse if needed
-        */
-        void addItem(ModificationCommand* modificationCommand, BCHAR* COMMAND, SyncItem* syncItem, const BCHAR* type) EXTRA_SECTION_01;
-        
-        /*
-        * Reset the cmdID counter
-        */
-        void resetCommandID() EXTRA_SECTION_01;
-
-        /*
-        * increase the msgID counter
-        */
-        void increaseMsgRef() EXTRA_SECTION_01;
-        
-        /*
-        * reset MsgId counter
-        */
-        
-        void resetMessageID() EXTRA_SECTION_01;
-        
-        /**
-         * Sets the items content encoding
-         */
-        void setEncoding(DataEncoding e) EXTRA_SECTION_01;
-
-        /**
-         * Returns the items content encoding
-         */
-        DataEncoding getEncoding() EXTRA_SECTION_01;
-
-        /**
-         * Sets the encryption password
-         *
-         * @param pwd encryption password - NOT NULL
-         */
-        void setEncPassword(const BCHAR* pwd);
-        
-        /*
-        * reset MsgRef counter
-        */
-        void resetMsgRef();
-
-    private:
-
-        void initialize();
-
-        BCHAR* target;
-        BCHAR* device;
-        unsigned long maxMsgSize;        
-        BCHAR* encPassword;
-
-        unsigned long sessionID;
-        unsigned int  msgID    ;
-        unsigned int  cmdID    ;
-        unsigned int  msgRef   ;
-        
-        DataEncoding encoding;
-
-        BCHAR* encodeB64(char* data, TransformationInfo& info);   
-        BCHAR* encodeDESB64(char* data, TransformationInfo& info);
-        ComplexData* getComplexData(SyncItem* syncItem);
-
-};
-
-#endif
+/*
+ * Copyright (C) 2005-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef INCL_SYNCML_BUILDER
+#define INCL_SYNCML_BUILDER
+
+#include "spds/DataTransformer.h"
+#include "spds/SyncSource.h"
+#include "spds/SyncMap.h"
+#include "syncml/core/TagNames.h"
+#include "syncml/core/ObjectDel.h"
+#include "syncml/formatter/Formatter.h"
+
+enum DataEncoding {
+    PLAIN  = 0,
+    B64    = 1,
+    DES    = 2,
+    DESB64 = 3
+};
+
+class SyncMLBuilder {
+
+    public:
+        SyncMLBuilder() EXTRA_SECTION_01;
+        ~SyncMLBuilder() EXTRA_SECTION_01;
+        SyncMLBuilder(BCHAR* t, BCHAR* d, unsigned long msgSize) EXTRA_SECTION_01;
+        
+        /*
+         * Convert the SyncML object into an xml message
+         */
+        BCHAR* prepareMsg(SyncML* syncml) EXTRA_SECTION_01;        
+        
+        /*
+         * Convert the SyncML object into an xml message
+         */       
+        SyncML*  prepareSyncML(ArrayList* commands, BOOL final) EXTRA_SECTION_01;
+         
+        /*
+        * Set init parameters
+        */
+        void     set(BCHAR* t, BCHAR* d, unsigned long msgSize) EXTRA_SECTION_01;
+        
+        /*
+        * Prepare the init SyncML* message with credential and db alert to sync
+        */
+        SyncML*  prepareInitObject(Cred* cred, ArrayList* alerts, ArrayList* commands) EXTRA_SECTION_01;
+        
+        /*
+        * Prepare the SyncHdr message with credential if not null
+        */        
+        SyncHdr* prepareSyncHdr(Cred* cred) EXTRA_SECTION_01;
+        
+        /*
+        * Prepare the init alert
+        */
+        Alert*   prepareInitAlert(SyncSource& source) EXTRA_SECTION_01;
+        
+        /*
+        * Prepare the special init alert for Address Change Notification
+        */
+        Alert*   prepareAddrChangeAlert(SyncSource& source) EXTRA_SECTION_01;
+        
+        /*
+        * Prepare alert with 222 code to request the server items
+        */ 
+        Alert*   prepareRequestAlert(SyncSource& source) EXTRA_SECTION_01;
+        
+        /*
+        * Prepare the status for Sync Header
+        */ 
+        Status*  prepareSyncHdrStatus(Chal* chal, int data) EXTRA_SECTION_01;
+        
+        /*
+        * Prepare the status for Alert command
+        */
+        Status*  prepareAlertStatus(SyncSource& s,  ArrayList* alert, int authStatusCode) EXTRA_SECTION_01;
+
+        /*
+        * Prepare the status for Item command. COMMAND could be ADD, REPLACE, DEL
+        */
+        Status*  prepareItemStatus(const BCHAR* COMMAND, const BCHAR* key, const BCHAR* cmdRef, int code) EXTRA_SECTION_01;
+        
+        /*
+        * Add the status to the corrent list of commands. It is responsible to collapse the status if needed
+        */ 
+        void     addItemStatus(ArrayList* previousStatus, Status* status) EXTRA_SECTION_01;
+
+        /*
+        * Prepare the status for Sync command
+        */
+        Status*  prepareSyncStatus(SyncSource& source, Sync* sync) EXTRA_SECTION_01;
+                        
+        /*
+        * Prepare the Sync object. It doesn't contain any items. It is to prepare the insert of items
+        */
+        Sync*    prepareSyncCommand(SyncSource& source) EXTRA_SECTION_01;
+        
+        /*
+        * Prepare the Map object. It doesn't containt anything. It is to prepare the insert of map items
+        */
+        Map*     prepareMapCommand(SyncSource& source)EXTRA_SECTION_01;
+        
+        /*
+        * Prepare the MapItem. It could contain only one MapItem
+        */
+        MapItem* prepareMapItem(SyncMap* syncMap) EXTRA_SECTION_01;
+        
+        ArrayList* prepareItem(SyncItem* syncItem, const BCHAR* type, BCHAR* COMMAND);
+
+        /*
+        * Add the MapItem to the Map command.
+        */
+        void     addMapItem(Map* map, MapItem* mapItem) EXTRA_SECTION_01;
+        
+        /*
+        * Prepare a ADD, REPLACE, DEL command using the syncItem passed by the source
+        */ 
+        ModificationCommand* prepareModificationCommand(BCHAR* COMMAND, SyncItem* item, const BCHAR* defaultType) EXTRA_SECTION_01;
+        
+        /*
+        * Add a SyncItem into the modificationCommand. It is responsible to collapse if needed
+        */
+        void addItem(ModificationCommand* modificationCommand, BCHAR* COMMAND, SyncItem* syncItem, const BCHAR* defaultType) EXTRA_SECTION_01;
+        
+        /*
+        * Reset the cmdID counter
+        */
+        void resetCommandID() EXTRA_SECTION_01;
+
+        /*
+        * increase the msgID counter
+        */
+        void increaseMsgRef() EXTRA_SECTION_01;
+        
+        /*
+        * reset MsgId counter
+        */
+        
+        void resetMessageID() EXTRA_SECTION_01;
+        
+        /**
+         * Sets the items content encoding
+         */
+        void setEncoding(DataEncoding e) EXTRA_SECTION_01;
+
+        /**
+         * Returns the items content encoding
+         */
+        DataEncoding getEncoding() EXTRA_SECTION_01;
+
+        /**
+         * Sets the encryption password
+         *
+         * @param pwd encryption password - NOT NULL
+         */
+        void setEncPassword(const BCHAR* pwd);
+        
+        /*
+        * reset MsgRef counter
+        */
+        void resetMsgRef();
+
+    private:
+
+        void initialize();
+
+        BCHAR* target;
+        BCHAR* device;
+        unsigned long maxMsgSize;        
+        BCHAR* encPassword;
+
+        unsigned long sessionID;
+        unsigned int  msgID    ;
+        unsigned int  cmdID    ;
+        unsigned int  msgRef   ;
+        
+        DataEncoding encoding;
+
+        BCHAR* encodeB64(char* data, TransformationInfo& info);   
+        BCHAR* encodeDESB64(char* data, TransformationInfo& info);
+        ComplexData* getComplexData(SyncItem* syncItem);
+
+};
+
+#endif
--- native/src/c++/common/spds/SyncMLBuilder.cpp~item-type
+++ native/src/c++/common/spds/SyncMLBuilder.cpp
@@ -1,886 +1,904 @@
-/*
- * Copyright (C) 2003-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <string.h>
-
-#include "base/fscapi.h"
-#include "base/base64.h"
-#include "base/util/utils.h"
-#include "base/util/StringBuffer.h"
-#include "filter/ClauseUtil.h"
-#include "spds/constants.h"
-#include "spds/DataTransformerFactory.h"
-#include "spds/SyncItem.h"
-#include "spds/SyncMLBuilder.h"
-
-
-
-SyncMLBuilder::SyncMLBuilder() {
-    initialize();
-    set(NULL, NULL, 0);
-}
-
-SyncMLBuilder::~SyncMLBuilder() {
-    safeDelete(&target  );    
-    safeDelete(&device  );     
-    safeDelete(&encPassword);
-}
-
-
-SyncMLBuilder::SyncMLBuilder(BCHAR* t, BCHAR* d, unsigned long msgSize) {
-    initialize();
-    set(t, d, msgSize);
-}
-
-void SyncMLBuilder::set(BCHAR* t, BCHAR* d, unsigned long msgSize) {    
-
-    target   = stringdup(t);   
-    device   = stringdup(d);   
-    maxMsgSize = msgSize;
-}
-
-void SyncMLBuilder::initialize() {
-    sessionID = (unsigned long)time(NULL);
-    msgRef    = 0         ;
-    msgID     = 0         ;
-    cmdID     = 0         ;
-    maxMsgSize = 0        ;      
-    encoding   = PLAIN    ;
-    encPassword = NULL    ;
-}
-
-void SyncMLBuilder::setEncoding(DataEncoding e) {
-    encoding = e;
-}
-
-DataEncoding SyncMLBuilder::getEncoding() {
-    return encoding;
-}
-
-void SyncMLBuilder::resetCommandID() {
-    cmdID = 0;
-}
-
-void SyncMLBuilder::increaseMsgRef() {
-    msgRef++;
-}
-
-void SyncMLBuilder::resetMsgRef() {
-    msgRef = 0;
-}
-
-void SyncMLBuilder::addItemStatus(ArrayList* previousStatus, Status* status) {
-    
-    if (previousStatus->size() == 0) {
-        previousStatus->add(*status);
-        return;
-    }
-    
-    BOOL found    = FALSE;    
-    Status* s     = NULL;
-
-    if (status == NULL)
-        return;
-    ArrayList* list = new ArrayList();
-    for (int i = 0; i < previousStatus->size(); i++) {
-    
-        s = (Status*)previousStatus->get(i);
-        if ((bstrcmp(s->getCmd(NULL), status->getCmd(NULL)) == 0) &&
-            (bstrcmp(s->getData()->getData(NULL), status->getData()->getData(NULL)) == 0) &&  
-            (bstrcmp(s->getCmdRef(NULL), status->getCmdRef(NULL)) == 0) ) {                    
-                    list = s->getItems();
-                    for (int j = 0; j < status->getItems()->size(); j++) {                        
-                        list->add(*((Item*)(status->getItems())->get(j)));  
-                        found = TRUE;
-                    }                    
-                }                               
-                                                    
-    }    
-    if (!found)
-        previousStatus->add(*status);
-    
-}
-
-
-
-/*
-* Return the status of the items sent by server. Used to create the status to respond
-* after a add, replace or delete command
-*/
-Status* SyncMLBuilder::prepareItemStatus(const BCHAR* COMMAND,
-                                         const BCHAR* key,
-                                         const BCHAR* cmdRef,
-                                         int code) {
-    /*                                                                                               
-    <Status>                                 CmdID*        cmdID     ,                           
-        <CmdID>3</CmdID>                     BCHAR*      msgRef    ,                           
-        <MsgRef>2</MsgRef>                   BCHAR*      cmdRef    ,                           
-        <CmdRef>4</CmdRef>                   BCHAR*      cmd       ,                           
-        <Cmd>Replace</Cmd>                   ArrayList*    targetRefs,                           
-        <Data>201</Data>                     ArrayList*    sourceRefs,                           
-        <Item>                               Cred*         cred      ,                           
-            <Source>                         Chal*         chal      ,                           
-            <LocURI>item0</LocURI>           Data*         data      ,                           
-            </Source>                        ArrayList*    items     );                          
-        </Item>                                                                                  
-        <Item>                                                                                   
-            <Source>                                                                             
-            <LocURI>item1</LocURI>                                                               
-            </Source>                                                                            
-        </Item>                                                                                  
-    </Status>                                                                                    
-    */                                                                                           
-
-    ++cmdID;
-    BCHAR* cmdid = itow(cmdID);
-    CmdID* commandID  = new CmdID(cmdid);    
-    ArrayList* empty  = new ArrayList();    
-    Data*      data   = new Data(code);    
-    ArrayList* list   = new ArrayList();                
-    Source* sou       = new Source(key);   
-    Item* item        = new Item(NULL, sou, NULL, NULL, FALSE);
-    list->add(*item);
-
-    BCHAR *mRef = itow(msgRef);
-    Status* s = new Status(commandID, mRef, cmdRef, COMMAND, empty, empty, NULL, NULL, data, list);
-    delete [] mRef;
-    
-    safeDelete(&cmdid);
-    deleteCmdID(&commandID);
-    deleteData(&data);
-    deleteSource(&sou);    
-    deleteItem(&item);
-    deleteArrayList(&empty);
-    deleteArrayList(&list);
-    if (list)  { delete list; list = NULL; }
-    if (empty) { delete empty; empty = NULL; }
-
-    return s;
-
-}
-
-/*
-* Return the status of the server authentication process
-*/
-Status* SyncMLBuilder::prepareSyncHdrStatus(Chal*chal, int d) {
-    
-    ++cmdID;
-    BCHAR* cmdid = itow(cmdID);
-    CmdID* commandID         = new CmdID(cmdid);
-    ArrayList*    targetRefs = new ArrayList();
-    ArrayList*    sourceRefs = new ArrayList();
-    TargetRef*    tar        = new TargetRef(target);
-    SourceRef*    sou        = new SourceRef(device);   
-    Data*      data          = new Data(d);
-    targetRefs->add(*tar);
-    sourceRefs->add(*sou);
-
-    Status* s = new Status(commandID, itow(msgRef), T("0"), SYNC_HDR, targetRefs, sourceRefs, NULL, chal, data, NULL);
-    
-    safeDelete(&cmdid);
-    deleteCmdID(&commandID);
-    deleteArrayList(&targetRefs);
-    deleteArrayList(&sourceRefs);
-    deleteTargetRef(&tar);
-    deleteSourceRef(&sou);
-    deleteData(&data);
-
-    return s;
-
-}
-
-Status* SyncMLBuilder::prepareSyncStatus(SyncSource& source, Sync* sync) {
-    if (sync == NULL)
-        return NULL;
-    
-    ++cmdID;
-
-    CmdID* commandID         = new CmdID(itow(cmdID));
-    ArrayList*    targetRefs = new ArrayList();
-    ArrayList*    sourceRefs = new ArrayList();
-    CmdID* cmdRef            = sync->getCmdID();
-
-    
-    TargetRef*    tar        = new TargetRef(_wcc(source.getRemoteURI()));
-    SourceRef*    sou        = new SourceRef(_wcc(source.getName()));
-    targetRefs->add(*tar);
-    sourceRefs->add(*sou);
-    Data* d                  = new Data(200);
-    
-    Status* s = new Status(commandID, itow(msgRef), cmdRef->getCmdID(), SYNC, targetRefs, sourceRefs, NULL, NULL, d, NULL);
-
-    deleteCmdID(&commandID);
-    deleteArrayList(&targetRefs);
-    deleteArrayList(&sourceRefs);
-    deleteTargetRef(&tar);
-    deleteSourceRef(&sou);    
-    deleteData(&d);
-
-    return s;
-
-}
-
-
-/*
-* Return the status against an alert command. It could be releated on the authentication process
-* or any other else
-*/
-Status* SyncMLBuilder::prepareAlertStatus(SyncSource& source, ArrayList* alerts, int authStatusCode) {
-    /*
-    next = source.getNextAnchor(NULL);
-    <Status>\n
-        <CmdID>2</CmdID>\n
-        <MsgRef>1</MsgRef>
-        <CmdRef>1</CmdRef>
-        <Cmd>Alert</Cmd>\n
-        <TargetRef>
-            sb.append(source.getRemoteURI(NULL));
-        </TargetRef>\n
-        <SourceRef>
-            sb.append(source.getName(NULL, -1));
-        </SourceRef>\n
-        <Data>200</Data>\n
-        <Item>\n
-            <Data>
-                <Anchor xmlns='syncml:metinf'>
-                    <Next>
-                        sb.append(next);    
-                    </Next>
-                </Anchor>\n
-            </Data>\n
-        </Item>\n
-    </Status>
-    */
-    
-    if (alerts == NULL || alerts->size() == 0)
-        return NULL;
-    
-    Alert* a = NULL;
-    Item* item = NULL;
-    ArrayList* list = new ArrayList();
-    BOOL found = FALSE;
-
-    for (int i = 0; i < alerts->size(); i++) {
-        a = (Alert*)alerts->get(i);
-        list = a->getItems();
-        if (list->size() == 1) {
-            item = (Item*)list->get(0);
-            if (bstrcmp(item->getTarget()->getLocURI(), _wcc(source.getName())) == 0) {
-                found = TRUE;
-            }
-        }
-    }
-    
-    //
-    // Currently it returns null. It could return a status value if necessary
-    //
-    if (!found) {
-        return NULL;
-
-    }
-
-    ++cmdID;
-
-    CmdID* commandID         = new CmdID(itow(cmdID));
-    ArrayList*    targetRefs = new ArrayList();
-    ArrayList*    sourceRefs = new ArrayList();
-    
-    TargetRef*    tar        = new TargetRef(_wcc(source.getRemoteURI()));
-    SourceRef*    sou        = new SourceRef(_wcc(source.getName()));
-    targetRefs->add(*tar);
-    sourceRefs->add(*sou);
-    CmdID* cmdRef            = a->getCmdID();
-    BCHAR* next            = NULL;
-    int authStatus           = 0;
-    
-    if (authStatusCode >= 200 && authStatusCode <=299)
-        authStatus = 200;
-     else
-        authStatus = authStatusCode;
-
-    Data* d              = new Data(authStatus);
-    ComplexData* data    = NULL;
-    ArrayList* items     = new ArrayList();
-    Anchor*    anchor    = NULL;
-
-    if (authStatusCode < 400) {
-        list = a->getItems();
-        if (list->size() > 0) {
-            for (int i = 0; i < list->size(); i++) {
-                Item* it = (Item*)list->get(i);
-                Meta* m = it->getMeta();
-                if (m) {
-                    anchor = m->getAnchor();
-                    next = stringdup(anchor->getNext());
-                }
-
-            }
-
-            anchor = new Anchor(NULL, next);
-            data = new ComplexData();
-            data->setAnchor(anchor);
-            item           = new Item(NULL, NULL, NULL, data, FALSE);        
-            items->add(*item);
-        }
-    }
-    
-    Status* s = new Status(commandID, itow(msgRef), cmdRef->getCmdID(), ALERT, targetRefs, sourceRefs, NULL, NULL, d, items);
-    
-    deleteCmdID(&commandID);
-    deleteArrayList(&targetRefs);
-    deleteArrayList(&sourceRefs);
-    deleteTargetRef(&tar);
-    deleteSourceRef(&sou);
-    deleteItem(&item);
-    deleteAnchor(&anchor);
-    deleteComplexData(&data);    
-    deleteData(&d);
-    safeDel(&next);
-
-    return s;
-}
-
-Alert* SyncMLBuilder::prepareRequestAlert(SyncSource& s) {
-    
-    ++cmdID;
-
-    CmdID* commandID     = new CmdID(itow(cmdID));    
-    Target* tar          = new Target(_wcc(s.getRemoteURI()));
-    Source* sou          = new Source(_wcc(s.getName()));     
-    Item* item           = new Item(tar, sou, NULL, NULL, FALSE);
-
-    ArrayList* list      = new ArrayList();    
-    list->add(*item);    
-    Alert* alert         = new Alert(commandID, false, NULL, 222, list);
-    
-    deleteTarget(&tar);
-    deleteSource(&sou);
-    deleteItem(&item);
-    deleteCmdID(&commandID);
-    deleteArrayList(&list);
-
-    return alert;
-}
-
-Alert* SyncMLBuilder::prepareInitAlert(SyncSource& s) {
-    
-    ++cmdID;
-
-    CmdID* commandID     = new CmdID(itow(cmdID));
-    int data             = s.getPreferredSyncMode();
-    Target* tar          = new Target(_wcc(s.getRemoteURI()));    
-    Source* sou          = new Source(_wcc(s.getName()));
-
-    //
-    // Read the clause filter from the source and translate
-    // it into a Filter. This must be assigned to the Target
-    //
-    SourceFilter* sourceFilter = s.getFilter();
-    if (sourceFilter) {
-        Filter* filter = ClauseUtil::toFilter(*sourceFilter);
-        tar->setFilter(filter);
-        delete filter; filter = NULL;
-    }
-    
-    Anchor*    anchor    = new Anchor(s.getLastAnchor(), s.getNextAnchor());    
-    MetInf* metInf       = new MetInf(NULL, NULL, NULL, NULL, 
-                               anchor, NULL, NULL, NULL, NULL, NULL, NULL); 
-    Meta* meta           = new Meta();
-    meta->setMetInf(metInf);
-    Item* item           = new Item(tar, sou, meta, NULL, FALSE);
-
-    ArrayList* list      = new ArrayList();    
-    list->add(*item);    
-    Alert* alert         = new Alert(commandID, false, NULL, data, list);    
-    
-    deleteCmdID(&commandID);
-    deleteTarget(&tar);
-    if(sou)
-        delete sou;
-    deleteAnchor(&anchor);
-    deleteMetInf(&metInf);
-    deleteMeta(&meta);
-    deleteItem(&item);
-    deleteArrayList(&list);
-    
-    return alert;
-}
-
-Alert* SyncMLBuilder::prepareAddrChangeAlert(SyncSource& s) {
-    
-    SyncItem *syncItem;
-    ArrayList list;
-    for(syncItem = s.getFirstItem(); syncItem; syncItem = s.getNextItem()) {
-        int size = syncItem->getDataSize();        
-        
-        if( syncItem && size ) {  // only valid items
-            
-            char* syncData = new char[size + 1];
-            memset(syncData, 0, size + 1);
-            memcpy (syncData, (char*)syncItem->getData(), size);
-             
-            ComplexData addr( syncData );
-            Target target( T("") );
-            Source source(_wcc(syncItem->getKey()));
-            // Build Item
-            Item item(&target, &source, NULL, &addr, FALSE);
-            // Add it to the list
-            list.add(item);
-
-            delete [] syncData;
-        }
-    }
-    /*
-    for(syncItem = s.getFirstItem(); syncItem; syncItem = s.getNextItem()) {
-        int size = syncItem->getDataSize()/sizeof(BCHAR);
-        BCHAR *syncData = (BCHAR *)syncItem->getData();
-
-        if( syncItem && size ) {  // only valid items
-
-            // Add the syncItem data as zero terminated string
-            StringBuffer itemData(syncData, size);
-            ComplexData addr( itemData.c_str() );
-            Target target( T("") );
-            Source source(syncItem->getKey());
-            // Build Item
-            Item item(&target, &source, NULL, &addr, FALSE);
-            // Add it to the list
-            list.add(item);
-        }
-    }
-    */
-    // If no valid items were provided by the syncsource
-    // return null alert
-    if(list.isEmpty())
-        return NULL;
-
-    // Ok, prepare the message
-    cmdID++;
-
-    CmdID commandID(itow(cmdID));
-    int data = s.getPreferredSyncMode();
-
-    Alert* alert = new Alert(&commandID, false, NULL, data, &list);
-    
-    return alert;
-}
-
-SyncHdr* SyncMLBuilder::prepareSyncHdr(Cred* cred) {
-
-    ++msgID;
-
-    VerDTD*    verDTD    = new VerDTD(T("1.1"));
-    VerProto*  verProto  = new VerProto(T("SyncML/1.1"));
-    SessionID* sessID    = new SessionID(ltow(sessionID));
-    BCHAR*   messageID = itow(msgID);
-    Target*    tar       = new Target(target);
-    Source*    sou       = new Source(device);       
-    Meta* meta           = NULL;
-
-    if (maxMsgSize > 0) {
-        MetInf* metInf = new MetInf(NULL, NULL, NULL, NULL, 
-                                    NULL, NULL, NULL, maxMsgSize,
-                                    NULL, NULL, NULL); 
-        meta = new Meta();
-        meta->setMetInf(metInf);
-        deleteMetInf(&metInf);
-    }
-    SyncHdr* syncHdr = new SyncHdr(verDTD, verProto, sessID, messageID, 
-                                   tar, sou, NULL, false, cred, meta); //respUri e Meta are null
-
-    deleteVerDTD(&verDTD);
-    deleteVerProto(&verProto);
-    deleteSessionID(&sessID);
-    deleteSource(&sou);
-    deleteTarget(&tar);    
-    safeDel(&messageID);    
-
-    return syncHdr;    
-}
-
-SyncML* SyncMLBuilder::prepareInitObject(Cred* cred, ArrayList* alerts, ArrayList* commands) {
-
-    SyncHdr* syncHdr     = prepareSyncHdr(cred);
-    SyncML*  syncml      = NULL;               
-    ArrayList* list      = new ArrayList();
-    SyncBody* syncBody   = NULL;
-
-    if (!commands->isEmpty()) {
-        list = commands->clone();
-    }    
-    if (alerts && alerts->size() > 0) {
-        for (int k = 0; k < alerts->size(); k++)
-            list->add(*(Alert*)alerts->get(k));        
-    }
-        
-    
-    syncBody   = new SyncBody(list, TRUE);
-    deleteArrayList(&list);
-    syncml       = new SyncML(syncHdr, syncBody);
-
-    deleteSyncHdr(&syncHdr);
-    deleteSyncBody(&syncBody);   
-    
-    return syncml;
-}
-
-BCHAR* SyncMLBuilder::prepareMsg(SyncML* syncml) {        
-    StringBuffer *s = Formatter::getSyncML(syncml);
-    BCHAR* str = stringdup(s->c_str());
-    delete s;
-    return str;
-}
-
-
-SyncML* SyncMLBuilder::prepareSyncML(ArrayList* commands, BOOL final) {    
-    
-    SyncHdr* syncHdr = prepareSyncHdr(NULL);       
-    SyncBody* syncBody   = new SyncBody(commands, final);       
-    SyncML* syncml = new SyncML(syncHdr, syncBody);
-    deleteSyncHdr(&syncHdr);    
-    deleteSyncBody(&syncBody);
-
-    return syncml;
-}
-
-ComplexData* SyncMLBuilder::getComplexData(SyncItem* syncItem) {
-    
-        BCHAR* t   = NULL;
-        TransformationInfo info;
-        ComplexData* data = NULL;
-
-        info.size = syncItem->getDataSize();
-        info.password = encPassword;
-        if (encoding == DESB64) {
-            char* tt = new char[info.size + 1];
-            memset(tt, 0, info.size + 1);            
-            memcpy(tt, syncItem->getData(), syncItem->getDataSize());                        
-            t = encodeDESB64(tt, info);
-            delete [] tt;
-        } else if (encoding == B64) {
-            char* tt = new char[info.size + 1];
-            memset(tt, 0, info.size + 1);            
-            memcpy(tt, syncItem->getData(), syncItem->getDataSize());            
-            t = encodeB64(tt, info);
-            delete [] tt;
-        } else {
-            t = new BCHAR[info.size + 1];
-            memset(t, 0, info.size + 1);            
-            memcpy(t, syncItem->getData(), syncItem->getDataSize());
-        }
-                           
-        data = new ComplexData(t);
-        
-        if (t)
-            {delete [] t; t = NULL; }
-        
-        return data;
-}
-
-
-ArrayList* SyncMLBuilder::prepareItem(SyncItem* syncItem, const BCHAR* type, BCHAR* COMMAND) {
-    ArrayList* list = new ArrayList();            
-    
-    Source* sou = new Source(_wcc(syncItem->getKey()));
-    ComplexData* data = NULL;
-    Meta m;
-    if (bstrcmp(DELETE_COMMAND_NAME, COMMAND) != 0) {       
-        if (encoding == DESB64) {
-            m.setFormat(T("des;b64"));         
-        } else if (encoding == B64) {
-            m.setFormat(T("b64"));            
-        } 
-        data = getComplexData(syncItem);
-
-    }
-    
-    BCHAR *tparent = toMultibyte(syncItem->getTargetParent());
-    BCHAR *sparent = toMultibyte(syncItem->getSourceParent());
-
-    Item* item = new Item(NULL, sou, tparent, sparent, &m, data, FALSE);
-    list->add(*item);
-
-    delete [] tparent;
-    delete [] sparent;
-
-    deleteSource(&sou);
-    deleteComplexData(&data);
-    deleteItem(&item);
-
-    return list;   
-}
-
-/*
-* Prepare an empty modification command without any commands. They will be added with the insertItem method
-*/
-ModificationCommand* SyncMLBuilder::prepareModificationCommand(BCHAR* COMMAND, SyncItem* syncItem, const BCHAR* type) {        
-    
-    if (syncItem == NULL) {
-         return NULL;
-    }
-    ++cmdID;
-    CmdID* commandID     = new CmdID(itow(cmdID));
-
-    ModificationCommand* ret = NULL;
-    MetInf* metInf       = new MetInf(NULL, (BCHAR*)type, NULL, NULL, 
-                                      NULL, NULL, NULL, NULL, NULL, NULL, NULL); 
-    Meta* meta           = new Meta();
-    meta->setMetInf(metInf);
-    
-    ArrayList* list = new ArrayList();
-    if (syncItem) {
-        ArrayList* tmpList = prepareItem(syncItem, type, COMMAND);
-        list->add(tmpList);
-        deleteArrayList(&tmpList);
-    }
-    if (bstrcmp(ADD_COMMAND_NAME, COMMAND) == 0)
-        ret = new Add(commandID, FALSE, NULL, meta, list);
-    else if (bstrcmp(REPLACE_COMMAND_NAME, COMMAND) == 0){
-        ret = new Replace(commandID, FALSE, NULL, meta, list);
-    } else if (bstrcmp(DELETE_COMMAND_NAME, COMMAND) == 0) {
-        ret = new Delete(commandID, FALSE, FALSE, FALSE, NULL, meta, list);
-    }
-    
-    deleteMetInf(&metInf);
-    deleteCmdID(&commandID);
-    deleteArrayList(&list);
-    deleteMeta(&meta);
-
-    return ret;
-}
-
-/*
-* Add another item into the 
-*/
-void SyncMLBuilder::addItem(ModificationCommand* modificationCommand, BCHAR* COMMAND, SyncItem* syncItem, const BCHAR* type) {        
-    
-    if (syncItem == NULL || modificationCommand == NULL) {
-         return;
-    }       
-    
-    ArrayList* list = modificationCommand->getItems();
-    ArrayList* tmpList = prepareItem(syncItem, type, COMMAND);
-    list->add(tmpList);
-    deleteArrayList(&tmpList);
-}
-
-Sync* SyncMLBuilder::prepareSyncCommand(SyncSource& source) {            
-
-    ++cmdID;
-
-    CmdID* commandID     = new CmdID(itow(cmdID));
-    Target* tar          = new Target(_wcc(source.getRemoteURI()));
-    Source* sou          = new Source(_wcc(source.getName())); 
-    ArrayList* list      = new ArrayList();  
-    Sync* sync           = NULL;
-         
-    sync = new Sync(commandID, FALSE, NULL, tar, sou, NULL, 0,  list);
-
-    deleteCmdID(&commandID);
-    deleteTarget(&tar);
-    deleteSource(&sou);
-    deleteArrayList(&list);
-
-    return sync;  
-    
-}
-
-
-Map* SyncMLBuilder::prepareMapCommand(SyncSource& s) {
-    /*
-    CmdID* cmdID,
-    Target* target,
-    Source* source,
-    Cred* cred,
-    Meta* meta,
-    ArrayList* mapItems);
-    */
-    ++cmdID;
-    CmdID* commandID     = new CmdID(itow(cmdID));    
-    Target* tar          = new Target(_wcc(s.getRemoteURI()));
-    Source* sou          = new Source(_wcc(s.getName()));
-    ArrayList* mapItems  = new ArrayList();
-    Map* map = new Map(commandID, tar, sou, NULL, NULL, mapItems);
-
-    deleteCmdID(&commandID);
-    deleteTarget(&tar);
-    deleteSource(&sou);
-    deleteArrayList(&mapItems);
-
-    return map;
-
-}
-
-MapItem* SyncMLBuilder::prepareMapItem(SyncMap* syncMap) {
-      
-    Target* tar          = new Target(syncMap->getGUID());
-    Source* sou          = new Source(syncMap->getLUID());    
-    MapItem* m = new MapItem(tar, sou);
-    deleteTarget(&tar);
-    deleteSource(&sou);
-    
-    return m;
-}
-
-void SyncMLBuilder::addMapItem(Map* map, MapItem* mapItem){
-    if (mapItem == NULL || map == NULL)
-        return;
-    ArrayList* list = map->getMapItems();
-    list->add(*mapItem);
-
-}
-
-void SyncMLBuilder::resetMessageID() {
-    msgID = 0;
-}
-
-void SyncMLBuilder::setEncPassword(const BCHAR* pwd) {
-    if (encPassword) {
-        safeDelete(&encPassword);
-    }
-
-    if (pwd) {
-        encPassword = stringdup(pwd);
-    }
-}
-
-BCHAR* SyncMLBuilder::encodeDESB64(char* data, TransformationInfo& info) {
-    char*    des = NULL;
-    char*    b64 = NULL;
-    BCHAR* ret = NULL;
-
-    DataTransformer* dtdes = DataTransformerFactory::getEncoder(T("des"));
-    DataTransformer* dtb64 = DataTransformerFactory::getEncoder(T("b64"));
-
-    if ((dtdes == NULL) || (dtb64 == NULL)) {
-        goto exit;
-    }
-
-    des = dtdes->transform(data, info);
-
-    if (lastErrorCode != ERR_NONE) {
-        goto exit;
-    }
-
-    b64 = dtb64->transform(des, info);
-
-    if (lastErrorCode != ERR_NONE) {
-        goto exit;
-    }
-
-    //
-    // We now translate it into a wchar zero-terminated string 
-    //
-    ret = utf82wc(b64, NULL, 0);
-
-    ++info.size;
-    // info.size = (bstrlen(ret)+1)*sizeof(BCHAR);
-
-
-exit:
-
-    if (des) {
-        delete [] des; des = NULL;
-    }
-
-    if (b64) {
-        delete [] b64; b64 = NULL;
-    }
-
-    if (dtdes) {
-        delete dtdes;
-    }
-
-    if (dtb64) {
-        delete dtb64;
-    }
-
-    return ret;
-}
-
-BCHAR* SyncMLBuilder::encodeB64(char* data, TransformationInfo& info) {
-    char*    b64 = NULL;
-    BCHAR* ret = NULL;
-    DataTransformer* dtb64 = DataTransformerFactory::getEncoder(T("b64"));
-
-    if (dtb64 == NULL) {
-        goto exit;
-    }
-
-    b64 = dtb64->transform((char*)data, info);
-
-    //
-    // We now translate it into a wchar zero-terminated string 
-    //
-    ret = utf82wc(b64);
-
-    ++info.size;
-    // info.size = (bstrlen(ret)+1)*sizeof(BCHAR);
-
-exit:
-
-    if (b64) {
-        delete [] b64; b64 = NULL;
-    }
-
-    if (dtb64) {
-        delete dtb64;
-    }
-
-    return ret;
-}
-
-/*
-ComplexData* SyncMLBuilder::getComplexData(SyncItem* syncItem) {
-    
-        BCHAR* t   = NULL;
-        char*    tmp = NULL;
-        TransformationInfo info;
-        ComplexData* data = NULL;
-
-        info.size = syncItem->getDataSize() / sizeof(BCHAR);
-        info.password = encPassword;
-        if (encoding == DESB64) {
-            BCHAR* tt = new BCHAR[info.size + 1];
-            wmemset(tt, 0, info.size + 1);            
-            memcpy(tt, syncItem->getData(), syncItem->getDataSize());            
-            tmp = wc2utf8(tt);            
-            t = encodeDESB64(tmp, info);
-            delete [] tt;
-        } else if (encoding == B64) {
-            BCHAR* tt = new BCHAR[info.size + 1];
-            wmemset(tt, 0, info.size + 1);            
-            memcpy(tt, syncItem->getData(), syncItem->getDataSize());
-            tmp = wc2utf8(tt);                                          
-            t = encodeB64(tmp, info);
-            delete [] tt;
-        } else {
-            t = new BCHAR[info.size + 1];
-            wmemset(t, 0, info.size + 1);            
-            memcpy(t, syncItem->getData(), syncItem->getDataSize());
-        }
-                           
-        data = new ComplexData(t);
-        
-        if (t) {delete [] t; t = NULL; }
-        if (tmp) {delete [] tmp; tmp = NULL; }
-
-        return data;
-
-}
-*/
\ No newline at end of file
+/*
+ * Copyright (C) 2003-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <string.h>
+
+#include "base/fscapi.h"
+#include "base/base64.h"
+#include "base/util/utils.h"
+#include "base/util/StringBuffer.h"
+#include "filter/ClauseUtil.h"
+#include "spds/constants.h"
+#include "spds/DataTransformerFactory.h"
+#include "spds/SyncItem.h"
+#include "spds/SyncMLBuilder.h"
+
+
+
+SyncMLBuilder::SyncMLBuilder() {
+    initialize();
+    set(NULL, NULL, 0);
+}
+
+SyncMLBuilder::~SyncMLBuilder() {
+    safeDelete(&target  );    
+    safeDelete(&device  );     
+    safeDelete(&encPassword);
+}
+
+
+SyncMLBuilder::SyncMLBuilder(BCHAR* t, BCHAR* d, unsigned long msgSize) {
+    initialize();
+    set(t, d, msgSize);
+}
+
+void SyncMLBuilder::set(BCHAR* t, BCHAR* d, unsigned long msgSize) {    
+
+    target   = stringdup(t);   
+    device   = stringdup(d);   
+    maxMsgSize = msgSize;
+}
+
+void SyncMLBuilder::initialize() {
+    sessionID = (unsigned long)time(NULL);
+    msgRef    = 0         ;
+    msgID     = 0         ;
+    cmdID     = 0         ;
+    maxMsgSize = 0        ;      
+    encoding   = PLAIN    ;
+    encPassword = NULL    ;
+}
+
+void SyncMLBuilder::setEncoding(DataEncoding e) {
+    encoding = e;
+}
+
+DataEncoding SyncMLBuilder::getEncoding() {
+    return encoding;
+}
+
+void SyncMLBuilder::resetCommandID() {
+    cmdID = 0;
+}
+
+void SyncMLBuilder::increaseMsgRef() {
+    msgRef++;
+}
+
+void SyncMLBuilder::resetMsgRef() {
+    msgRef = 0;
+}
+
+void SyncMLBuilder::addItemStatus(ArrayList* previousStatus, Status* status) {
+    
+    if (previousStatus->size() == 0) {
+        previousStatus->add(*status);
+        return;
+    }
+    
+    BOOL found    = FALSE;    
+    Status* s     = NULL;
+
+    if (status == NULL)
+        return;
+    ArrayList* list = new ArrayList();
+    for (int i = 0; i < previousStatus->size(); i++) {
+    
+        s = (Status*)previousStatus->get(i);
+        if ((bstrcmp(s->getCmd(NULL), status->getCmd(NULL)) == 0) &&
+            (bstrcmp(s->getData()->getData(NULL), status->getData()->getData(NULL)) == 0) &&  
+            (bstrcmp(s->getCmdRef(NULL), status->getCmdRef(NULL)) == 0) ) {                    
+                    list = s->getItems();
+                    for (int j = 0; j < status->getItems()->size(); j++) {                        
+                        list->add(*((Item*)(status->getItems())->get(j)));  
+                        found = TRUE;
+                    }                    
+                }                               
+                                                    
+    }    
+    if (!found)
+        previousStatus->add(*status);
+    
+}
+
+
+
+/*
+* Return the status of the items sent by server. Used to create the status to respond
+* after a add, replace or delete command
+*/
+Status* SyncMLBuilder::prepareItemStatus(const BCHAR* COMMAND,
+                                         const BCHAR* key,
+                                         const BCHAR* cmdRef,
+                                         int code) {
+    /*                                                                                               
+    <Status>                                 CmdID*        cmdID     ,                           
+        <CmdID>3</CmdID>                     BCHAR*      msgRef    ,                           
+        <MsgRef>2</MsgRef>                   BCHAR*      cmdRef    ,                           
+        <CmdRef>4</CmdRef>                   BCHAR*      cmd       ,                           
+        <Cmd>Replace</Cmd>                   ArrayList*    targetRefs,                           
+        <Data>201</Data>                     ArrayList*    sourceRefs,                           
+        <Item>                               Cred*         cred      ,                           
+            <Source>                         Chal*         chal      ,                           
+            <LocURI>item0</LocURI>           Data*         data      ,                           
+            </Source>                        ArrayList*    items     );                          
+        </Item>                                                                                  
+        <Item>                                                                                   
+            <Source>                                                                             
+            <LocURI>item1</LocURI>                                                               
+            </Source>                                                                            
+        </Item>                                                                                  
+    </Status>                                                                                    
+    */                                                                                           
+
+    ++cmdID;
+    BCHAR* cmdid = itow(cmdID);
+    CmdID* commandID  = new CmdID(cmdid);    
+    ArrayList* empty  = new ArrayList();    
+    Data*      data   = new Data(code);    
+    ArrayList* list   = new ArrayList();                
+    Source* sou       = new Source(key);   
+    Item* item        = new Item(NULL, sou, NULL, NULL, FALSE);
+    list->add(*item);
+
+    BCHAR *mRef = itow(msgRef);
+    Status* s = new Status(commandID, mRef, cmdRef, COMMAND, empty, empty, NULL, NULL, data, list);
+    delete [] mRef;
+    
+    safeDelete(&cmdid);
+    deleteCmdID(&commandID);
+    deleteData(&data);
+    deleteSource(&sou);    
+    deleteItem(&item);
+    deleteArrayList(&empty);
+    deleteArrayList(&list);
+    if (list)  { delete list; list = NULL; }
+    if (empty) { delete empty; empty = NULL; }
+
+    return s;
+
+}
+
+/*
+* Return the status of the server authentication process
+*/
+Status* SyncMLBuilder::prepareSyncHdrStatus(Chal*chal, int d) {
+    
+    ++cmdID;
+    BCHAR* cmdid = itow(cmdID);
+    CmdID* commandID         = new CmdID(cmdid);
+    ArrayList*    targetRefs = new ArrayList();
+    ArrayList*    sourceRefs = new ArrayList();
+    TargetRef*    tar        = new TargetRef(target);
+    SourceRef*    sou        = new SourceRef(device);   
+    Data*      data          = new Data(d);
+    targetRefs->add(*tar);
+    sourceRefs->add(*sou);
+
+    Status* s = new Status(commandID, itow(msgRef), T("0"), SYNC_HDR, targetRefs, sourceRefs, NULL, chal, data, NULL);
+    
+    safeDelete(&cmdid);
+    deleteCmdID(&commandID);
+    deleteArrayList(&targetRefs);
+    deleteArrayList(&sourceRefs);
+    deleteTargetRef(&tar);
+    deleteSourceRef(&sou);
+    deleteData(&data);
+
+    return s;
+
+}
+
+Status* SyncMLBuilder::prepareSyncStatus(SyncSource& source, Sync* sync) {
+    if (sync == NULL)
+        return NULL;
+    
+    ++cmdID;
+
+    CmdID* commandID         = new CmdID(itow(cmdID));
+    ArrayList*    targetRefs = new ArrayList();
+    ArrayList*    sourceRefs = new ArrayList();
+    CmdID* cmdRef            = sync->getCmdID();
+
+    
+    TargetRef*    tar        = new TargetRef(_wcc(source.getRemoteURI()));
+    SourceRef*    sou        = new SourceRef(_wcc(source.getName()));
+    targetRefs->add(*tar);
+    sourceRefs->add(*sou);
+    Data* d                  = new Data(200);
+    
+    Status* s = new Status(commandID, itow(msgRef), cmdRef->getCmdID(), SYNC, targetRefs, sourceRefs, NULL, NULL, d, NULL);
+
+    deleteCmdID(&commandID);
+    deleteArrayList(&targetRefs);
+    deleteArrayList(&sourceRefs);
+    deleteTargetRef(&tar);
+    deleteSourceRef(&sou);    
+    deleteData(&d);
+
+    return s;
+
+}
+
+
+/*
+* Return the status against an alert command. It could be releated on the authentication process
+* or any other else
+*/
+Status* SyncMLBuilder::prepareAlertStatus(SyncSource& source, ArrayList* alerts, int authStatusCode) {
+    /*
+    next = source.getNextAnchor(NULL);
+    <Status>\n
+        <CmdID>2</CmdID>\n
+        <MsgRef>1</MsgRef>
+        <CmdRef>1</CmdRef>
+        <Cmd>Alert</Cmd>\n
+        <TargetRef>
+            sb.append(source.getRemoteURI(NULL));
+        </TargetRef>\n
+        <SourceRef>
+            sb.append(source.getName(NULL, -1));
+        </SourceRef>\n
+        <Data>200</Data>\n
+        <Item>\n
+            <Data>
+                <Anchor xmlns='syncml:metinf'>
+                    <Next>
+                        sb.append(next);    
+                    </Next>
+                </Anchor>\n
+            </Data>\n
+        </Item>\n
+    </Status>
+    */
+    
+    if (alerts == NULL || alerts->size() == 0)
+        return NULL;
+    
+    Alert* a = NULL;
+    Item* item = NULL;
+    ArrayList* list = new ArrayList();
+    BOOL found = FALSE;
+
+    for (int i = 0; i < alerts->size(); i++) {
+        a = (Alert*)alerts->get(i);
+        list = a->getItems();
+        if (list->size() == 1) {
+            item = (Item*)list->get(0);
+            if (bstrcmp(item->getTarget()->getLocURI(), _wcc(source.getName())) == 0) {
+                found = TRUE;
+            }
+        }
+    }
+    
+    //
+    // Currently it returns null. It could return a status value if necessary
+    //
+    if (!found) {
+        return NULL;
+
+    }
+
+    ++cmdID;
+
+    CmdID* commandID         = new CmdID(itow(cmdID));
+    ArrayList*    targetRefs = new ArrayList();
+    ArrayList*    sourceRefs = new ArrayList();
+    
+    TargetRef*    tar        = new TargetRef(_wcc(source.getRemoteURI()));
+    SourceRef*    sou        = new SourceRef(_wcc(source.getName()));
+    targetRefs->add(*tar);
+    sourceRefs->add(*sou);
+    CmdID* cmdRef            = a->getCmdID();
+    BCHAR* next            = NULL;
+    int authStatus           = 0;
+    
+    if (authStatusCode >= 200 && authStatusCode <=299)
+        authStatus = 200;
+     else
+        authStatus = authStatusCode;
+
+    Data* d              = new Data(authStatus);
+    ComplexData* data    = NULL;
+    ArrayList* items     = new ArrayList();
+    Anchor*    anchor    = NULL;
+
+    if (authStatusCode < 400) {
+        list = a->getItems();
+        if (list->size() > 0) {
+            for (int i = 0; i < list->size(); i++) {
+                Item* it = (Item*)list->get(i);
+                Meta* m = it->getMeta();
+                if (m) {
+                    anchor = m->getAnchor();
+                    next = stringdup(anchor->getNext());
+                }
+
+            }
+
+            anchor = new Anchor(NULL, next);
+            data = new ComplexData();
+            data->setAnchor(anchor);
+            item           = new Item(NULL, NULL, NULL, data, FALSE);        
+            items->add(*item);
+        }
+    }
+    
+    Status* s = new Status(commandID, itow(msgRef), cmdRef->getCmdID(), ALERT, targetRefs, sourceRefs, NULL, NULL, d, items);
+    
+    deleteCmdID(&commandID);
+    deleteArrayList(&targetRefs);
+    deleteArrayList(&sourceRefs);
+    deleteTargetRef(&tar);
+    deleteSourceRef(&sou);
+    deleteItem(&item);
+    deleteAnchor(&anchor);
+    deleteComplexData(&data);    
+    deleteData(&d);
+    safeDel(&next);
+
+    return s;
+}
+
+Alert* SyncMLBuilder::prepareRequestAlert(SyncSource& s) {
+    
+    ++cmdID;
+
+    CmdID* commandID     = new CmdID(itow(cmdID));    
+    Target* tar          = new Target(_wcc(s.getRemoteURI()));
+    Source* sou          = new Source(_wcc(s.getName()));     
+    Item* item           = new Item(tar, sou, NULL, NULL, FALSE);
+
+    ArrayList* list      = new ArrayList();    
+    list->add(*item);    
+    Alert* alert         = new Alert(commandID, false, NULL, 222, list);
+    
+    deleteTarget(&tar);
+    deleteSource(&sou);
+    deleteItem(&item);
+    deleteCmdID(&commandID);
+    deleteArrayList(&list);
+
+    return alert;
+}
+
+Alert* SyncMLBuilder::prepareInitAlert(SyncSource& s) {
+    
+    ++cmdID;
+
+    CmdID* commandID     = new CmdID(itow(cmdID));
+    int data             = s.getPreferredSyncMode();
+    Target* tar          = new Target(_wcc(s.getRemoteURI()));    
+    Source* sou          = new Source(_wcc(s.getName()));
+
+    //
+    // Read the clause filter from the source and translate
+    // it into a Filter. This must be assigned to the Target
+    //
+    SourceFilter* sourceFilter = s.getFilter();
+    if (sourceFilter) {
+        Filter* filter = ClauseUtil::toFilter(*sourceFilter);
+        tar->setFilter(filter);
+        delete filter; filter = NULL;
+    }
+    
+    Anchor*    anchor    = new Anchor(s.getLastAnchor(), s.getNextAnchor());    
+    MetInf* metInf       = new MetInf(NULL, NULL, NULL, NULL, 
+                               anchor, NULL, NULL, NULL, NULL, NULL, NULL); 
+    Meta* meta           = new Meta();
+    meta->setMetInf(metInf);
+    Item* item           = new Item(tar, sou, meta, NULL, FALSE);
+
+    ArrayList* list      = new ArrayList();    
+    list->add(*item);    
+    Alert* alert         = new Alert(commandID, false, NULL, data, list);    
+    
+    deleteCmdID(&commandID);
+    deleteTarget(&tar);
+    if(sou)
+        delete sou;
+    deleteAnchor(&anchor);
+    deleteMetInf(&metInf);
+    deleteMeta(&meta);
+    deleteItem(&item);
+    deleteArrayList(&list);
+    
+    return alert;
+}
+
+Alert* SyncMLBuilder::prepareAddrChangeAlert(SyncSource& s) {
+    
+    SyncItem *syncItem;
+    ArrayList list;
+    for(syncItem = s.getFirstItem(); syncItem; syncItem = s.getNextItem()) {
+        int size = syncItem->getDataSize();        
+        
+        if( syncItem && size ) {  // only valid items
+            
+            char* syncData = new char[size + 1];
+            memset(syncData, 0, size + 1);
+            memcpy (syncData, (char*)syncItem->getData(), size);
+             
+            ComplexData addr( syncData );
+            Target target( T("") );
+            Source source(_wcc(syncItem->getKey()));
+            // Build Item
+            Item item(&target, &source, NULL, &addr, FALSE);
+            // Add it to the list
+            list.add(item);
+
+            delete [] syncData;
+        }
+    }
+    /*
+    for(syncItem = s.getFirstItem(); syncItem; syncItem = s.getNextItem()) {
+        int size = syncItem->getDataSize()/sizeof(BCHAR);
+        BCHAR *syncData = (BCHAR *)syncItem->getData();
+
+        if( syncItem && size ) {  // only valid items
+
+            // Add the syncItem data as zero terminated string
+            StringBuffer itemData(syncData, size);
+            ComplexData addr( itemData.c_str() );
+            Target target( T("") );
+            Source source(syncItem->getKey());
+            // Build Item
+            Item item(&target, &source, NULL, &addr, FALSE);
+            // Add it to the list
+            list.add(item);
+        }
+    }
+    */
+    // If no valid items were provided by the syncsource
+    // return null alert
+    if(list.isEmpty())
+        return NULL;
+
+    // Ok, prepare the message
+    cmdID++;
+
+    CmdID commandID(itow(cmdID));
+    int data = s.getPreferredSyncMode();
+
+    Alert* alert = new Alert(&commandID, false, NULL, data, &list);
+    
+    return alert;
+}
+
+SyncHdr* SyncMLBuilder::prepareSyncHdr(Cred* cred) {
+
+    ++msgID;
+
+    VerDTD*    verDTD    = new VerDTD(T("1.1"));
+    VerProto*  verProto  = new VerProto(T("SyncML/1.1"));
+    SessionID* sessID    = new SessionID(ltow(sessionID));
+    BCHAR*   messageID = itow(msgID);
+    Target*    tar       = new Target(target);
+    Source*    sou       = new Source(device);       
+    Meta* meta           = NULL;
+
+    if (maxMsgSize > 0) {
+        MetInf* metInf = new MetInf(NULL, NULL, NULL, NULL, 
+                                    NULL, NULL, NULL, maxMsgSize,
+                                    NULL, NULL, NULL); 
+        meta = new Meta();
+        meta->setMetInf(metInf);
+        deleteMetInf(&metInf);
+    }
+    SyncHdr* syncHdr = new SyncHdr(verDTD, verProto, sessID, messageID, 
+                                   tar, sou, NULL, false, cred, meta); //respUri e Meta are null
+
+    deleteVerDTD(&verDTD);
+    deleteVerProto(&verProto);
+    deleteSessionID(&sessID);
+    deleteSource(&sou);
+    deleteTarget(&tar);    
+    safeDel(&messageID);    
+
+    return syncHdr;    
+}
+
+SyncML* SyncMLBuilder::prepareInitObject(Cred* cred, ArrayList* alerts, ArrayList* commands) {
+
+    SyncHdr* syncHdr     = prepareSyncHdr(cred);
+    SyncML*  syncml      = NULL;               
+    ArrayList* list      = new ArrayList();
+    SyncBody* syncBody   = NULL;
+
+    if (!commands->isEmpty()) {
+        list = commands->clone();
+    }    
+    if (alerts && alerts->size() > 0) {
+        for (int k = 0; k < alerts->size(); k++)
+            list->add(*(Alert*)alerts->get(k));        
+    }
+        
+    
+    syncBody   = new SyncBody(list, TRUE);
+    deleteArrayList(&list);
+    syncml       = new SyncML(syncHdr, syncBody);
+
+    deleteSyncHdr(&syncHdr);
+    deleteSyncBody(&syncBody);   
+    
+    return syncml;
+}
+
+BCHAR* SyncMLBuilder::prepareMsg(SyncML* syncml) {        
+    StringBuffer *s = Formatter::getSyncML(syncml);
+    BCHAR* str = stringdup(s->c_str());
+    delete s;
+    return str;
+}
+
+
+SyncML* SyncMLBuilder::prepareSyncML(ArrayList* commands, BOOL final) {    
+    
+    SyncHdr* syncHdr = prepareSyncHdr(NULL);       
+    SyncBody* syncBody   = new SyncBody(commands, final);       
+    SyncML* syncml = new SyncML(syncHdr, syncBody);
+    deleteSyncHdr(&syncHdr);    
+    deleteSyncBody(&syncBody);
+
+    return syncml;
+}
+
+ComplexData* SyncMLBuilder::getComplexData(SyncItem* syncItem) {
+    
+        BCHAR* t   = NULL;
+        TransformationInfo info;
+        ComplexData* data = NULL;
+
+        info.size = syncItem->getDataSize();
+        info.password = encPassword;
+        if (encoding == DESB64) {
+            char* tt = new char[info.size + 1];
+            memset(tt, 0, info.size + 1);            
+            memcpy(tt, syncItem->getData(), syncItem->getDataSize());                        
+            t = encodeDESB64(tt, info);
+            delete [] tt;
+        } else if (encoding == B64) {
+            char* tt = new char[info.size + 1];
+            memset(tt, 0, info.size + 1);            
+            memcpy(tt, syncItem->getData(), syncItem->getDataSize());            
+            t = encodeB64(tt, info);
+            delete [] tt;
+        } else {
+            t = new BCHAR[info.size + 1];
+            memset(t, 0, info.size + 1);            
+            memcpy(t, syncItem->getData(), syncItem->getDataSize());
+        }
+                           
+        data = new ComplexData(t);
+        
+        if (t)
+            {delete [] t; t = NULL; }
+        
+        return data;
+}
+
+
+ArrayList* SyncMLBuilder::prepareItem(SyncItem* syncItem, const BCHAR* type, BCHAR* COMMAND) {
+    ArrayList* list = new ArrayList();            
+    
+    Source* sou = new Source(_wcc(syncItem->getKey()));
+    ComplexData* data = NULL;
+    Meta m;
+    if (bstrcmp(DELETE_COMMAND_NAME, COMMAND) != 0) {       
+        if (encoding == DESB64) {
+            m.setFormat(T("des;b64"));         
+        } else if (encoding == B64) {
+            m.setFormat(T("b64"));            
+        } 
+        data = getComplexData(syncItem);
+
+    }
+    
+    BCHAR *tparent = toMultibyte(syncItem->getTargetParent());
+    BCHAR *sparent = toMultibyte(syncItem->getSourceParent());
+
+    Item* item = new Item(NULL, sou, tparent, sparent, &m, data, FALSE);
+    list->add(*item);
+
+    delete [] tparent;
+    delete [] sparent;
+
+    deleteSource(&sou);
+    deleteComplexData(&data);
+    deleteItem(&item);
+
+    return list;   
+}
+
+/*
+* Prepare an empty modification command without any commands. They will be added with the insertItem method
+*/
+ModificationCommand* SyncMLBuilder::prepareModificationCommand(BCHAR* COMMAND, SyncItem* syncItem, const BCHAR* defaultType) {        
+    
+    if (syncItem == NULL) {
+         return NULL;
+    }
+    ++cmdID;
+    CmdID* commandID     = new CmdID(itow(cmdID));
+
+    // The item should determine its type itself.
+    // Only fallback to the default type configured for its
+    // source if (broken?) SyncSources do not set a in their
+    // items.
+    const BCHAR *type = syncItem->getDataType();
+    if (!type || !type[0]) {
+        type = defaultType;
+    }
+
+    ModificationCommand* ret = NULL;
+    MetInf* metInf       = new MetInf(NULL, (BCHAR*)type, NULL, NULL, 
+                                      NULL, NULL, NULL, NULL, NULL, NULL, NULL); 
+    Meta* meta           = new Meta();
+    meta->setMetInf(metInf);
+    
+    ArrayList* list = new ArrayList();
+    if (syncItem) {
+        ArrayList* tmpList = prepareItem(syncItem, type, COMMAND);
+        list->add(tmpList);
+        deleteArrayList(&tmpList);
+    }
+    if (bstrcmp(ADD_COMMAND_NAME, COMMAND) == 0)
+        ret = new Add(commandID, FALSE, NULL, meta, list);
+    else if (bstrcmp(REPLACE_COMMAND_NAME, COMMAND) == 0){
+        ret = new Replace(commandID, FALSE, NULL, meta, list);
+    } else if (bstrcmp(DELETE_COMMAND_NAME, COMMAND) == 0) {
+        ret = new Delete(commandID, FALSE, FALSE, FALSE, NULL, meta, list);
+    }
+    
+    deleteMetInf(&metInf);
+    deleteCmdID(&commandID);
+    deleteArrayList(&list);
+    deleteMeta(&meta);
+
+    return ret;
+}
+
+/*
+* Add another item into the 
+*/
+void SyncMLBuilder::addItem(ModificationCommand* modificationCommand, BCHAR* COMMAND, SyncItem* syncItem, const BCHAR* defaultType) {        
+    
+    if (syncItem == NULL || modificationCommand == NULL) {
+         return;
+    }       
+    
+    // The item should determine its type itself.
+    // Only fallback to the default type configured for its
+    // source if (broken?) SyncSources do not set a in their
+    // items.
+    const BCHAR *type = syncItem->getDataType();
+    if (!type || !type[0]) {
+        type = defaultType;
+    }
+
+    ArrayList* list = modificationCommand->getItems();
+    ArrayList* tmpList = prepareItem(syncItem, type, COMMAND);
+    list->add(tmpList);
+    deleteArrayList(&tmpList);
+}
+
+Sync* SyncMLBuilder::prepareSyncCommand(SyncSource& source) {            
+
+    ++cmdID;
+
+    CmdID* commandID     = new CmdID(itow(cmdID));
+    Target* tar          = new Target(_wcc(source.getRemoteURI()));
+    Source* sou          = new Source(_wcc(source.getName())); 
+    ArrayList* list      = new ArrayList();  
+    Sync* sync           = NULL;
+         
+    sync = new Sync(commandID, FALSE, NULL, tar, sou, NULL, 0,  list);
+
+    deleteCmdID(&commandID);
+    deleteTarget(&tar);
+    deleteSource(&sou);
+    deleteArrayList(&list);
+
+    return sync;  
+    
+}
+
+
+Map* SyncMLBuilder::prepareMapCommand(SyncSource& s) {
+    /*
+    CmdID* cmdID,
+    Target* target,
+    Source* source,
+    Cred* cred,
+    Meta* meta,
+    ArrayList* mapItems);
+    */
+    ++cmdID;
+    CmdID* commandID     = new CmdID(itow(cmdID));    
+    Target* tar          = new Target(_wcc(s.getRemoteURI()));
+    Source* sou          = new Source(_wcc(s.getName()));
+    ArrayList* mapItems  = new ArrayList();
+    Map* map = new Map(commandID, tar, sou, NULL, NULL, mapItems);
+
+    deleteCmdID(&commandID);
+    deleteTarget(&tar);
+    deleteSource(&sou);
+    deleteArrayList(&mapItems);
+
+    return map;
+
+}
+
+MapItem* SyncMLBuilder::prepareMapItem(SyncMap* syncMap) {
+      
+    Target* tar          = new Target(syncMap->getGUID());
+    Source* sou          = new Source(syncMap->getLUID());    
+    MapItem* m = new MapItem(tar, sou);
+    deleteTarget(&tar);
+    deleteSource(&sou);
+    
+    return m;
+}
+
+void SyncMLBuilder::addMapItem(Map* map, MapItem* mapItem){
+    if (mapItem == NULL || map == NULL)
+        return;
+    ArrayList* list = map->getMapItems();
+    list->add(*mapItem);
+
+}
+
+void SyncMLBuilder::resetMessageID() {
+    msgID = 0;
+}
+
+void SyncMLBuilder::setEncPassword(const BCHAR* pwd) {
+    if (encPassword) {
+        safeDelete(&encPassword);
+    }
+
+    if (pwd) {
+        encPassword = stringdup(pwd);
+    }
+}
+
+BCHAR* SyncMLBuilder::encodeDESB64(char* data, TransformationInfo& info) {
+    char*    des = NULL;
+    char*    b64 = NULL;
+    BCHAR* ret = NULL;
+
+    DataTransformer* dtdes = DataTransformerFactory::getEncoder(T("des"));
+    DataTransformer* dtb64 = DataTransformerFactory::getEncoder(T("b64"));
+
+    if ((dtdes == NULL) || (dtb64 == NULL)) {
+        goto exit;
+    }
+
+    des = dtdes->transform(data, info);
+
+    if (lastErrorCode != ERR_NONE) {
+        goto exit;
+    }
+
+    b64 = dtb64->transform(des, info);
+
+    if (lastErrorCode != ERR_NONE) {
+        goto exit;
+    }
+
+    //
+    // We now translate it into a wchar zero-terminated string 
+    //
+    ret = utf82wc(b64, NULL, 0);
+
+    ++info.size;
+    // info.size = (bstrlen(ret)+1)*sizeof(BCHAR);
+
+
+exit:
+
+    if (des) {
+        delete [] des; des = NULL;
+    }
+
+    if (b64) {
+        delete [] b64; b64 = NULL;
+    }
+
+    if (dtdes) {
+        delete dtdes;
+    }
+
+    if (dtb64) {
+        delete dtb64;
+    }
+
+    return ret;
+}
+
+BCHAR* SyncMLBuilder::encodeB64(char* data, TransformationInfo& info) {
+    char*    b64 = NULL;
+    BCHAR* ret = NULL;
+    DataTransformer* dtb64 = DataTransformerFactory::getEncoder(T("b64"));
+
+    if (dtb64 == NULL) {
+        goto exit;
+    }
+
+    b64 = dtb64->transform((char*)data, info);
+
+    //
+    // We now translate it into a wchar zero-terminated string 
+    //
+    ret = utf82wc(b64);
+
+    ++info.size;
+    // info.size = (bstrlen(ret)+1)*sizeof(BCHAR);
+
+exit:
+
+    if (b64) {
+        delete [] b64; b64 = NULL;
+    }
+
+    if (dtb64) {
+        delete dtb64;
+    }
+
+    return ret;
+}
+
+/*
+ComplexData* SyncMLBuilder::getComplexData(SyncItem* syncItem) {
+    
+        BCHAR* t   = NULL;
+        char*    tmp = NULL;
+        TransformationInfo info;
+        ComplexData* data = NULL;
+
+        info.size = syncItem->getDataSize() / sizeof(BCHAR);
+        info.password = encPassword;
+        if (encoding == DESB64) {
+            BCHAR* tt = new BCHAR[info.size + 1];
+            wmemset(tt, 0, info.size + 1);            
+            memcpy(tt, syncItem->getData(), syncItem->getDataSize());            
+            tmp = wc2utf8(tt);            
+            t = encodeDESB64(tmp, info);
+            delete [] tt;
+        } else if (encoding == B64) {
+            BCHAR* tt = new BCHAR[info.size + 1];
+            wmemset(tt, 0, info.size + 1);            
+            memcpy(tt, syncItem->getData(), syncItem->getDataSize());
+            tmp = wc2utf8(tt);                                          
+            t = encodeB64(tmp, info);
+            delete [] tt;
+        } else {
+            t = new BCHAR[info.size + 1];
+            wmemset(t, 0, info.size + 1);            
+            memcpy(t, syncItem->getData(), syncItem->getDataSize());
+        }
+                           
+        data = new ComplexData(t);
+        
+        if (t) {delete [] t; t = NULL; }
+        if (tmp) {delete [] tmp; tmp = NULL; }
+
+        return data;
+
+}
+*/
--- native/src/c++/common/spds/SyncItem.cpp~item-type
+++ native/src/c++/common/spds/SyncItem.cpp
@@ -1,261 +1,261 @@
-/*
- * Copyright (C) 2003-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-
-#include <string.h>
-#include <stdlib.h>
-
-#include "base/util/utils.h"
-#include "spds/SyncItem.h"
-
-/*
- * Default constructor
- */
-SyncItem::SyncItem() {
-    initialize();
-}
-
-
-/*
- * Constructs a new SyncItem identified by the given key. The key must
- * not be longer than DIM_KEY (see SPDS Constants).
- *
- * @param key - the key
- */
-SyncItem::SyncItem(const wchar_t* itemKey) {
-    initialize();
-    wcsncpy(key, itemKey, DIM_KEY);
-    key[DIM_KEY-1] = 0;
-}
-
-/**
- * Initializes private members
- */
-void SyncItem::initialize() {
-    wcscpy(type, TEXT(TYPE_UNKNOWN));
-    data = NULL;
-    size = -1;
-    lastModificationTime = -1;
-    key[0] = 0;
-    targetParent = NULL;
-    sourceParent = NULL;
-}
-
-/*
- * Destructor. Free the allocated memory (if any)
- */
-SyncItem::~SyncItem() {
-    if (data) {
-        delete [] data; data = NULL;
-    }
-    if (targetParent) {
-        delete [] targetParent; targetParent = NULL;
-    }
-    if (sourceParent) {
-        delete [] sourceParent; sourceParent = NULL;
-    }
-}
-
-/*
- * Returns the SyncItem's key. If key is NULL, the internal buffer is
- * returned; if key is not NULL, the value is copied in the caller
- * allocated buffer and the given buffer pointer is returned.
- *
- * @param key - buffer where the key will be stored
- */
-wchar_t* SyncItem::getKey() {
-        return key;
-    }
-
-/*
- * Changes the SyncItem key. The key must not be longer than DIM_KEY
- * (see SPDS Constants).
- *
- * @param key - the key
- */
-void SyncItem::setKey(const wchar_t* itemKey) {
-    wcsncpy(key, itemKey, DIM_KEY);
-    key[DIM_KEY-1] = 0;
-}
-
-/*
- * Sets the SyncItem modification timestamp. timestamp is a milliseconds
- * timestamp since a reference time (which is platform specific).
- *
- * @param timestamp - last modification timestamp
- */
- void SyncItem::setModificationTime(long timestamp) {
-     lastModificationTime = timestamp;
- }
-
-/*
- * Returns the SyncItem modeification timestamp. The returned value
- * is a milliseconds timestamp since a reference time (which is
- * platform specific).
- */
-long SyncItem::getModificationTime() {
-    return lastModificationTime;
-}
-
-/*
- * Sets the SyncItem content data. The passed data are copied into an
- * internal buffer so that the caller can release the buffer after
- * calling setData(). The buffer is fred in the destructor.
- * If when calling setData, there was an existing allocated data block,
- * it is reused (shrinked or expanded as necessary).
- */
-void* SyncItem::setData(const void* itemData, long dataSize) {
-    if (data) {
-        delete [] data; data = NULL;
-    }
-
-    if (itemData == NULL) {
-        size = 0;
-        return NULL;
-    }
-
-    data = new char[dataSize + 1];
-    if (data == NULL) {
-        lastErrorCode = ERR_NOT_ENOUGH_MEMORY;
-        bsprintf(lastErrorMsg, ERRMSG_NOT_ENOUGH_MEMORY, dataSize);
-        return NULL;
-    }
-
-    size = dataSize;
-    memcpy(data, itemData, size);
-	data[size] = 0;
-
-    return data;
-}
-
-/*
- * Returns the SyncItem data buffer. It is deleted in the destructor.
- */
-void* SyncItem::getData() {
-    return data;
-}
-
-/*
- * Returns the SyncItem data size.
- */
-long SyncItem::getDataSize() {
-    return size;
-}
-
-/*
- * Sets the SyncItem data size.
- */
-void SyncItem::setDataSize(long s) {
-    size = s;
-}
-
-/*
- * Sets the SyncItem data mime type
- *
- * @param - type the content mimetype
- */
-void SyncItem::setDataType(const wchar_t* mimeType) {
-    wcsncpy(type, mimeType, DIM_MIME_TYPE);
-    type[DIM_MIME_TYPE-1] = 0;
-}
-
-/*
- * Returns the SyncItem data mime type.
- *
- */
-wchar_t* SyncItem::getDataType() {
-    return type;
-}
-
-/*
- * Sets the SyncItem state
- *
- * @param state the new SyncItem state
- */
-void SyncItem::setState(SyncState newState) {
-    state = newState;
-}
-
-/*
- * Gets the SyncItem state
- */
-SyncState SyncItem::getState() {
-    return state;
-}
-
-/**
- * Gets the taregtParent property
- *
- * @return the taregtParent property value
- */
-wchar_t* SyncItem::getTargetParent(wchar_t* parent) {
-    if (parent == NULL) {
-        return targetParent;
-    }
-    return wcscpy(parent, targetParent);
-}
-
-/**
- * Sets the taregtParent property
- *
- * @param parent the taregtParent property
- */
-void SyncItem::setTargetParent(const wchar_t* parent) {
-    if (targetParent) {
-        delete [] targetParent; targetParent = NULL;
-    }
-    targetParent = wstrdup(parent);  
-}
-
-/**
- * Gets the sourceParent property
- *
- * @return the sourceParent property value
- */
-wchar_t* SyncItem::getSourceParent(wchar_t* parent) {
-    if (parent == NULL) {
-        return sourceParent;
-    }
-    return wcscpy(parent, sourceParent);
-}
-
-/**
- * Sets the sourceParent property
- *
- * @param parent the sourceParent property
- */
-void SyncItem::setSourceParent(const wchar_t* parent) {
-    if (sourceParent) {
-        delete [] sourceParent; sourceParent = NULL;
-    }
-    sourceParent = wstrdup(parent);  
-}
-
-ArrayElement* SyncItem::clone() {
-    SyncItem* ret = new SyncItem(key);
-
-    ret->setData(data, size);
-    ret->setDataType(type);
-    ret->setModificationTime(lastModificationTime);
-    ret->setState(state);
-    ret->setSourceParent(sourceParent);
-    ret->setTargetParent(targetParent);
-
-    return ret;
-}
+/*
+ * Copyright (C) 2003-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "base/util/utils.h"
+#include "spds/SyncItem.h"
+
+/*
+ * Default constructor
+ */
+SyncItem::SyncItem() {
+    initialize();
+}
+
+
+/*
+ * Constructs a new SyncItem identified by the given key. The key must
+ * not be longer than DIM_KEY (see SPDS Constants).
+ *
+ * @param key - the key
+ */
+SyncItem::SyncItem(const wchar_t* itemKey) {
+    initialize();
+    wcsncpy(key, itemKey, DIM_KEY);
+    key[DIM_KEY-1] = 0;
+}
+
+/**
+ * Initializes private members
+ */
+void SyncItem::initialize() {
+    type[0] = 0;
+    data = NULL;
+    size = -1;
+    lastModificationTime = -1;
+    key[0] = 0;
+    targetParent = NULL;
+    sourceParent = NULL;
+}
+
+/*
+ * Destructor. Free the allocated memory (if any)
+ */
+SyncItem::~SyncItem() {
+    if (data) {
+        delete [] data; data = NULL;
+    }
+    if (targetParent) {
+        delete [] targetParent; targetParent = NULL;
+    }
+    if (sourceParent) {
+        delete [] sourceParent; sourceParent = NULL;
+    }
+}
+
+/*
+ * Returns the SyncItem's key. If key is NULL, the internal buffer is
+ * returned; if key is not NULL, the value is copied in the caller
+ * allocated buffer and the given buffer pointer is returned.
+ *
+ * @param key - buffer where the key will be stored
+ */
+wchar_t* SyncItem::getKey() {
+        return key;
+    }
+
+/*
+ * Changes the SyncItem key. The key must not be longer than DIM_KEY
+ * (see SPDS Constants).
+ *
+ * @param key - the key
+ */
+void SyncItem::setKey(const wchar_t* itemKey) {
+    wcsncpy(key, itemKey, DIM_KEY);
+    key[DIM_KEY-1] = 0;
+}
+
+/*
+ * Sets the SyncItem modification timestamp. timestamp is a milliseconds
+ * timestamp since a reference time (which is platform specific).
+ *
+ * @param timestamp - last modification timestamp
+ */
+ void SyncItem::setModificationTime(long timestamp) {
+     lastModificationTime = timestamp;
+ }
+
+/*
+ * Returns the SyncItem modeification timestamp. The returned value
+ * is a milliseconds timestamp since a reference time (which is
+ * platform specific).
+ */
+long SyncItem::getModificationTime() {
+    return lastModificationTime;
+}
+
+/*
+ * Sets the SyncItem content data. The passed data are copied into an
+ * internal buffer so that the caller can release the buffer after
+ * calling setData(). The buffer is fred in the destructor.
+ * If when calling setData, there was an existing allocated data block,
+ * it is reused (shrinked or expanded as necessary).
+ */
+void* SyncItem::setData(const void* itemData, long dataSize) {
+    if (data) {
+        delete [] data; data = NULL;
+    }
+
+    if (itemData == NULL) {
+        size = 0;
+        return NULL;
+    }
+
+    data = new char[dataSize + 1];
+    if (data == NULL) {
+        lastErrorCode = ERR_NOT_ENOUGH_MEMORY;
+        bsprintf(lastErrorMsg, ERRMSG_NOT_ENOUGH_MEMORY, dataSize);
+        return NULL;
+    }
+
+    size = dataSize;
+    memcpy(data, itemData, size);
+	data[size] = 0;
+
+    return data;
+}
+
+/*
+ * Returns the SyncItem data buffer. It is deleted in the destructor.
+ */
+void* SyncItem::getData() {
+    return data;
+}
+
+/*
+ * Returns the SyncItem data size.
+ */
+long SyncItem::getDataSize() {
+    return size;
+}
+
+/*
+ * Sets the SyncItem data size.
+ */
+void SyncItem::setDataSize(long s) {
+    size = s;
+}
+
+/*
+ * Sets the SyncItem data mime type
+ *
+ * @param - type the content mimetype
+ */
+void SyncItem::setDataType(const wchar_t* mimeType) {
+    wcsncpy(type, mimeType, DIM_MIME_TYPE);
+    type[DIM_MIME_TYPE-1] = 0;
+}
+
+/*
+ * Returns the SyncItem data mime type.
+ *
+ */
+wchar_t* SyncItem::getDataType() {
+    return type;
+}
+
+/*
+ * Sets the SyncItem state
+ *
+ * @param state the new SyncItem state
+ */
+void SyncItem::setState(SyncState newState) {
+    state = newState;
+}
+
+/*
+ * Gets the SyncItem state
+ */
+SyncState SyncItem::getState() {
+    return state;
+}
+
+/**
+ * Gets the taregtParent property
+ *
+ * @return the taregtParent property value
+ */
+wchar_t* SyncItem::getTargetParent(wchar_t* parent) {
+    if (parent == NULL) {
+        return targetParent;
+    }
+    return wcscpy(parent, targetParent);
+}
+
+/**
+ * Sets the taregtParent property
+ *
+ * @param parent the taregtParent property
+ */
+void SyncItem::setTargetParent(const wchar_t* parent) {
+    if (targetParent) {
+        delete [] targetParent; targetParent = NULL;
+    }
+    targetParent = wstrdup(parent);  
+}
+
+/**
+ * Gets the sourceParent property
+ *
+ * @return the sourceParent property value
+ */
+wchar_t* SyncItem::getSourceParent(wchar_t* parent) {
+    if (parent == NULL) {
+        return sourceParent;
+    }
+    return wcscpy(parent, sourceParent);
+}
+
+/**
+ * Sets the sourceParent property
+ *
+ * @param parent the sourceParent property
+ */
+void SyncItem::setSourceParent(const wchar_t* parent) {
+    if (sourceParent) {
+        delete [] sourceParent; sourceParent = NULL;
+    }
+    sourceParent = wstrdup(parent);  
+}
+
+ArrayElement* SyncItem::clone() {
+    SyncItem* ret = new SyncItem(key);
+
+    ret->setData(data, size);
+    ret->setDataType(type);
+    ret->setModificationTime(lastModificationTime);
+    ret->setState(state);
+    ret->setSourceParent(sourceParent);
+    ret->setTargetParent(targetParent);
+
+    return ret;
+}
--- native/src/include/common/spds/constants.h~item-type
+++ native/src/include/common/spds/constants.h
@@ -1,156 +1,154 @@
-/*
- * Copyright (C) 2003-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-
-#ifndef INCL_SPDS_CONSTANTS
-#define INCL_SPDS_CONSTANTS
-
-#include "base/fscapi.h"
-
-#define DIM_SOURCE_NAME      128
-#define DIM_SOURCE_URI        64
-#define DIM_KEY              256
-#define DIM_MIME_TYPE         64
-#define DIM_USERNAME         100
-#define DIM_PASSWORD         100
-#define DIM_DEVICE_ID         50
-#define DIM_SERVERNAME       100
-#define DIM_SYNC_MODES_LIST   64
-#define DIM_SYNC_MODE         16
-#define DIM_ANCHOR            32
-
-#define ERR_REPRESENTATION  700
-
-#define TYPE_UNKNOWN "unknown"
-
-typedef enum SyncMode{
-        SYNC_NONE                          = 000,
-        SYNC_TWO_WAY                       = 200,
-        SYNC_SLOW                          = 201,
-        SYNC_ONE_WAY_FROM_CLIENT           = 202,
-        SYNC_REFRESH_FROM_CLIENT           = 203,
-        SYNC_ONE_WAY_FROM_SERVER           = 204,
-        SYNC_REFRESH_FROM_SERVER           = 205,
-        SYNC_TWO_WAY_BY_SERVER             = 206,
-        SYNC_ONE_WAY_FROM_CLIENT_BY_SERVER = 207,
-        SYNC_REFRESH_FROM_CLIENT_BY_SERVER = 208,
-        SYNC_ONE_WAY_FROM_SERVER_BY_SERVER = 209,
-        SYNC_REFRESG_FROM_SERVER_BY_SERVER = 210,
-        //---Funambol extension-----------------
-        SYNC_ADDR_CHANGE_NOTIFICATION      = 745
-} SyncMode;
-
-#define CONTEXT_SPDS_SYNCML  "/spds/syncml"
-#define CONTEXT_SPDS_SOURCES "/spds/sources"
-
-//-------------------------------------------------------
-// Status codes
-
-#define IN_PROGRESS                                   101
-#define OK                                            200
-#define ITEM_ADDED                                    201
-#define ACCEPTED_FOR_PROCESSING                       202
-#define NONAUTHORITATIVE_RESPONSE                     203
-#define NO_CONTENT                                    204
-#define RESET_CONTENT                                 205
-#define PARTIAL_CONTENT                               206
-#define CONFLICT_RESOLVED_WITH_MERGE                  207
-#define CONFLICT_RESOLVED_WITH_CLIENT_COMMAND_WINNING 208
-#define CONFLICT_RESOLVED_WITH_DUPLICATE              209
-#define DELETE_WITHOUT_ARCHIVE                        210
-#define ITEM_NOT_DELETED                              211
-#define AUTHENTICATION_ACCEPTED                       212
-#define CHUNKED_ITEM_ACCEPTED                         213
-#define OPERATION_CANCELLED_OK                        214
-#define NOT_EXECUTED                                  215
-#define ATOMIC_ROLLBACK_OK                            216
-#define MULTIPLE_CHOICES                              300
-#define MOVED_PERMANENTLY                             301
-#define FOUND                                         302
-#define SEE_ANOTHER_URI                               303
-#define NOT_MODIFIED                                  304
-#define USE_PROXY                                     305
-#define BAD_REQUEST                                   400
-#define INVALID_CREDENTIALS                           401
-#define PAYMENT_REQUIRED                              402
-#define FORBIDDEN                                     403
-#define NOT_FOUND                                     404
-#define COMMAND_NOT_ALLOWED                           405
-#define OPTIONAL_FEATURE_NOT_SUPPORTED                406
-#define MISSING_CREDENTIALS                           407
-#define REQUEST_TIMEOUT                               408
-#define UPDATE_CONFLICT                               409
-#define GONE                                          410
-#define SIZE_REQUIRED                                 411
-#define INCOMPLETE_COMMAND                            412
-#define REQUESTED_ENTITY_TOO_LARGE                    413
-#define URI_TOO_LONG                                  414
-#define UNSUPPORTED_MEDIA_TYPE                        415
-#define REQUESTED_SIZE_TOO_BIG                        416
-#define RETRY_LATER                                   417
-#define ALREADY_EXISTS                                418
-#define CONFLICT_RESOLVED_WITH_SERVER_DATA            419
-#define DEVICE_FULL                                   420
-#define UNKNOWN_SEARCH_GRAMMAR                        421
-#define BAD_CGI_SCRIPT                                422
-#define SOFT_DELETE_CONFLICT                          423
-#define OBJECT_SIZE_MISMATCH                          424
-#define PERMISSION_DENIED                             425
-#define COMMAND_FAILED                                500
-#define COMMAND_NOT_IMPLEMENTED                       501
-#define BAD_GATEWAY                                   502
-#define SERVICE_UNAVAILABLE                           503
-#define GATEWAY_TIMEOUT                               504
-#define VERSION_NOT_SUPPORTED                         505
-#define PROCESSING_ERROR                              506
-#define ATOMIC_FAILED                                 507
-#define REFRESH_REQUIRED                              508
-#define RECIPIENT_EXCEPTION_RESERVED1                 509
-#define DATASTORE_FAILURE                             510
-#define SERVER_FAILURE                                511
-#define SYNCHRONIZATION_FAILED                        512
-#define PROTOCOL_VERSION_NOT_SUPPORTED                513
-#define OPERATION_CANCELLED                           514
-#define ATOMIC_ROLLBACK_FAILED                        516
-#define ATOMIC_RESPONSE_TOO_LARGE_TO_FIT              517
-
-// ------------------------------------------------------
-
-//-------------------------------------------------------
-// Commands
-
-#define COMMAND_ADD     T("Add")
-#define COMMAND_DELETE  T("Delete")
-#define COMMAND_GET     T("Get")
-#define COMMAND_PUT     T("Put")
-#define COMMAND_REPLACE T("Replace")
-#define COMMAND_RESULTS T("Results")
-#define COMMAND_STATUS  T("Status")
-#define COMMAND_SYNC    T("Sync")
-
-//-------------------------------------------------------
-
-#ifndef NULL
-    #define NULL 0x00
-#endif
-
-
-BCHAR* retSyncMode(SyncMode) EXTRA_SECTION_01;
-
-#endif
+/*
+ * Copyright (C) 2003-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+
+#ifndef INCL_SPDS_CONSTANTS
+#define INCL_SPDS_CONSTANTS
+
+#include "base/fscapi.h"
+
+#define DIM_SOURCE_NAME      128
+#define DIM_SOURCE_URI        64
+#define DIM_KEY              256
+#define DIM_MIME_TYPE         64
+#define DIM_USERNAME         100
+#define DIM_PASSWORD         100
+#define DIM_DEVICE_ID         50
+#define DIM_SERVERNAME       100
+#define DIM_SYNC_MODES_LIST   64
+#define DIM_SYNC_MODE         16
+#define DIM_ANCHOR            32
+
+#define ERR_REPRESENTATION  700
+
+typedef enum SyncMode{
+        SYNC_NONE                          = 000,
+        SYNC_TWO_WAY                       = 200,
+        SYNC_SLOW                          = 201,
+        SYNC_ONE_WAY_FROM_CLIENT           = 202,
+        SYNC_REFRESH_FROM_CLIENT           = 203,
+        SYNC_ONE_WAY_FROM_SERVER           = 204,
+        SYNC_REFRESH_FROM_SERVER           = 205,
+        SYNC_TWO_WAY_BY_SERVER             = 206,
+        SYNC_ONE_WAY_FROM_CLIENT_BY_SERVER = 207,
+        SYNC_REFRESH_FROM_CLIENT_BY_SERVER = 208,
+        SYNC_ONE_WAY_FROM_SERVER_BY_SERVER = 209,
+        SYNC_REFRESG_FROM_SERVER_BY_SERVER = 210,
+        //---Funambol extension-----------------
+        SYNC_ADDR_CHANGE_NOTIFICATION      = 745
+} SyncMode;
+
+#define CONTEXT_SPDS_SYNCML  "/spds/syncml"
+#define CONTEXT_SPDS_SOURCES "/spds/sources"
+
+//-------------------------------------------------------
+// Status codes
+
+#define IN_PROGRESS                                   101
+#define OK                                            200
+#define ITEM_ADDED                                    201
+#define ACCEPTED_FOR_PROCESSING                       202
+#define NONAUTHORITATIVE_RESPONSE                     203
+#define NO_CONTENT                                    204
+#define RESET_CONTENT                                 205
+#define PARTIAL_CONTENT                               206
+#define CONFLICT_RESOLVED_WITH_MERGE                  207
+#define CONFLICT_RESOLVED_WITH_CLIENT_COMMAND_WINNING 208
+#define CONFLICT_RESOLVED_WITH_DUPLICATE              209
+#define DELETE_WITHOUT_ARCHIVE                        210
+#define ITEM_NOT_DELETED                              211
+#define AUTHENTICATION_ACCEPTED                       212
+#define CHUNKED_ITEM_ACCEPTED                         213
+#define OPERATION_CANCELLED_OK                        214
+#define NOT_EXECUTED                                  215
+#define ATOMIC_ROLLBACK_OK                            216
+#define MULTIPLE_CHOICES                              300
+#define MOVED_PERMANENTLY                             301
+#define FOUND                                         302
+#define SEE_ANOTHER_URI                               303
+#define NOT_MODIFIED                                  304
+#define USE_PROXY                                     305
+#define BAD_REQUEST                                   400
+#define INVALID_CREDENTIALS                           401
+#define PAYMENT_REQUIRED                              402
+#define FORBIDDEN                                     403
+#define NOT_FOUND                                     404
+#define COMMAND_NOT_ALLOWED                           405
+#define OPTIONAL_FEATURE_NOT_SUPPORTED                406
+#define MISSING_CREDENTIALS                           407
+#define REQUEST_TIMEOUT                               408
+#define UPDATE_CONFLICT                               409
+#define GONE                                          410
+#define SIZE_REQUIRED                                 411
+#define INCOMPLETE_COMMAND                            412
+#define REQUESTED_ENTITY_TOO_LARGE                    413
+#define URI_TOO_LONG                                  414
+#define UNSUPPORTED_MEDIA_TYPE                        415
+#define REQUESTED_SIZE_TOO_BIG                        416
+#define RETRY_LATER                                   417
+#define ALREADY_EXISTS                                418
+#define CONFLICT_RESOLVED_WITH_SERVER_DATA            419
+#define DEVICE_FULL                                   420
+#define UNKNOWN_SEARCH_GRAMMAR                        421
+#define BAD_CGI_SCRIPT                                422
+#define SOFT_DELETE_CONFLICT                          423
+#define OBJECT_SIZE_MISMATCH                          424
+#define PERMISSION_DENIED                             425
+#define COMMAND_FAILED                                500
+#define COMMAND_NOT_IMPLEMENTED                       501
+#define BAD_GATEWAY                                   502
+#define SERVICE_UNAVAILABLE                           503
+#define GATEWAY_TIMEOUT                               504
+#define VERSION_NOT_SUPPORTED                         505
+#define PROCESSING_ERROR                              506
+#define ATOMIC_FAILED                                 507
+#define REFRESH_REQUIRED                              508
+#define RECIPIENT_EXCEPTION_RESERVED1                 509
+#define DATASTORE_FAILURE                             510
+#define SERVER_FAILURE                                511
+#define SYNCHRONIZATION_FAILED                        512
+#define PROTOCOL_VERSION_NOT_SUPPORTED                513
+#define OPERATION_CANCELLED                           514
+#define ATOMIC_ROLLBACK_FAILED                        516
+#define ATOMIC_RESPONSE_TOO_LARGE_TO_FIT              517
+
+// ------------------------------------------------------
+
+//-------------------------------------------------------
+// Commands
+
+#define COMMAND_ADD     T("Add")
+#define COMMAND_DELETE  T("Delete")
+#define COMMAND_GET     T("Get")
+#define COMMAND_PUT     T("Put")
+#define COMMAND_REPLACE T("Replace")
+#define COMMAND_RESULTS T("Results")
+#define COMMAND_STATUS  T("Status")
+#define COMMAND_SYNC    T("Sync")
+
+//-------------------------------------------------------
+
+#ifndef NULL
+    #define NULL 0x00
+#endif
+
+
+BCHAR* retSyncMode(SyncMode) EXTRA_SECTION_01;
+
+#endif
