Fixes several problems in combination with Synthesis (and probably
other) servers:
- CDATA in <Data></Data> parts not supported
- escape & and < with CDATA because the Synthesis server only supports that;
  is also cheaper to do at runtime (no replaceAll).
- bugfix: code which replaced &amp; and &lt; was unconditionally applied
  at high levels and broke e.g. <Add><Data><![CDATA[ literal entity &amp; ]]></Data></Add>
  but it was also applied multiple times to the same text and thus might have
  incorrectly replaced &amp;amp; with & although &amp; would have been correct
- <LocName> required for MD5 authentication
- after failed authentication <SourceRef> might be missing in reply,
  ignore it
- moved code into new SyncManager::checkForServerChanges() to deal with
  server <Sync> which might come before the 222 alert and wasn't expected
  there by the client without this patch
- several XML tags must have the xmlns parameter to be accepted as valid XML

#
# Patch managed by http://www.holgerschurig.de/patcher.html
#

--- native/src/c++/common/base/util/XMLProcessor.cpp~synthesis
+++ native/src/c++/common/base/util/XMLProcessor.cpp
@@ -1,790 +1,853 @@
-/*
- * Copyright (C) 2003-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <stdlib.h>
-
-#include "base/util/utils.h"
-#include "base/util/XMLProcessor.h"
-#include "base/util/StringBuffer.h"
-#include "base/Log.h"
-
-//--------------------------------------------------------------- Static functions
-
-static const BCHAR *findElementContent(const BCHAR *xml,
-                          const BCHAR *openTag, const BCHAR *closeTag,
-                          unsigned int* pos     ,
-                          unsigned int* startPos,
-                          unsigned int* endPos  )
-{
-    const BCHAR *p1, *p2, *xmlptr = xml;
-
-    if (pos) {
-        *pos = 0;
-    }
-
-    do {
-        p1 = bstrstr(xmlptr, openTag);
-        p2 = NULL;
-
-        if (!p1) {
-            // Tag not found
-            //LOG.debug("XMLProcessor: tag %s not found", openTag);
-            return 0;
-        }
-        
-        p1 += bstrlen(openTag); // move to end of tag
-
-        // Check the tag type
-        switch( *p1 ){
-            case ' ':   // <tag attr=xxx>
-                // Find the end of the tag (TODO: should check for invalid chars?)
-                for (p1++; *p1 != '>'; p1++) {
-                    if(*p1 == 0 || *p1 == '<'){
-                        LOG.info("XMLProcessor: incomplete tag");
-                        return 0;
-                    }
-                }
-                if(*(p1-1) == '/'){ // <tag attr=xxx />
-                    // Like case '/' below:
-                    p1++;
-                    p2=p1;
-                    closeTag=0;
-                    break;
-                }
-                // The break is not missing!
-                // After the for, we are in the same case of the tag
-                // without attributes
-            case '>':   // <tag>
-                p1++;   // this is the beginning of content
-                if (!p1[0]) {
-                    LOG.info("XMLProcessor: tag at end of file");
-                    return 0;
-                }
-                // Find the closing tag
-                p2 = bstrstr(p1, closeTag);
-                break;
-            case '/':
-                p1++;
-                if(*p1 != '>'){
-                    LOG.info("XMLProcessor: invalid empty tag");
-                    return 0;
-                }
-                p1++;
-                // The tag is already closed, no content: make end = start
-                p2=p1;
-                // Invalidate closeTag
-                closeTag=0;
-                break;
-            case '\n':
-                p1++;
-                p2 = bstrstr(p1, closeTag);
-                break;
-            default:
-                // This is not the searched tag, search again
-                //LOG.debug("XMLProcessor: this is not tag %s", openTag);
-                xmlptr = p1;
-                p1 = 0;
-        }
-    }
-    while (!p1); // If p1 is null and we are here, it means that the 'default'
-                 // case was hit.
-
-    // Closing tag not found
-    if (!p2) {
-        //
-        // This is abc<tag>xyz\0
-        //
-        p1 = NULL;
-        return 0;
-    }
-    
-    // Okay, if we are here, the tag content has been found
-    if (startPos) {
-        *startPos = p1 - xml;
-    }
-    if (endPos) {
-        *endPos = p2 - xml ;
-    }
-    if (pos) {
-        *pos = p2-xml;
-        if (closeTag){
-            *pos += bstrlen(closeTag);
-        }
-    }
-
-    return p1;
-}
-
-const BCHAR* XMLProcessor::getElementContent(const BCHAR* xml,
-                                       const BCHAR* tag,
-                                       unsigned int* pos,
-                                       unsigned int* startPos,
-                                       unsigned int* endPos  )
-{        
-    BCHAR *openTag = 0;
-    BCHAR *closeTag = 0;
-    
-    if (!xml) {
-        return 0;
-    }
-
-    size_t l = bstrlen(tag);
-
-    if(bstrcmp(tag, T("CDATA")) == 0) {
-        openTag = stringdup(T("<![CDATA["));
-        closeTag = stringdup(T("]]>"));
-    }
-    else {
-        openTag = new BCHAR[l+10];
-        closeTag = new BCHAR[l+10];
-        bsprintf(openTag, T("<%s"), tag);
-        bsprintf(closeTag, T("</%s>"), tag);
-    }
-
-    const BCHAR *ret = findElementContent(xml, openTag, closeTag, pos, startPos, endPos);
-
-    if (openTag)
-        delete [] openTag;
-    if (closeTag)
-        delete [] closeTag;
-
-    return ret;
-}
-
-BCHAR* XMLProcessor::getContent(const BCHAR* xml,
-                                unsigned int startPos,
-                                unsigned int endPos  ) {
-
-    BCHAR * ret = NULL;
-
-    if (!xml) {
-        return 0;
-    }
-    if (endPos < startPos) {
-        return 0;
-    }
-    if (bstrlen(xml) < endPos - startPos) {
-        return 0;
-    }
-
-    ret = new BCHAR[endPos - startPos + 1];
-
-    bstrncpy(ret, xml+startPos, endPos - startPos);
-    ret[endPos - startPos] = 0;
-
-    return ret;
-}
-
-BCHAR* XMLProcessor::getElementContent(const BCHAR* xml,
-                                       const BCHAR* tag,
-                                       unsigned int* pos)
-{
-    unsigned int start, end;
-
-    if( getElementContent (xml, tag, pos, &start, &end) ) {
-        return getContent(xml, start, end);
-    }
-    return 0;
-}
-
-/*
-* It returns the number of the tag in the xml string
-*/
-
-int XMLProcessor::countElementTag(BCHAR* xml, BCHAR* tag) {
-
-    unsigned int count = 0, pos = 0, previous = 0;
-    
-    while (getElementContent(&xml[pos], tag , &pos, NULL, NULL) != NULL) {
-        pos += previous;
-        previous = pos;
-        count ++;
-    }
-    return count;
-}
-
-
-/*
-* Returns the next tag found in the xml string. It looks at the < and > tags to retrieve 
-* the name of the token. 
-* If <tag xmlns...> it returns "tag"
-* The "pos" argument will contain the position of the close <tag/>
-* The return value is a new BCHAR* and must be fred by the caller. If no tag is found, NULL is returned
-*/
-BCHAR* XMLProcessor::getNextTag(BCHAR* xml, int* pos) {
-    
-    BCHAR* p1, *p2, *p4, *p3 = NULL, *ret = NULL;
-    p1 = p2 = p4 = xml;
-    int i = 0, k = 0, len = 0;
-    BOOL found = FALSE;
-    len = bstrlen(xml);     
-    
-    for (i = 0; i < len; i++) {
-        if (found) {
-            if (p4[i] != '/' && p4[i] != '!' && p4[i] != '-' ) {
-                break; // the element found is right!
-            } else {
-                found = FALSE;
-            }
-        }
-        if (p4[i] == '<') {            
-            p1 = &p4[i];            
-            found = TRUE;
-        }
-    }
-    
-    if (found) {
-        p2 = p1;           
-        for (k = 0; k < len; k++) {             
-            if (*p1 == 0) {
-                break;
-            }
-            else if (*p1 == ' ') {
-                p3 = p1;
-            }
-            else if (*p1 == '>') { 
-                *pos = p1 -xml + 1;
-                if (p3) {                    
-                    p1 = p3;
-                }
-                ret = new BCHAR[(p1)-(p2)];
-                bstrncpy(ret, p2+1, (p1)-(p2+1));
-                ret[(p1)-(p2+1)] = 0;
-                return ret;
-                break;
-            }            
-            p1 = p1 + 1;
-        }
-    }
-    return ret;
-
-}
-
-
-
-/*
-* count the number of "&" (passed as a string) in the token. 
-*/
-int XMLProcessor::countAnd(BCHAR* token) {
-    return countChar(token, T("&"));
-}
-
-int XMLProcessor::countChar(BCHAR* token, BCHAR* element) {
-
-    BCHAR* p1, *p2;
-    p1 = p2 = token;
-    int i = 0, k = 0, len = 0;
-
-    while (bstrstr(p1, element) != NULL) {
-        len = bstrlen(p2);        
-        for (k = 0; k < len; k++) {             
-            if (*p1 == 0) {
-                break;
-            }
-            else if (*p1 == '&') {                
-                p1 = p1 + 1;
-                i++;
-                break;
-            }            
-            p1 = p1 + 1;
-        }  
-    }
-    return i;
-}
-
-
-/*
-* it's as getElementContent but it doesn't get the content of a tag if the parent match except.
-* The parent can be more than one. They have to be separated by &
-* i.e.  
-*
-* getElementContentExcept(xmlPtr, T("Add"), T("Sync&Atomic"), &post)
-*
-* The function returns "... to keep ... " content only 
-*
-* <SyncBody>
-   <Sync>
-     <Add>... to avoid ...</Add>
-   </Sync>
-   <Add>... to keep ...</Add>
-   <Sync>
-     <Add>... to avoid ...</Add>
-   </Sync>
-    <Atomic>
-     <Add>... to avoid ...</Add>
-   </Atomic>
- </SyncBody>
-*/
-
-BCHAR* XMLProcessor::getElementContentExcept(BCHAR*      xmlPtr    ,
-                                               BCHAR*      tag       ,
-                                               BCHAR*      except    ,
-                                               unsigned int* post) {
-    
-    BCHAR*  ret    = NULL;
-    const BCHAR*  found  = NULL;
-    BCHAR*  xml    = NULL;
-    BCHAR** array = NULL;
-    int*  validElement = NULL;   
-    int count        = 0, countTag = 0;
-    BOOL notValid  = FALSE;
-
-    unsigned int pos      = 0, previous         = 0,
-                 position = 0, previousPosition = 0,
-                 startPos = 0, endPos           = 0;
-    
-    xml = xmlPtr;
-    
-    if (xml == NULL) {
-        return NULL;
-    }     
-    
-    if (except == NULL) {
-        ret = getElementContent(xml, tag, &pos);
-        if (post) {
-            *post = pos;
-        }
-        return ret;
-    }
-    count = countAnd(except);    
-    count++;
-    
-    array = new BCHAR*[count + 1];
-	int l;
-    for (l = 0; l <= count; l++) {
-        array[l] = NULL;
-    }
-    
-    // represent a element found that can be used properly
-    countTag = countElementTag(xml, tag);
-    if (countTag > 0) {
-        validElement = new int[countTag];
-        for (l = 0; l < countTag; l++) {
-            validElement[l] = 1;
-        }
-    }
-
-    BCHAR* internal = stringdup(except);
-    BCHAR* p1, *p2;
-    p1 = p2 = internal;
-    int i = 0, k = 0, len = 0;
-
-    while (bstrstr(p2, T("&")) != NULL) {
-        len = bstrlen(p2);        
-        for (k = 0; k < len; k++) {             
-            if (*p1 == 0) {
-                break;
-            }
-            else if (*p1 == '&') {                
-                *p1 = 0;
-                array[i] = stringdup(p2);
-                p1 = p1 + 1;
-                p2 = p1;
-                i++;
-                break;
-            }            
-            p1 = p1 + 1;
-        }  
-    }
-    
-    if (i == 0 || k < len) {
-        if (array[i]) { delete [] array[i]; array[i] = NULL; }
-        array[i] = stringdup(p2);
-        i++;
-    }
-             
-    for (int s = 0; s < count; s ++) {
-        i = 0;
-
-        do {
-            safeDel(&ret);
-            k = 0;
-
-            pos = 0, previous = 0;
-            while ((ret = getElementContent(&xml[pos], tag, &pos)) != NULL) {    
-            
-                if (validElement && validElement[k] == 1) {
-                    pos += previous;
-                    position = 0; 
-                    previousPosition = 0;
-                    startPos = 0; 
-                    endPos   = 0;
-                    while ((found = getElementContent(&xml[position], array[i], &position, &startPos, &endPos)) != NULL ) {
-        
-                        startPos += previousPosition;
-                        endPos   += previousPosition;
-                        position += previousPosition;
-                        if (startPos < pos && pos < endPos) {
-                            notValid = TRUE;                    
-                            break;
-                        }
-                        previousPosition = position;
-                       
-                    }                    
-
-                    if (notValid) {
-                        notValid = FALSE;     
-                        safeDel(&ret);
-                        validElement[k] = 0;
-                    } else {
-                        if (post) {
-                            *post = pos;
-                        }
-                        break;
-                    }
-                    previous = pos;
-                    k++;
-                } else {
-                    pos += previous;
-                    previous = pos;
-                    k++;
-                    safeDel(&ret); // if (ret) { delete [] ret; ret = NULL; }
-                }
-            }
-            i++;
-
-        } while(array[i] != NULL);
-
-        if (count > 1) {
-            BCHAR* tmp = stringdup(array[0]);
-    
-            for (int m = 0; m < count - 1; m++) {
-                if (array[m]) { delete [] array[m]; array[m] = NULL; }
-                //safeDel(&array[m]);  
-                array[m] = stringdup(array[m+1]);
-            }
-            //safeDel(&array[count-1]);
-            if (array[count-1]) { delete [] array[count-1]; array[count-1] = NULL; }
-            array[count-1] = stringdup(tmp);
-            safeDel(&tmp); 
-        }
-    }       
-    
-    if (notValid) {
-        if (ret) {
-            safeDel(&ret);
-        }
-        if (post) {
-            *post = 0;
-        }
-    } else {
-        ;
-    }
-    
-    safeDel(&internal);
-    if (validElement) {
-        delete [] validElement; validElement = NULL;
-    }
-    
-    for (l = 0; l <= count; l++) {
-        if (array[l]) { delete [] array[l]; array[l] = NULL; }
-    }
-    delete [] array; array = NULL;
-    //safeDelete(array);   
-
-    return ret;
-}
-
-/*
-* It returns getElementContent value but it depends on the level that is specified.
-* It return only ... to keep ... independently on the tag in which it is contained if lev is zero.
-* 
-*   <Sync>
-*     <Add>... to avoid ...</Add>
-*   </Sync>
-*   <Add>... to keep ...</Add>
-*   <Sync>
-*     <Add>... to avoid ...</Add>
-*   </Sync>
-*    <Atomic>
-*     <Add>... to avoid ...</Add>
-*   </Atomic>
-*
-* The parameters are:
-* xml: the xml to analize
-* tag: the name of the tag to use
-* lev: the inner level in which discover the tag
-* startLevel: the starting level from which start the search
-* pos: the position index search end
-*
-* The follow piece of code explain how get the value tag "... to keep ..." that is in the root (0) level.
-* Note the startLevel declaration and initialization to -1 value
-*
-*
-*    BCHAR* p = NULL;
-*    unsigned int pos = 0, previous = 0;
-*    int startLevel = -1;
-*    while ((p = XMLProcessor::getElementContentLevel(&xml[pos], T("Add"), 0, &startLevel, &pos)) != NULL) {        
-*        pos += previous;
-*        previous = pos;                
-*    }
-*
-*/
-
-BCHAR* XMLProcessor::getElementContentLevel(BCHAR*      xml   ,
-                                              BCHAR*      tag   ,                                              
-                                              unsigned int* pos, 
-                                              int           lev ,   
-                                              int*          startLevel)  {
-    
-    BCHAR* p1       = NULL;
-    BCHAR* p2       = NULL;
-    BCHAR* ret      = NULL;
-    BOOL openBracket  = FALSE;  // <
-    BOOL closeBracket = FALSE;  // >
-    BOOL aloneBracket = FALSE;  // </
-    BOOL preCloseBracket = FALSE;  //<.../
-    BOOL openTag      = FALSE;
-    BOOL closeTag     = FALSE;
-
-    BCHAR tagNameFound[40];
-    
-    int level               = -1;
-    unsigned int xmlLength  = (unsigned int)-1;
-    unsigned int l          = (unsigned int)-1;
-    unsigned int previousIndex = (unsigned int)-1;
-    unsigned int i          =  0;    
-    
-    if (xml == NULL) {
-        goto finally;
-    }
-    
-    if (lev < 0) {
-        return getElementContent(xml, tag, pos);
-    }        
-   
-    xmlLength = bstrlen(xml);
-    l = bstrlen(tag);
-
-    if (pos != NULL) {
-        *pos = 0;
-    }
-    if (startLevel != NULL) {
-       level = *startLevel;
-    }
-
-    p1 = p2 = xml;
-    
-    for (i = 0; i < xmlLength; i ++) {
-        
-        if (p1[i] == '<') {
-            openBracket = TRUE;
-            previousIndex = i;
-            p2 = &p1[i];
-
-        } else if (p1[i] == '/') {
-            if (previousIndex == (i - 1)) {
-                // <.../>                
-                preCloseBracket = TRUE;
-            } else {
-                // TBD  </...>
-            }
-
-        } else if (p1[i] == '>') {  
-            
-            if (openBracket == FALSE) {
-                closeBracket = FALSE;
-                preCloseBracket = FALSE;
-            } else {
-                if (preCloseBracket) {
-                    closeTag = TRUE;
-                }
-                else { 
-                    openTag = TRUE;                    
-                }
-                closeBracket = TRUE;
-                
-                if (closeTag) {
-                    level--;
-                    openBracket  = FALSE;
-                    closeBracket = FALSE;
-                    preCloseBracket = FALSE;
-                    openTag      = FALSE;
-                    closeTag     = FALSE;
-
-                } else if (openTag) {
-                    level++;
-                } else {
-                    openBracket  = FALSE;
-                    closeBracket = FALSE;
-                    preCloseBracket = FALSE;
-                    openTag      = FALSE;
-                    closeTag     = FALSE;
-
-                }                
-            }
-        }         
-          if (openTag && openBracket && closeBracket) {
-            int n = (&p1[i] - p2 - 1);
-            bstrncpy(tagNameFound, p2 + 1, n);         
-            tagNameFound[n] = 0;
-            if (bstrcmp(tagNameFound, tag) == 0 && (level == lev)) {
-                unsigned int internalPos;
-                ret = getElementContent(p2, tag, &internalPos);
-                if (pos) {
-                    *pos = p2 - xml + internalPos;                    
-                }
-                if (startLevel) {
-                    *startLevel = level - 1;
-                }
-                break;
-            }
-            openBracket  = FALSE;
-            closeBracket = FALSE;           
-        }
-    }
-
-finally:
-    openBracket  = FALSE;
-    closeBracket = FALSE;
-    preCloseBracket = FALSE;
-    openTag      = FALSE;
-    closeTag     = FALSE;
-    return ret;
-
-}
-
-/**
- * Get the attribute list of the forst element 'tag', returning a pointer 
- * to the beginning of the string in the original buffer 'xml', and the 
- * starting and ending position of the substring.
- *
- * @param xml - the XML document to process.
- * @param tag - the tag name to find
- * @param startPos - return value - the start pos of the attribute list
- * @param endPos - return value - the end position of the attribute list
- */
-const BCHAR* XMLProcessor::getElementAttributes(const BCHAR* xml,
-                                          const BCHAR* tag,
-                                          unsigned int* startPos,
-                                          unsigned int* endPos, 
-                                          bool escaped) {
-        
-    const BCHAR* p1 = NULL;
-    const BCHAR* p2 = NULL;
-    BOOL charFound  = FALSE;
-    unsigned int l = bstrlen(tag);
-
-    // example ot tag with attribute list
-    // <body enc="base64">
-    BCHAR *openTag = 0; //<tag
-    
-    if (!xml) {
-        goto finally;
-    }
-
-    if(bstrcmp(tag, T("CDATA")) == 0) {
-        goto finally;
-    }
-    else {
-        openTag = new BCHAR[l+10];
-        if (escaped){
-            bsprintf(openTag, T("&lt;%s "), tag);
-        }
-        else{
-            bsprintf(openTag, T("<%s "), tag);
-        }
-    }
-
-    p1 = bstrstr(xml, openTag);
-
-    if (!p1) {
-        LOG.info("XMLProcessor: tag %s not found", tag);
-        goto finally;
-    }
-    // move to the beginning of the attribute list
-    p1 += bstrlen(openTag);
-
-    // find the end of the tag
-    for (p2 = p1; *p2 != '>'; p2++) {
-        if(*p2 == 0 || *p2 == '<'){
-            LOG.info("XMLProcessor: incomplete tag");
-            goto finally;
-        }
-    }
-    // set the return parameters
-    if (startPos != NULL) {
-        *startPos = p1 - xml;
-    }
-    if (endPos != NULL) {
-        *endPos = p2 - xml ;
-    }
-
-    finally:
-
-    if (openTag)
-        delete [] openTag;
-
-    return p1;
-
-}
-
-
-StringBuffer XMLProcessor::makeElement(const BCHAR* tag, const BCHAR* val, const BCHAR* attr)
-{
-    StringBuffer s;
-        
-    if (!val)
-        return s;
-    if (!val[0])
-        return s;
-    
-    size_t len = bstrlen(tag);
-    BCHAR* t1 = new BCHAR[len + 4]; // <  >  0, whitout closing >
-    BCHAR* t2 = new BCHAR[len + 6]; // </ > \n 0
-
-    sprintf(t1, T("<%s"), tag);    
-    sprintf(t2, T("</%s>\n"), tag);
-
-    s = t1; 
-    if (attr != NULL)
-    {
-        s += " ";
-        s += attr;        
-    }
-    s += ">";
-    s += val; s += t2;
-
-    delete [] t1;
-    delete [] t2;
-    
-    return s;    
-}
-
-
-StringBuffer XMLProcessor::makeElement(const BCHAR* tag, 
-                                    const BCHAR* val,
-                                    ArrayList attrList) {
-
-    StringBuffer s;
-    
-    for (int i = 0; i < attrList.size(); i++)
-    {
-        KeyValuePair* item = (KeyValuePair*)attrList[i];
-        if (i > 0)
-            s += " ";
-        s += item->getKey(); 
-        s += "=\"";
-        s += item->getValue(); 
-        s += "\"";
-    }    
-    s = makeElement(tag, val, s.c_str());
-
-    return s;
-}
+/*
+ * Copyright (C) 2003-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#include <stdlib.h>
+
+#include "base/util/utils.h"
+#include "base/util/XMLProcessor.h"
+#include "base/util/StringBuffer.h"
+#include "base/Log.h"
+
+//--------------------------------------------------------------- Static functions
+
+static const BCHAR *findElementContent(const BCHAR *xml,
+                          const BCHAR *openTag, const BCHAR *closeTag,
+                          unsigned int* pos     ,
+                          unsigned int* startPos,
+                          unsigned int* endPos  )
+{
+    const BCHAR *p1, *p2, *xmlptr = xml;
+
+    if (pos) {
+        *pos = 0;
+    }
+
+    do {
+        p1 = bstrstr(xmlptr, openTag);
+        p2 = NULL;
+
+        if (!p1) {
+            // Tag not found
+            //LOG.debug("XMLProcessor: tag %s not found", openTag);
+            return 0;
+        }
+        
+        p1 += bstrlen(openTag); // move to end of tag
+
+        // Check the tag type
+        switch( *p1 ){
+            case ' ':   // <tag attr=xxx>
+                // Find the end of the tag (TODO: should check for invalid chars?)
+                for (p1++; *p1 != '>'; p1++) {
+                    if(*p1 == 0 || *p1 == '<'){
+                        LOG.info("XMLProcessor: incomplete tag");
+                        return 0;
+                    }
+                }
+                if(*(p1-1) == '/'){ // <tag attr=xxx />
+                    // Like case '/' below:
+                    p1++;
+                    p2=p1;
+                    closeTag=0;
+                    break;
+                }
+                // The break is not missing!
+                // After the for, we are in the same case of the tag
+                // without attributes
+            case '>':   // <tag>
+                p1++;   // this is the beginning of content
+                if (!p1[0]) {
+                    LOG.info("XMLProcessor: tag at end of file");
+                    return 0;
+                }
+                // Find the closing tag
+                p2 = bstrstr(p1, closeTag);
+                break;
+            case '/':
+                p1++;
+                if(*p1 != '>'){
+                    LOG.info("XMLProcessor: invalid empty tag");
+                    return 0;
+                }
+                p1++;
+                // The tag is already closed, no content: make end = start
+                p2=p1;
+                // Invalidate closeTag
+                closeTag=0;
+                break;
+            case '\n':
+                p1++;
+                p2 = bstrstr(p1, closeTag);
+                break;
+            default:
+                // This is not the searched tag, search again
+                //LOG.debug("XMLProcessor: this is not tag %s", openTag);
+                xmlptr = p1;
+                p1 = 0;
+        }
+    }
+    while (!p1); // If p1 is null and we are here, it means that the 'default'
+                 // case was hit.
+
+    // Closing tag not found
+    if (!p2) {
+        //
+        // This is abc<tag>xyz\0
+        //
+        p1 = NULL;
+        return 0;
+    }
+    
+    // Okay, if we are here, the tag content has been found
+    if (startPos) {
+        *startPos = p1 - xml;
+    }
+    if (endPos) {
+        *endPos = p2 - xml ;
+    }
+    if (pos) {
+        *pos = p2-xml;
+        if (closeTag){
+            *pos += bstrlen(closeTag);
+        }
+    }
+
+    return p1;
+}
+
+const BCHAR* XMLProcessor::getElementContent(const BCHAR* xml,
+                                       const BCHAR* tag,
+                                       unsigned int* pos,
+                                       unsigned int* startPos,
+                                       unsigned int* endPos  )
+{        
+    BCHAR *openTag = 0;
+    BCHAR *closeTag = 0;
+    
+    if (!xml) {
+        return 0;
+    }
+
+    size_t l = bstrlen(tag);
+
+    if(bstrcmp(tag, T("CDATA")) == 0) {
+        openTag = stringdup(T("<![CDATA["));
+        closeTag = stringdup(T("]]>"));
+    }
+    else {
+        openTag = new BCHAR[l+10];
+        closeTag = new BCHAR[l+10];
+        bsprintf(openTag, T("<%s"), tag);
+        bsprintf(closeTag, T("</%s>"), tag);
+    }
+
+    const BCHAR *ret = findElementContent(xml, openTag, closeTag, pos, startPos, endPos);
+
+    if (openTag)
+        delete [] openTag;
+    if (closeTag)
+        delete [] closeTag;
+
+    return ret;
+}
+
+BCHAR* XMLProcessor::getContent(const BCHAR* xml,
+                                unsigned int startPos,
+                                unsigned int endPos  ) {
+
+    BCHAR * ret = NULL;
+
+    if (!xml) {
+        return 0;
+    }
+    if (endPos < startPos) {
+        return 0;
+    }
+    if (bstrlen(xml) < endPos - startPos) {
+        return 0;
+    }
+
+    // figure out whether the text that we are about to copy
+    // contains further elements; if not, treat it as a leaf
+    // element and decode entities
+    BOOL isLeaf = TRUE;
+    unsigned int pos = startPos;
+    while (pos < endPos) {
+        if (xml[pos] == '<') {
+            isLeaf = FALSE;
+            break;
+        }
+        pos++;
+    }
+
+    const BCHAR cdataStart[] = T("<![CDATA[");
+    const int cdataStartLen = sizeof(cdataStart) - 1;
+    const BCHAR cdataEnd[] = T("]]>");
+    const int cdataEndLen = sizeof(cdataEnd) - 1;
+
+    // strip CDATA markers at start and end?
+    if (!isLeaf &&
+        endPos - pos > cdataStartLen + cdataEndLen &&
+        !bstrncmp(xml + pos, cdataStart, cdataStartLen)) {
+        // yep, copy content verbatim;
+        // search real end of data first
+        pos += cdataStartLen;
+        unsigned int cdataEndPos = endPos;
+        while (cdataEndPos - cdataEndLen > pos) {
+            if (!bstrncmp(xml + cdataEndPos - cdataEndLen,
+                          cdataEnd,
+                          cdataEndLen)) {
+                // found "]]>"
+                cdataEndPos -= cdataEndLen;
+                break;
+            }
+            cdataEndPos--;
+        }
+        
+        ret = new BCHAR[cdataEndPos - pos + 1];
+        bstrncpy(ret, xml + pos, cdataEndPos - pos);
+        ret[cdataEndPos - pos] = 0;
+    } else if (isLeaf) {
+        // Decode content of final element:
+        // might contain escaped special characters.
+        //
+        // This must _not_ be done for tags which contain other
+        // tags because then we might destroy the content of e.g.
+        // <Add><Data><![CDATA[ literal entity &amp; ]]></Data></Add>
+        //
+        StringBuffer tmp(xml+startPos, endPos - startPos);
+        tmp.replaceAll("&amp;", "&");
+        tmp.replaceAll("&lt;", "<");
+        ret = stringdup(tmp.c_str());
+    } else {
+        size_t len = endPos - startPos;
+        ret = new BCHAR [len + 1];
+        memcpy( ret, xml + startPos, len * sizeof(BCHAR));
+        ret[len] = 0;
+    }
+
+    return ret;
+}
+
+BCHAR* XMLProcessor::getElementContent(const BCHAR* xml,
+                                       const BCHAR* tag,
+                                       unsigned int* pos)
+{
+    unsigned int start, end;
+
+    if( getElementContent (xml, tag, pos, &start, &end) ) {
+        return getContent(xml, start, end);
+    }
+    return 0;
+}
+
+/*
+* It returns the number of the tag in the xml string
+*/
+
+int XMLProcessor::countElementTag(BCHAR* xml, BCHAR* tag) {
+
+    unsigned int count = 0, pos = 0, previous = 0;
+    
+    while (getElementContent(&xml[pos], tag , &pos, NULL, NULL) != NULL) {
+        pos += previous;
+        previous = pos;
+        count ++;
+    }
+    return count;
+}
+
+
+/*
+* Returns the next tag found in the xml string. It looks at the < and > tags to retrieve 
+* the name of the token. 
+* If <tag xmlns...> it returns "tag"
+* The "pos" argument will contain the position of the close <tag/>
+* The return value is a new BCHAR* and must be fred by the caller. If no tag is found, NULL is returned
+*/
+BCHAR* XMLProcessor::getNextTag(BCHAR* xml, int* pos) {
+    
+    BCHAR* p1, *p2, *p4, *p3 = NULL, *ret = NULL;
+    p1 = p2 = p4 = xml;
+    int i = 0, k = 0, len = 0;
+    BOOL found = FALSE;
+    len = bstrlen(xml);     
+    
+    for (i = 0; i < len; i++) {
+        if (found) {
+            if (p4[i] != '/' && p4[i] != '!' && p4[i] != '-' ) {
+                break; // the element found is right!
+            } else {
+                found = FALSE;
+            }
+        }
+        if (p4[i] == '<') {            
+            p1 = &p4[i];            
+            found = TRUE;
+        }
+    }
+    
+    if (found) {
+        p2 = p1;           
+        for (k = 0; k < len; k++) {             
+            if (*p1 == 0) {
+                break;
+            }
+            else if (*p1 == ' ') {
+                p3 = p1;
+            }
+            else if (*p1 == '>') { 
+                *pos = p1 -xml + 1;
+                if (p3) {                    
+                    p1 = p3;
+                }
+                ret = new BCHAR[(p1)-(p2)];
+                bstrncpy(ret, p2+1, (p1)-(p2+1));
+                ret[(p1)-(p2+1)] = 0;
+                return ret;
+                break;
+            }            
+            p1 = p1 + 1;
+        }
+    }
+    return ret;
+
+}
+
+
+
+/*
+* count the number of "&" (passed as a string) in the token. 
+*/
+int XMLProcessor::countAnd(BCHAR* token) {
+    return countChar(token, T("&"));
+}
+
+int XMLProcessor::countChar(BCHAR* token, BCHAR* element) {
+
+    BCHAR* p1, *p2;
+    p1 = p2 = token;
+    int i = 0, k = 0, len = 0;
+
+    while (bstrstr(p1, element) != NULL) {
+        len = bstrlen(p2);        
+        for (k = 0; k < len; k++) {             
+            if (*p1 == 0) {
+                break;
+            }
+            else if (*p1 == '&') {                
+                p1 = p1 + 1;
+                i++;
+                break;
+            }            
+            p1 = p1 + 1;
+        }  
+    }
+    return i;
+}
+
+
+/*
+* it's as getElementContent but it doesn't get the content of a tag if the parent match except.
+* The parent can be more than one. They have to be separated by &
+* i.e.  
+*
+* getElementContentExcept(xmlPtr, T("Add"), T("Sync&Atomic"), &post)
+*
+* The function returns "... to keep ... " content only 
+*
+* <SyncBody>
+   <Sync>
+     <Add>... to avoid ...</Add>
+   </Sync>
+   <Add>... to keep ...</Add>
+   <Sync>
+     <Add>... to avoid ...</Add>
+   </Sync>
+    <Atomic>
+     <Add>... to avoid ...</Add>
+   </Atomic>
+ </SyncBody>
+*/
+
+BCHAR* XMLProcessor::getElementContentExcept(BCHAR*      xmlPtr    ,
+                                               BCHAR*      tag       ,
+                                               BCHAR*      except    ,
+                                               unsigned int* post) {
+    
+    BCHAR*  ret    = NULL;
+    const BCHAR*  found  = NULL;
+    BCHAR*  xml    = NULL;
+    BCHAR** array = NULL;
+    int*  validElement = NULL;   
+    int count        = 0, countTag = 0;
+    BOOL notValid  = FALSE;
+
+    unsigned int pos      = 0, previous         = 0,
+                 position = 0, previousPosition = 0,
+                 startPos = 0, endPos           = 0;
+    
+    xml = xmlPtr;
+    
+    if (xml == NULL) {
+        return NULL;
+    }     
+    
+    if (except == NULL) {
+        ret = getElementContent(xml, tag, &pos);
+        if (post) {
+            *post = pos;
+        }
+        return ret;
+    }
+    count = countAnd(except);    
+    count++;
+    
+    array = new BCHAR*[count + 1];
+	int l;
+    for (l = 0; l <= count; l++) {
+        array[l] = NULL;
+    }
+    
+    // represent a element found that can be used properly
+    countTag = countElementTag(xml, tag);
+    if (countTag > 0) {
+        validElement = new int[countTag];
+        for (l = 0; l < countTag; l++) {
+            validElement[l] = 1;
+        }
+    }
+
+    BCHAR* internal = stringdup(except);
+    BCHAR* p1, *p2;
+    p1 = p2 = internal;
+    int i = 0, k = 0, len = 0;
+
+    while (bstrstr(p2, T("&")) != NULL) {
+        len = bstrlen(p2);        
+        for (k = 0; k < len; k++) {             
+            if (*p1 == 0) {
+                break;
+            }
+            else if (*p1 == '&') {                
+                *p1 = 0;
+                array[i] = stringdup(p2);
+                p1 = p1 + 1;
+                p2 = p1;
+                i++;
+                break;
+            }            
+            p1 = p1 + 1;
+        }  
+    }
+    
+    if (i == 0 || k < len) {
+        if (array[i]) { delete [] array[i]; array[i] = NULL; }
+        array[i] = stringdup(p2);
+        i++;
+    }
+             
+    for (int s = 0; s < count; s ++) {
+        i = 0;
+
+        do {
+            safeDel(&ret);
+            k = 0;
+
+            pos = 0, previous = 0;
+            while ((ret = getElementContent(&xml[pos], tag, &pos)) != NULL) {    
+            
+                if (validElement && validElement[k] == 1) {
+                    pos += previous;
+                    position = 0; 
+                    previousPosition = 0;
+                    startPos = 0; 
+                    endPos   = 0;
+                    while ((found = getElementContent(&xml[position], array[i], &position, &startPos, &endPos)) != NULL ) {
+        
+                        startPos += previousPosition;
+                        endPos   += previousPosition;
+                        position += previousPosition;
+                        if (startPos < pos && pos < endPos) {
+                            notValid = TRUE;                    
+                            break;
+                        }
+                        previousPosition = position;
+                       
+                    }                    
+
+                    if (notValid) {
+                        notValid = FALSE;     
+                        safeDel(&ret);
+                        validElement[k] = 0;
+                    } else {
+                        if (post) {
+                            *post = pos;
+                        }
+                        break;
+                    }
+                    previous = pos;
+                    k++;
+                } else {
+                    pos += previous;
+                    previous = pos;
+                    k++;
+                    safeDel(&ret); // if (ret) { delete [] ret; ret = NULL; }
+                }
+            }
+            i++;
+
+        } while(array[i] != NULL);
+
+        if (count > 1) {
+            BCHAR* tmp = stringdup(array[0]);
+    
+            for (int m = 0; m < count - 1; m++) {
+                if (array[m]) { delete [] array[m]; array[m] = NULL; }
+                //safeDel(&array[m]);  
+                array[m] = stringdup(array[m+1]);
+            }
+            //safeDel(&array[count-1]);
+            if (array[count-1]) { delete [] array[count-1]; array[count-1] = NULL; }
+            array[count-1] = stringdup(tmp);
+            safeDel(&tmp); 
+        }
+    }       
+    
+    if (notValid) {
+        if (ret) {
+            safeDel(&ret);
+        }
+        if (post) {
+            *post = 0;
+        }
+    } else {
+        ;
+    }
+    
+    safeDel(&internal);
+    if (validElement) {
+        delete [] validElement; validElement = NULL;
+    }
+    
+    for (l = 0; l <= count; l++) {
+        if (array[l]) { delete [] array[l]; array[l] = NULL; }
+    }
+    delete [] array; array = NULL;
+    //safeDelete(array);   
+
+    return ret;
+}
+
+/*
+* It returns getElementContent value but it depends on the level that is specified.
+* It return only ... to keep ... independently on the tag in which it is contained if lev is zero.
+* 
+*   <Sync>
+*     <Add>... to avoid ...</Add>
+*   </Sync>
+*   <Add>... to keep ...</Add>
+*   <Sync>
+*     <Add>... to avoid ...</Add>
+*   </Sync>
+*    <Atomic>
+*     <Add>... to avoid ...</Add>
+*   </Atomic>
+*
+* The parameters are:
+* xml: the xml to analize
+* tag: the name of the tag to use
+* lev: the inner level in which discover the tag
+* startLevel: the starting level from which start the search
+* pos: the position index search end
+*
+* The follow piece of code explain how get the value tag "... to keep ..." that is in the root (0) level.
+* Note the startLevel declaration and initialization to -1 value
+*
+*
+*    BCHAR* p = NULL;
+*    unsigned int pos = 0, previous = 0;
+*    int startLevel = -1;
+*    while ((p = XMLProcessor::getElementContentLevel(&xml[pos], T("Add"), 0, &startLevel, &pos)) != NULL) {        
+*        pos += previous;
+*        previous = pos;                
+*    }
+*
+*/
+
+BCHAR* XMLProcessor::getElementContentLevel(BCHAR*      xml   ,
+                                              BCHAR*      tag   ,                                              
+                                              unsigned int* pos, 
+                                              int           lev ,   
+                                              int*          startLevel)  {
+    
+    BCHAR* p1       = NULL;
+    BCHAR* p2       = NULL;
+    BCHAR* ret      = NULL;
+    BOOL openBracket  = FALSE;  // <
+    BOOL closeBracket = FALSE;  // >
+    BOOL aloneBracket = FALSE;  // </
+    BOOL preCloseBracket = FALSE;  //<.../
+    BOOL openTag      = FALSE;
+    BOOL closeTag     = FALSE;
+
+    BCHAR tagNameFound[40];
+    
+    int level               = -1;
+    unsigned int xmlLength  = (unsigned int)-1;
+    unsigned int l          = (unsigned int)-1;
+    unsigned int previousIndex = (unsigned int)-1;
+    unsigned int i          =  0;    
+    
+    if (xml == NULL) {
+        goto finally;
+    }
+    
+    if (lev < 0) {
+        return getElementContent(xml, tag, pos);
+    }        
+   
+    xmlLength = bstrlen(xml);
+    l = bstrlen(tag);
+
+    if (pos != NULL) {
+        *pos = 0;
+    }
+    if (startLevel != NULL) {
+       level = *startLevel;
+    }
+
+    p1 = p2 = xml;
+    
+    for (i = 0; i < xmlLength; i ++) {
+        if (!bstrncmp(p1 + i, T("<![CDATA["), bstrlen(T("<![CDATA[")))) {
+            // skip over content
+            while(p1[i]) {
+                i++;
+                if (!bstrcmp(p1 + i, T("]]>"))) {
+                    i += bstrlen(T("]]>"));
+                    break;
+                }
+            }
+        }
+        if (p1[i] == '<') {
+            openBracket = TRUE;
+            previousIndex = i;
+            p2 = &p1[i];
+
+        } else if (p1[i] == '/') {
+            if (previousIndex == (i - 1)) {
+                // <.../>                
+                preCloseBracket = TRUE;
+            } else {
+                // TBD  </...>
+            }
+
+        } else if (p1[i] == '>') {  
+            
+            if (openBracket == FALSE) {
+                closeBracket = FALSE;
+                preCloseBracket = FALSE;
+            } else {
+                if (preCloseBracket) {
+                    closeTag = TRUE;
+                }
+                else { 
+                    openTag = TRUE;                    
+                }
+                closeBracket = TRUE;
+                
+                if (closeTag) {
+                    level--;
+                    openBracket  = FALSE;
+                    closeBracket = FALSE;
+                    preCloseBracket = FALSE;
+                    openTag      = FALSE;
+                    closeTag     = FALSE;
+
+                } else if (openTag) {
+                    level++;
+                } else {
+                    openBracket  = FALSE;
+                    closeBracket = FALSE;
+                    preCloseBracket = FALSE;
+                    openTag      = FALSE;
+                    closeTag     = FALSE;
+
+                }                
+            }
+        }         
+          if (openTag && openBracket && closeBracket) {
+            int n = (&p1[i] - p2 - 1);
+            bstrncpy(tagNameFound, p2 + 1, n);         
+            tagNameFound[n] = 0;
+            if (bstrcmp(tagNameFound, tag) == 0 && (level == lev)) {
+                unsigned int internalPos;
+                ret = getElementContent(p2, tag, &internalPos);
+                if (pos) {
+                    *pos = p2 - xml + internalPos;                    
+                }
+                if (startLevel) {
+                    *startLevel = level - 1;
+                }
+                break;
+            }
+            openBracket  = FALSE;
+            closeBracket = FALSE;           
+        }
+    }
+
+finally:
+    openBracket  = FALSE;
+    closeBracket = FALSE;
+    preCloseBracket = FALSE;
+    openTag      = FALSE;
+    closeTag     = FALSE;
+    return ret;
+
+}
+
+/**
+ * Get the attribute list of the forst element 'tag', returning a pointer 
+ * to the beginning of the string in the original buffer 'xml', and the 
+ * starting and ending position of the substring.
+ *
+ * @param xml - the XML document to process.
+ * @param tag - the tag name to find
+ * @param startPos - return value - the start pos of the attribute list
+ * @param endPos - return value - the end position of the attribute list
+ */
+const BCHAR* XMLProcessor::getElementAttributes(const BCHAR* xml,
+                                          const BCHAR* tag,
+                                          unsigned int* startPos,
+                                          unsigned int* endPos, 
+                                          bool escaped) {
+        
+    const BCHAR* p1 = NULL;
+    const BCHAR* p2 = NULL;
+    BOOL charFound  = FALSE;
+    unsigned int l = bstrlen(tag);
+
+    // example ot tag with attribute list
+    // <body enc="base64">
+    BCHAR *openTag = 0; //<tag
+    
+    if (!xml) {
+        goto finally;
+    }
+
+    if(bstrcmp(tag, T("CDATA")) == 0) {
+        goto finally;
+    }
+    else {
+        openTag = new BCHAR[l+10];
+        if (escaped){
+            bsprintf(openTag, T("&lt;%s "), tag);
+        }
+        else{
+            bsprintf(openTag, T("<%s "), tag);
+        }
+    }
+
+    p1 = bstrstr(xml, openTag);
+
+    if (!p1) {
+        LOG.info("XMLProcessor: tag %s not found", tag);
+        goto finally;
+    }
+    // move to the beginning of the attribute list
+    p1 += bstrlen(openTag);
+
+    // find the end of the tag
+    for (p2 = p1; *p2 != '>'; p2++) {
+        if(*p2 == 0 || *p2 == '<'){
+            LOG.info("XMLProcessor: incomplete tag");
+            goto finally;
+        }
+    }
+    // set the return parameters
+    if (startPos != NULL) {
+        *startPos = p1 - xml;
+    }
+    if (endPos != NULL) {
+        *endPos = p2 - xml ;
+    }
+
+    finally:
+
+    if (openTag)
+        delete [] openTag;
+
+    return p1;
+
+}
+
+
+StringBuffer XMLProcessor::makeElement(const BCHAR* tag, const BCHAR* val, const BCHAR* attr)
+{
+    StringBuffer s;
+        
+    if (!val)
+        return s;
+    if (!val[0])
+        return s;
+    
+    size_t len = bstrlen(tag);
+    BCHAR* t1 = new BCHAR[len + 4]; // <  >  0, whitout closing >
+    BCHAR* t2 = new BCHAR[len + 6]; // </ > \n 0
+
+    sprintf(t1, T("<%s"), tag);    
+    sprintf(t2, T("</%s>\n"), tag);
+
+    s = t1; 
+    if (attr != NULL)
+    {
+        s += " ";
+        s += attr;        
+    }
+    s += ">";
+    s += val; s += t2;
+
+    delete [] t1;
+    delete [] t2;
+    
+    return s;    
+}
+
+
+StringBuffer XMLProcessor::makeElement(const BCHAR* tag, 
+                                    const BCHAR* val,
+                                    ArrayList attrList) {
+
+    StringBuffer s;
+    
+    for (int i = 0; i < attrList.size(); i++)
+    {
+        KeyValuePair* item = (KeyValuePair*)attrList[i];
+        if (i > 0)
+            s += " ";
+        s += item->getKey(); 
+        s += "=\"";
+        s += item->getValue(); 
+        s += "\"";
+    }    
+    s = makeElement(tag, val, s.c_str());
+
+    return s;
+}
--- native/src/c++/common/spds/CredentialHandler.cpp~synthesis
+++ native/src/c++/common/spds/CredentialHandler.cpp
@@ -1,231 +1,239 @@
-/*
- * Copyright (C) 2003-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include "spds/CredentialHandler.h"
-
-/*
- * Default constructor
- */
-CredentialHandler::CredentialHandler() {
-    initialize();
-}
-
-/**
- * Initializes private members
- */
-void CredentialHandler::initialize() {
-    username       = NULL;
-    password       = NULL;
-    clientAuthType = NULL;
-    clientNonce    = NULL;
-                  
-    serverID       = NULL;
-    serverPWD      = NULL;
-    serverAuthType = NULL;
-    serverNonce    = NULL;
-}
-
-/*
- * Destructor. Free the allocated memory (if any)
- */
-CredentialHandler::~CredentialHandler() {
-    safeDel(&username       );
-    safeDel(&password       );
-    safeDel(&clientAuthType );
-    safeDel(&clientNonce    );
-    
-    safeDel(&serverID       );
-    safeDel(&serverPWD      );
-    safeDel(&serverAuthType );
-    safeDel(&serverNonce    );
-
-}
-
-void CredentialHandler::setUsername(const BCHAR* t) {
-    safeDel(&username);
-    username = stringdup(t);
-}
-
-void CredentialHandler::setPassword(const BCHAR* t) {
-    safeDel(&password);
-    password = stringdup(t);
-}
-
-void CredentialHandler::setClientAuthType(const BCHAR* t){
-    safeDel(&clientAuthType);
-    clientAuthType = stringdup(t);
-}
-
-const BCHAR* CredentialHandler::getClientAuthType(BCHAR* t){    
-    if (t == NULL) {
-        return clientAuthType;
-    }
-    return bstrcpy(t, clientAuthType);    
-}
-
-
-void CredentialHandler::setClientNonce(const BCHAR* t){
-    safeDel(&clientNonce);
-    clientNonce = stringdup(t);
-}
-
-const BCHAR* CredentialHandler::getClientNonce(BCHAR* t) {
-     if (t == NULL) {
-        return clientNonce;
-    }
-    return bstrcpy(t, clientNonce);        
-}
-
-void CredentialHandler::setServerID(const BCHAR* t) {
-    safeDel(&serverID);
-    serverID = stringdup(t);
-}
-
-void CredentialHandler::setServerPWD(const BCHAR* t) {
-    safeDel(&serverPWD);
-    serverPWD = stringdup(t);
-}
-
-void CredentialHandler::setServerAuthType(const BCHAR* t) {
-    safeDel(&serverAuthType);
-    serverAuthType = stringdup(t);
-}
-
-const BCHAR* CredentialHandler::getServerAuthType(BCHAR* t) {
-     if (t == NULL) {
-        return serverAuthType;
-    }
-    return bstrcpy(t, serverAuthType);        
-}
-
-void CredentialHandler::setServerNonce(const BCHAR* t) {
-    safeDel(&serverNonce);
-    serverNonce = stringdup(t); 
-}
-
-const BCHAR* CredentialHandler::getServerNonce(BCHAR* t) {
-     if (t == NULL) {
-        return serverNonce;
-    }
-    return bstrcpy(t, serverNonce);        
-}
-
-void CredentialHandler::setServerAuthRequired(BOOL t) {
-    isServerAuthRequired = t;    
-}
-
-BOOL CredentialHandler::getServerAuthRequired() {
-    return isServerAuthRequired;    
-}
-
-Cred* CredentialHandler::getClientCredential() {
-    
-    Authentication* auth = NULL;
-    BCHAR* credential  = NULL;
-    if (bstrcmp(clientAuthType, AUTH_TYPE_BASIC) == 0) {
-        auth = new Authentication(AUTH_TYPE_BASIC, username, password);
-    } else {
-        credential = MD5CredentialData(username, password, clientNonce);
-        auth = new Authentication(AUTH_TYPE_MD5, credential);                   
-        if (credential) { delete [] credential; credential = NULL; }
-    }
-    
-    Cred* cred           = new Cred(auth);    
-    
-    deleteAuthentication(&auth);    
-    return cred;
-
-}
-
-/*
-* it returns the server credential. The method is used both during the request of authentication
-* and the creation of the status as response of server authentication.
-* Therefore, if the server is arleady authenticated, no credential are sent back. 
-*/
-
-
-Cred* CredentialHandler::getServerCredential() {
-    
-    Authentication* auth = NULL;
-    Cred* cred           = NULL;
-    BCHAR* credential  = NULL;
-    if (bstrcmp(serverAuthType, AUTH_TYPE_BASIC) == 0) {
-        auth = new Authentication(AUTH_TYPE_BASIC, serverID, serverPWD);
-    } else {
-        credential = MD5CredentialData(serverID, serverPWD, serverNonce);
-        auth = new Authentication(AUTH_TYPE_MD5, credential);                    
-    }    
-    
-    cred = new Cred(auth);        
-
-    deleteAuthentication(&auth);    
-    return cred;
-
-}
-
-BOOL CredentialHandler::performServerAuth(Cred* cred) {
-    
-    BOOL ret = FALSE;
-    Cred* currentCred = getServerCredential();
-    
-    if (cred == NULL || currentCred == NULL) {
-        goto finally;
-    }    
-    
-    if (bstrcmp(cred->getData(NULL), currentCred->getData(NULL)) == 0) {
-        ret = TRUE;
-    }
-finally:
-    
-    return ret;
-}
-
-Chal* CredentialHandler::getServerChal(BOOL isServerAuthenticated) {
-    
-    Chal* chal = NULL;
-
-    if (bstrcmp(serverAuthType, AUTH_TYPE_BASIC) == 0 && isServerAuthenticated == FALSE) {
-        chal = Chal::getBasicChal();
-
-    } else if (bstrcmp(serverAuthType, AUTH_TYPE_MD5) == 0) { // MD5
-        chal = Chal::getMD5Chal();
-        char nonce[16];
-        generateNonce(nonce);
-        NextNonce* nextNonce = new NextNonce(nonce, 16);
-        chal->setNextNonce(nextNonce);
-        setServerNonce(nextNonce->getValueAsBase64());
-    }
-        
-    return chal;
-}
-
-
-// private
-void CredentialHandler::generateNonce(char nonce[16]) {
-    srand((unsigned int)time(NULL));
-    for (unsigned int i = 0; i < 16; i++) {
-        nonce[i] = ((rand()%100) * (rand()%100))%100;
-
-        if (nonce[i] < 32) {
-            nonce[i] +=96;
-        }
-    }
-}
-
-
+/*
+ * Copyright (C) 2003-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#include "spds/CredentialHandler.h"
+
+/*
+ * Default constructor
+ */
+CredentialHandler::CredentialHandler() {
+    initialize();
+}
+
+/**
+ * Initializes private members
+ */
+void CredentialHandler::initialize() {
+    username       = NULL;
+    password       = NULL;
+    clientAuthType = NULL;
+    clientNonce    = NULL;
+                  
+    serverID       = NULL;
+    serverPWD      = NULL;
+    serverAuthType = NULL;
+    serverNonce    = NULL;
+}
+
+/*
+ * Destructor. Free the allocated memory (if any)
+ */
+CredentialHandler::~CredentialHandler() {
+    safeDel(&username       );
+    safeDel(&password       );
+    safeDel(&clientAuthType );
+    safeDel(&clientNonce    );
+    
+    safeDel(&serverID       );
+    safeDel(&serverPWD      );
+    safeDel(&serverAuthType );
+    safeDel(&serverNonce    );
+
+}
+
+void CredentialHandler::setUsername(const BCHAR* t) {
+    safeDel(&username);
+    username = stringdup(t);
+}
+
+const BCHAR *CredentialHandler::getUsername() {
+    return username;
+}
+
+void CredentialHandler::setPassword(const BCHAR* t) {
+    safeDel(&password);
+    password = stringdup(t);
+}
+
+const BCHAR *CredentialHandler::getPassword() {
+    return password;
+}
+
+void CredentialHandler::setClientAuthType(const BCHAR* t){
+    safeDel(&clientAuthType);
+    clientAuthType = stringdup(t);
+}
+
+const BCHAR* CredentialHandler::getClientAuthType(BCHAR* t){    
+    if (t == NULL) {
+        return clientAuthType;
+    }
+    return bstrcpy(t, clientAuthType);    
+}
+
+
+void CredentialHandler::setClientNonce(const BCHAR* t){
+    safeDel(&clientNonce);
+    clientNonce = stringdup(t);
+}
+
+const BCHAR* CredentialHandler::getClientNonce(BCHAR* t) {
+     if (t == NULL) {
+        return clientNonce;
+    }
+    return bstrcpy(t, clientNonce);        
+}
+
+void CredentialHandler::setServerID(const BCHAR* t) {
+    safeDel(&serverID);
+    serverID = stringdup(t);
+}
+
+void CredentialHandler::setServerPWD(const BCHAR* t) {
+    safeDel(&serverPWD);
+    serverPWD = stringdup(t);
+}
+
+void CredentialHandler::setServerAuthType(const BCHAR* t) {
+    safeDel(&serverAuthType);
+    serverAuthType = stringdup(t);
+}
+
+const BCHAR* CredentialHandler::getServerAuthType(BCHAR* t) {
+     if (t == NULL) {
+        return serverAuthType;
+    }
+    return bstrcpy(t, serverAuthType);        
+}
+
+void CredentialHandler::setServerNonce(const BCHAR* t) {
+    safeDel(&serverNonce);
+    serverNonce = stringdup(t); 
+}
+
+const BCHAR* CredentialHandler::getServerNonce(BCHAR* t) {
+     if (t == NULL) {
+        return serverNonce;
+    }
+    return bstrcpy(t, serverNonce);        
+}
+
+void CredentialHandler::setServerAuthRequired(BOOL t) {
+    isServerAuthRequired = t;    
+}
+
+BOOL CredentialHandler::getServerAuthRequired() {
+    return isServerAuthRequired;    
+}
+
+Cred* CredentialHandler::getClientCredential() {
+    
+    Authentication* auth = NULL;
+    BCHAR* credential  = NULL;
+    if (bstrcmp(clientAuthType, AUTH_TYPE_BASIC) == 0) {
+        auth = new Authentication(AUTH_TYPE_BASIC, username, password);
+    } else {
+        credential = MD5CredentialData(username, password, clientNonce);
+        auth = new Authentication(AUTH_TYPE_MD5, credential);                   
+        if (credential) { delete [] credential; credential = NULL; }
+    }
+    
+    Cred* cred           = new Cred(auth);    
+    
+    deleteAuthentication(&auth);    
+    return cred;
+
+}
+
+/*
+* it returns the server credential. The method is used both during the request of authentication
+* and the creation of the status as response of server authentication.
+* Therefore, if the server is arleady authenticated, no credential are sent back. 
+*/
+
+
+Cred* CredentialHandler::getServerCredential() {
+    
+    Authentication* auth = NULL;
+    Cred* cred           = NULL;
+    BCHAR* credential  = NULL;
+    if (bstrcmp(serverAuthType, AUTH_TYPE_BASIC) == 0) {
+        auth = new Authentication(AUTH_TYPE_BASIC, serverID, serverPWD);
+    } else {
+        credential = MD5CredentialData(serverID, serverPWD, serverNonce);
+        auth = new Authentication(AUTH_TYPE_MD5, credential);                    
+    }    
+    
+    cred = new Cred(auth);        
+
+    deleteAuthentication(&auth);    
+    return cred;
+
+}
+
+BOOL CredentialHandler::performServerAuth(Cred* cred) {
+    
+    BOOL ret = FALSE;
+    Cred* currentCred = getServerCredential();
+    
+    if (cred == NULL || currentCred == NULL) {
+        goto finally;
+    }    
+    
+    if (bstrcmp(cred->getData(NULL), currentCred->getData(NULL)) == 0) {
+        ret = TRUE;
+    }
+finally:
+    
+    return ret;
+}
+
+Chal* CredentialHandler::getServerChal(BOOL isServerAuthenticated) {
+    
+    Chal* chal = NULL;
+
+    if (bstrcmp(serverAuthType, AUTH_TYPE_BASIC) == 0 && isServerAuthenticated == FALSE) {
+        chal = Chal::getBasicChal();
+
+    } else if (bstrcmp(serverAuthType, AUTH_TYPE_MD5) == 0) { // MD5
+        chal = Chal::getMD5Chal();
+        char nonce[16];
+        generateNonce(nonce);
+        NextNonce* nextNonce = new NextNonce(nonce, 16);
+        chal->setNextNonce(nextNonce);
+        setServerNonce(nextNonce->getValueAsBase64());
+    }
+        
+    return chal;
+}
+
+
+// private
+void CredentialHandler::generateNonce(char nonce[16]) {
+    srand((unsigned int)time(NULL));
+    for (unsigned int i = 0; i < 16; i++) {
+        nonce[i] = ((rand()%100) * (rand()%100))%100;
+
+        if (nonce[i] < 32) {
+            nonce[i] +=96;
+        }
+    }
+}
+
+
--- native/src/c++/common/spds/SyncManager.cpp~synthesis
+++ native/src/c++/common/spds/SyncManager.cpp
@@ -1,1616 +1,1668 @@
-/*
- * Copyright (C) 2003-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#include "base/fscapi.h"
-#include "base/Log.h"
-#include "base/debug.h"
-#include "base/util/utils.h"
-#include "base/messages.h"
-#include "http/TransportAgentFactory.h"
-#include "spds/constants.h"
-#include "spds/DataTransformer.h"
-#include "spds/DataTransformerFactory.h"
-#include "spds/SyncManagerConfig.h"
-#include "spds/SyncManager.h"
-#include "spds/SyncMLProcessor.h"
-#include "spds/spdsutils.h"
-#include "syncml/core/TagNames.h"
-#include "syncml/core/ObjectDel.h"
-
-/**
- * Is the given status code an error status code? Error codes are the ones
- * outside the range 200-299.
- *
- * @param status the status code to check
- */
-inline static bool isErrorStatus(int status) {
-    return (status) && ((status < 200) || (status > 299));
-}
-
-/**
- * Return true if the status code is authentication failed
- *
- * @param status the status code to check
- */
-inline static bool isAuthFailed(int status) {
-    return (status) && ((status == 401) || (status == 407));
-}
-
-/**
- * Return true if there's no more work to do
- *
- * @param check - the array of flags to set
- * @param size - the size of the array
- */
-static bool isToExit(int* check, int size) {
-    for (int i = 0; i < size; i++) {
-        if (check[i] == 1) 
-            return false; 
-    }
-    return true;
-}
-
-SyncManager::SyncManager(SyncManagerConfig* c) : config(*c) {
-    initialize();
-}
-
-SyncManager::SyncManager(SyncManagerConfig& c) : config(c) {
-    initialize();
-}
-
-void SyncManager::initialize() {
-    AccessConfig& c = config.getAccessConfig();   
-    
-    credentialHandler = CredentialHandler();
-
-    bstrncpy(syncURL, c.getSyncURL(), 511);
-    bstrncpy(deviceId, c.getDeviceId(), 31);
-    
-    credentialHandler.setUsername           (c.getUsername());
-    credentialHandler.setPassword           (c.getPassword());
-    credentialHandler.setClientNonce        (c.getClientNonce());
-    credentialHandler.setClientAuthType     (c.getClientAuthType());
-
-    credentialHandler.setServerID           (c.getServerID());
-    credentialHandler.setServerPWD          (c.getServerPWD());
-    credentialHandler.setServerNonce        (c.getServerNonce());
-    credentialHandler.setServerAuthType     (c.getServerAuthType());
-    credentialHandler.setServerAuthRequired (c.getServerAuthRequired());
-            
-    transportAgent = NULL;
-    
-    currentState = STATE_START;
-
-    commands = new ArrayList();
-    mappings      = NULL;
-    check         = NULL;
-    sourcesNumber = 0;
-    count         = 0;
-
-    maxMsgSize   = c.getMaxMsgSize();
-    maxModPerMsg = 150;  // dafault value
-    readBufferSize = 5000; // default value    
-
-    if (c.getMaxModPerMsg() > 0)
-        maxModPerMsg = c.getMaxModPerMsg();
-    
-    if (c.getReadBufferSize() > 0)
-        readBufferSize = c.getReadBufferSize();
-    
-    memset(userAgent, 0, 128*sizeof(BCHAR));
-    bstrcpy(userAgent, c.getUserAgent());
-    if (bstrlen(userAgent) == 0) {
-        bstrcpy(userAgent, BCHAR_USER_AGENT);
-    }
-                  
-    syncMLBuilder.set(syncURL, deviceId, maxMsgSize);
-    memset(credentialInfo, 0, 256*sizeof(BCHAR));
-}
-
-SyncManager::~SyncManager() {
-    if (transportAgent) {
-        delete transportAgent;
-    }
-    if (commands) {
-        commands->clear(); delete commands; commands = NULL;
-    }
-    if (check) {
-        delete [] check; check = NULL;
-    }
-    if (mappings) {
-        for (int i=0; i<sourcesNumber; i++) {
-            deleteArrayList(&mappings[i]);
-            delete mappings[i];
-        }
-        delete [] mappings; mappings = NULL;
-    }
-    if (sources) {
-        // This deletes only SyncSource array
-        // We DON'T want to release SyncSource objects here!
-        delete [] sources;
-    }
-}
-
-/*
- * Modification to perform the sync of an array of sync sources.
- */
-
-int SyncManager::prepareSync(SyncSource** s) {
-    
-    BCHAR* initMsg            = NULL;
-    BCHAR* respURI            = NULL;
-    BCHAR* responseMsg        = NULL;
-    SyncML*  syncml             = NULL;
-    int ret                     = 0;
-    int serverRet               = 0;
-    int count                   = 0;    
-    const BCHAR* requestedAuthType  = NULL;
-    ArrayList* list             = new ArrayList();
-    ArrayList* alerts           = new ArrayList();
-    
-    // for authentication improvments
-    BOOL isServerAuthRequired   = credentialHandler.getServerAuthRequired();
-    int clientAuthRetries       = 1;
-    int serverAuthRetries       = 1;    
-    int authStatusCode          = 200;
-
-    BOOL isClientAuthenticated  = FALSE;
-    BOOL isServerAuthenticated  = FALSE;
-    Chal*   clientChal          = NULL; // The chal of the server to the client
-    Chal*   serverChal          = NULL; // The chal of the client to the server
-    Status* status              = NULL; // The status from the client to the server
-    Cred*   cred                = NULL;
-    Alert*  alert               = NULL;
-    SyncSource** buf            = NULL;
-    const BCHAR *syncURL;
-    
-    syncURL = config.getAccessConfig().getSyncURL(); //sizeof(syncURL));
-
-    URL url(syncURL);
-    Proxy proxy;
-
-    // Set proxy username/password if proxy is used.
-    if (config.getAccessConfig().getUseProxy()) {
-        //BCHAR* proxyHost = config.getAccessConfig().getProxyHost();
-        //int    proxyPort = config.getAccessConfig().getProxyPort();
-        BCHAR* proxyUser = config.getAccessConfig().getProxyUsername();
-        BCHAR* proxyPwd  = config.getAccessConfig().getProxyPassword();
-        proxy.setProxy(NULL, 0, proxyUser, proxyPwd);
-    }
-    
-    const BCHAR* sourceName = NULL;
-    
-    sourcesNumber = assignSources(s);
-    check = new int[sourcesNumber + 1];
-    mappings = new ArrayList*[sourcesNumber + 1];
-    for (count = 0; count < sourcesNumber; count++) {
-        check[count] = 1;
-        mappings[count] = new ArrayList();
-    }
-    check[sourcesNumber] = 0;
-
-    // --- INFO
-    bsprintf(logmsg, MSG_SYNC_URL, syncURL);
-    LOG.info(logmsg);
-    for (count = 0; count < sourcesNumber; count++) {
-        bsprintf(logmsg, MSG_PREPARING_SYNC, _wcc(sources[count]->getName()));
-        LOG.info(logmsg);
-    }
-    // ---
-
-    syncMLBuilder.resetMessageID();
-    syncMLBuilder.resetCommandID();
-    syncMLBuilder.resetMessageID();
-    unsigned long timestamp = (unsigned long)time(NULL);
-    config.getAccessConfig().setBeginSync(timestamp);
-    for (count = 0; count < sourcesNumber; count ++) {
-        if (readSyncSourceDefinition(*sources[count]) == false) {
-            ret = lastErrorCode = ERR_SOURCE_DEFINITION_NOT_FOUND;
-            bsprintf(lastErrorMsg, ERRMSG_SOURCE_DEFINITION_NOT_FOUND,
-                                   _wcc(sources[count]->getName()));
-            LOG.debug(lastErrorMsg);
-            check[count] = 0;
-        }
-    }
-    
-    for (count = 0; count < sourcesNumber; count ++) {
-        if (!check[count])
-            continue;
-
-        if (sources[count]->getSyncMode() == SYNC_NONE) {
-            check[count] = 0;
-        }
-    }
-        
-    if (isToExit(check, sourcesNumber)) {
-        // error. no source to sync
-        ret = lastErrorCode = ERR_NO_SOURCE_TO_SYNC;
-        bsprintf(lastErrorMsg, ERRMSG_NO_SOURCE_TO_SYNC);
-
-        goto finally;
-    }
-          
-    if (isServerAuthRequired == FALSE) 
-        isServerAuthenticated = TRUE;
-
-    do {
-        deleteCred(&cred);
-        deleteAlert(&alert);
-        deleteSyncML(&syncml);
-        deleteArrayList(&alerts);
-
-        bool addressChange = false;
-
-        // credential of the client
-        if (isClientAuthenticated == FALSE) {
-            BCHAR anc[DIM_ANCHOR];
-            timestamp = (unsigned long)time(NULL);
-            for (count = 0; count < sourcesNumber; count ++) {
-                if (!check[count])
-                    continue;
-                sources[count]->setNextSync(timestamp);
-                timestampToAnchor(sources[count]->getNextSync(), anc);
-                sources[count]->setNextAnchor(anc);
-                // Test if this source is for AddressChangeNotification
-                int prefmode = sources[count]->getPreferredSyncMode();
-                if( prefmode == SYNC_ADDR_CHANGE_NOTIFICATION ) {
-                    alert = syncMLBuilder.prepareAddrChangeAlert(*sources[count]);
-                    if(!alert) {
-                        ret = lastErrorCode = 745; // FIXME
-                        goto finally;
-                    }
-                    addressChange = true;   // remember that this sync is for
-                                            // address change notification
-                }
-                else {
-                    alert = syncMLBuilder.prepareInitAlert(*sources[count]);
-                }
-                alerts->add(*alert);
-                deleteAlert(&alert);
-            }                        
-            cred = credentialHandler.getClientCredential();             
-            bstrcpy(credentialInfo, cred->getAuthentication()->getData(NULL));            
-        }
-        syncml = syncMLBuilder.prepareInitObject(cred, alerts, commands);
-        if (syncml == NULL) {
-            ret = lastErrorCode;
-            goto finally;
-        }  
-       
-        initMsg = syncMLBuilder.prepareMsg(syncml);
-        if (initMsg == NULL) {
-            ret = lastErrorCode;
-            goto finally;
-        }        
-
-        LOG.debug(MSG_INITIALIZATATION_MESSAGE);
-        LOG.debug("%s", initMsg);
-
-        currentState = STATE_PKG1_SENDING;
-
-        if (transportAgent == NULL) {
-            transportAgent = TransportAgentFactory::getTransportAgent(url, proxy);
-            transportAgent->setReadBufferSize(readBufferSize);
-            transportAgent->setUserAgent(userAgent);            
-            
-            if (maxMsgSize > 0) {
-                transportAgent->setMaxMsgSize(maxMsgSize);
-            }
-            
-        } else {
-            transportAgent->setURL(url);
-        }
-        if (lastErrorCode != 0) { // connection: lastErrorCode = 2005: Impossible to establish internet connection
-            ret = lastErrorCode;
-            goto finally;
-        }  
-
-        deleteSyncML(&syncml);         
-        deleteChal(&serverChal);
-        deleteArrayList(&commands);
-        deleteCred(&cred);
-
-        responseMsg = transportAgent->sendMessage(initMsg);
-        if (responseMsg == NULL) {
-            // This is an error only is it is not an AddressChange
-            if ( addressChange && lastErrorCode == ERR_READING_CONTENT ) {
-                ret = 0;
-            }
-            else {
-                ret = lastErrorCode;
-            }
-            goto finally;
-        }
-
-        // increment the msgRef after every send message
-        syncMLBuilder.increaseMsgRef();
-        syncMLBuilder.resetCommandID();
-
-        syncml = syncMLProcessor.processMsg(responseMsg);
-        safeDelete(&responseMsg);
-        safeDelete(&initMsg);
-        
-        if (syncml == NULL) {
-            ret = lastErrorCode;
-            LOG.error(T("Error processing alert response."));
-            goto finally;
-        }
-        
-        // ret = syncMLProcessor.processInitResponse(*sources[0], syncml, alerts);
-
-        ret = syncMLProcessor.processSyncHdrStatus(syncml);
-
-        if (ret == -1) {
-            ret = lastErrorCode;
-            LOG.error(T("Error processing SyncHdr Status"));
-            goto finally;
-
-        } else if (isErrorStatus(ret) && ! isAuthFailed(ret)) {
-            lastErrorCode = ret;
-            bsprintf(logmsg, T("Error from server %d"), ret);
-            LOG.error(logmsg);
-            goto finally;
-        }
-
-        for (count = 0; count < sourcesNumber; count ++) {
-            if (!check[count])
-                continue;
-
-            ret = syncMLProcessor.processAlertStatus(*sources[count], syncml, alerts);
-            if (ret == -1 || ret == 404 || ret == 415) {
-                lastErrorCode = ret;
-                bsprintf(logmsg, T("AlertStatus from server %d"), ret);
-                LOG.error(logmsg);
-                check[count] = 0;   
-            }
-        } 
-        if (isToExit(check, sourcesNumber)) {
-            // error. no source to sync
-            ret = lastErrorCode;
-            goto finally;
-        }
-        
-        //
-        // Set the uri with session
-        //
-        respURI = syncMLProcessor.getRespURI(syncml->getSyncHdr());
-        if (respURI) {
-            url = respURI;
-            transportAgent->setURL(url);
-        }
-        //
-        // Server Authentication
-        //
-        if (isServerAuthenticated == FALSE) {
-            
-            cred = syncml->getSyncHdr()->getCred();
-            if (cred == NULL) {
-                if (serverAuthRetries == 1) {
-                    // create the serverNonce if needed and set into the CredentialHendler, serverNonce property
-                    serverChal = credentialHandler.getServerChal(isServerAuthenticated); 
-                    authStatusCode = 407;                    
-                    serverAuthRetries++;
-                } else {
-                     ret = -1;
-                     goto finally;
-                }
-
-            } else {                
-                isServerAuthenticated = credentialHandler.performServerAuth(cred);                                
-                if (isServerAuthenticated) {
-                    serverChal   = credentialHandler.getServerChal(isServerAuthenticated); 
-                    authStatusCode = 212;                    
-                }
-                else {
-                    if (bstrcmp(credentialHandler.getServerAuthType(NULL), AUTH_TYPE_MD5) == 0 ||
-                        serverAuthRetries == 1)
-                    {
-                        serverChal   = credentialHandler.getServerChal(isServerAuthenticated);
-                        authStatusCode = 401;
-                        
-                    } else {
-                        ret = -1;   //XXX
-                        LOG.error(T("Server not authenticated"));
-                        goto finally;
-                    }
-                    serverAuthRetries++;
-                }
-            } 
-            cred = NULL; // this cred is only a reference
-        } else  {
-            authStatusCode = 200;            
-        }
-        status = syncMLBuilder.prepareSyncHdrStatus(serverChal, authStatusCode);
-        commands->add(*status);
-        deleteStatus(&status);
-        list = syncMLProcessor.getCommands(syncml->getSyncBody(), ALERT);    
-        for (count = 0; count < sourcesNumber; count ++) {
-            if (!check[count])
-                continue;
-
-            status = syncMLBuilder.prepareAlertStatus(*sources[count], list, authStatusCode);    
-            if (status) {
-                commands->add(*status);
-                deleteStatus(&status);    
-            }
-        }  
-        
-        //
-        // Client Authentication. The auth of the client on the server
-        //
-        clientChal = syncMLProcessor.getChal(syncml->getSyncBody());
-
-        if (isAuthFailed(ret)) {                        
-            if (clientChal == NULL) {
-                requestedAuthType = credentialHandler.getClientAuthType();
-            } else {
-                requestedAuthType = clientChal->getType(NULL);
-            }
-            if (bstrcmp(credentialHandler.getClientAuthType(NULL),requestedAuthType) != 0 ) {           
-                if (clientChal && bstrcmp(requestedAuthType, AUTH_TYPE_MD5) == 0) {
-                    credentialHandler.setClientNonce(clientChal->getNextNonce()->getValueAsBase64());
-                }                 
-            } else { 
-                if (bstrcmp(requestedAuthType, AUTH_TYPE_MD5) == 0 && clientAuthRetries == 1)  {
-                    credentialHandler.setClientNonce(clientChal->getNextNonce()->getValueAsBase64());
-                 
-                } else {
-                    ret = 401;
-                    LOG.error(T("Client not authenticated"));
-                    goto finally;
-                }                                    
-            }
-            credentialHandler.setClientAuthType(requestedAuthType); 
-            clientAuthRetries++;            
-
-       } else {            
-            if (clientChal && bstrcmp(clientChal->getType(NULL), AUTH_TYPE_MD5) == 0) {                    
-                credentialHandler.setClientNonce(clientChal->getNextNonce()->getValueAsBase64());                
-            }
-            isClientAuthenticated = TRUE;
-            for (count = 0; count < sourcesNumber; count ++) {
-                if (!check[count])
-                    continue;
-                ret = syncMLProcessor.processServerAlert(*sources[count], syncml);
-                if (isErrorStatus(ret)) {
-                    check[count] = 0;   
-                }
-            }  
-       }
-    
-    } while(isClientAuthenticated == FALSE || isServerAuthenticated == FALSE);
-
-    config.getAccessConfig().setClientNonce(credentialHandler.getClientNonce(NULL));
-    config.getAccessConfig().setServerNonce(credentialHandler.getServerNonce(NULL));
-    
-    if (isToExit(check, sourcesNumber)) {
-        // error. no source to sync
-        ret = -1;
-        goto finally;
-    }
-
-    currentState = STATE_PKG1_SENT;
-    
-// ---------------------------------------------------------------------------------------
-finally:
-
-    if (respURI) {
-        delete [] respURI;
-    }
-    if (responseMsg) {
-        safeDelete(&responseMsg);
-    }
-    if (initMsg) {
-        safeDelete(&initMsg);
-    }
-
-    deleteSyncML(&syncml);
-    deleteCred(&cred);
-    deleteAlert(&alert);
-    deleteStatus(&status);
-    deleteChal(&serverChal);    
-    return ret;
-}
-
-int SyncManager::sync() {
-
-    BCHAR* msg         = NULL;
-    BCHAR* responseMsg = NULL;
-    Status* status       = NULL;
-    SyncML* syncml       = NULL;
-    SyncItem* syncItem   = NULL;
-    SyncItem* sItem      = NULL;
-    Alert* alert         = NULL;
-    ModificationCommand* modificationCommand = NULL;
-    unsigned int tot     = 0; 
-    unsigned int step    = 0; 
-    unsigned int toSync  = 0;
-    unsigned int iterator= 0;
-    int ret              = 0;  
-    BOOL last            = FALSE;
-    ArrayList* list      = new ArrayList();
-    BOOL isFinalfromServer = FALSE;
-    BOOL isAtLeastOneSourceCorrect = FALSE;
-
-    //for refresh from server sync
-    allItemsList = new ArrayList*[sourcesNumber]; 
-
-    //
-    // If this is the first message, currentState is STATE_PKG1_SENT,
-    // otherwise it is already in STATE_PKG3_SENDING.
-    //
-    if (currentState == STATE_PKG1_SENT) {
-        currentState = STATE_PKG3_SENDING;
-    }
-
-    // The real number of source to sync
-    for (count = 0; count < sourcesNumber; count ++) {
-        allItemsList[count] = NULL;
-        if (!check[count])
-            continue;
-        toSync++;
-    }
-
-    for (count = 0; count < sourcesNumber; count ++) {
-        if (!check[count])
-            continue;
-
-        tot  = 0;
-        step = 0;
-        last = FALSE;        
-        iterator++;
-
-        if ( sources[count]->beginSync() ) {
-            // Error from SyncSource
-            lastErrorCode = ERR_UNSPECIFIED;
-            ret = lastErrorCode;
-            check[count]=0;            
-            continue;
-        }
-        else
-        {
-            isAtLeastOneSourceCorrect = TRUE;
-        }
-
-        do {
-
-            //
-            // Sets the proper encoding for the content of the items.
-            //
-            if (config.isEncryption()) {
-                syncMLBuilder.setEncPassword(credentialInfo);
-                syncMLBuilder.setEncoding(DESB64);
-            } else {
-                // TBD: if we are using vcard/icalendar, we need to 
-                // set the encoding to PLAIN
-                if (bstrcmp(_wcc(sources[count]->getEncoding()), B64_ENCODING) == 0) {
-                    syncMLBuilder.setEncoding(B64);
-                } else {
-                    syncMLBuilder.setEncoding(PLAIN);
-                }   
-
-            }
-
-            if (modificationCommand) {
-                delete modificationCommand; 
-                modificationCommand = NULL;
-            }
-
-            if (commands->isEmpty()) {
-
-                status = syncMLBuilder.prepareSyncHdrStatus(NULL, 200);
-                commands->add(*status);
-                deleteStatus(&status);
-
-                /* The server should not send any alert...
-                   list = syncMLProcessor.getCommands(syncml->getSyncBody(), ALERT);   
-                   status = syncMLBuilder.prepareAlertStatus(*sources[0], list, 200);
-
-                   if (status) {
-                   commands->add(*status);
-                   deleteStatus(&status);    
-                   }
-                   deleteArrayList(&list);
-                 */
-            }
-
-            deleteSyncML(&syncml);
-
-            Sync* sync = syncMLBuilder.prepareSyncCommand(*sources[count]);
-            ArrayList* list = new ArrayList();
-
-            switch (sources[count]->getSyncMode()) {
-                case SYNC_SLOW: 
-                    {   
-                        sItem = NULL;
-                        if (tot == 0) {                    
-                            sItem = sources[count]->getFirstItem();                        
-                            if (sItem) {
-                                syncItem = (SyncItem*)sItem->clone();
-                            }
-                        }
-                        tot = 0;
-                        do {
-                            if (syncItem == NULL) {
-                                sItem = sources[count]->getNextItem();
-                                if (sItem)
-                                    syncItem = (SyncItem*)sItem->clone();                     
-                            }
-                            if (modificationCommand == NULL) {
-                                modificationCommand = 
-                                    syncMLBuilder.prepareModificationCommand(
-                                                            REPLACE_COMMAND_NAME, 
-                                                            syncItem,
-                                                            sources[count]->getType()
-                                                  );
-                            } else {
-                                syncMLBuilder.addItem(modificationCommand,
-                                                      REPLACE_COMMAND_NAME,
-                                                      syncItem, 
-                                                      sources[count]->getType());
-                            }
-
-                            if (syncItem) {
-                                // the item is only the pointer not another instance. to save mem
-                                delete syncItem; syncItem = NULL;
-                            }
-                            else {
-                                last = TRUE;
-                                break;
-                            }
-                            tot++;
-                            sItem = NULL;
-                        } while( tot < maxModPerMsg);                                                    
-                    }
-                    break;
-
-                case SYNC_REFRESH_FROM_SERVER:
-                    last = TRUE; 
-
-                    allItemsList[count] = new ArrayList();
-                    sItem = sources[count]->getFirstItemKey();
-                    if(sItem) {
-                        allItemsList[count]->add((ArrayElement&)*sItem);
-                    }
-                    sItem = sources[count]->getNextItemKey();
-                    while(sItem) {
-                        allItemsList[count]->add((ArrayElement&)*sItem);
-                        sItem = sources[count]->getNextItemKey();	
-                    } 
-                    break;
-
-                case SYNC_ONE_WAY_FROM_SERVER:
-                    last = TRUE;
-                    break;
-
-                case SYNC_REFRESH_FROM_CLIENT:
-                    {   
-                        sItem = NULL;
-                        if (tot == 0) {                    
-                            sItem = sources[count]->getFirstItem();                        
-                            if (sItem) {
-                                syncItem = (SyncItem*)sItem->clone();
-                            }
-                        }
-                        tot = 0;
-                        do {
-                            if (syncItem == NULL) {
-                                sItem = sources[count]->getNextItem();
-                                if (sItem)
-                                    syncItem = (SyncItem*)sItem->clone();                     
-                            }
-                            if (modificationCommand == NULL) {
-                                modificationCommand = syncMLBuilder.prepareModificationCommand(REPLACE_COMMAND_NAME, 
-                                        syncItem, sources[count]->getType());
-                            } else {
-                                syncMLBuilder.addItem(modificationCommand, REPLACE_COMMAND_NAME, syncItem, 
-                                        sources[count]->getType());
-                            }
-
-                            if (syncItem) {
-                                delete syncItem; syncItem = NULL;// the item is only the pointer not another instance. to save mem                        
-                            }
-                            else {
-                                last = TRUE;
-                                break;
-                            }
-                            tot++;
-                            sItem = NULL;
-                        } while( tot < maxModPerMsg);                                                    
-                    }
-                    break;
-
-                default:
-                    {    
-                        tot = 0;
-                        //
-                        // New Item
-                        //
-                        sItem = NULL;
-                        if (step == 0) {
-                            sItem = sources[count]->getFirstNewItem(); 
-                            if (sItem)
-                                syncItem = (SyncItem*)sItem->clone();
-                            step++;
-                            if (syncItem == NULL)
-                                step++;                        
-                        }
-                        if (step == 1) {                                                          
-                            do {
-                                if (syncItem == NULL) {
-                                    sItem = sources[count]->getNextNewItem();
-                                    if (sItem)   
-                                        syncItem = (SyncItem*)sItem->clone(); 
-                                }
-                                if (modificationCommand == NULL) {
-                                    modificationCommand = syncMLBuilder.prepareModificationCommand(ADD_COMMAND_NAME, 
-                                            syncItem, sources[count]->getType());
-                                } else {
-                                    syncMLBuilder.addItem(modificationCommand, ADD_COMMAND_NAME, 
-                                            syncItem, sources[count]->getType());
-                                }
-
-                                if (syncItem) {
-                                    delete syncItem; syncItem = NULL;
-                                }
-                                else {
-                                    step++;
-                                    break;
-                                }
-                                tot++;
-                                sItem = NULL;
-                            } while( tot < maxModPerMsg);
-                        }
-
-                        //
-                        // Updated Item
-                        //
-                        if (step == 2) {
-
-                            if (modificationCommand) {
-                                list->add(*modificationCommand);
-                                delete modificationCommand; 
-                                modificationCommand = NULL;
-                            }
-
-                            sItem = sources[count]->getFirstUpdatedItem();
-                            if (sItem)
-                                syncItem = (SyncItem*)sItem->clone();
-
-                            step++;
-                            if (syncItem == NULL)
-                                step++;    
-                        }
-                        if (step == 3) {
-                            do {
-                                if (syncItem == NULL) {
-                                    sItem = sources[count]->getNextUpdatedItem();
-                                    if (sItem)
-                                        syncItem = (SyncItem*)sItem->clone();
-
-                                }
-                                if (modificationCommand == NULL) {
-                                    modificationCommand = syncMLBuilder.prepareModificationCommand(REPLACE_COMMAND_NAME, 
-                                            syncItem, sources[count]->getType());
-                                } else {
-                                    syncMLBuilder.addItem(modificationCommand, REPLACE_COMMAND_NAME, 
-                                            syncItem, sources[count]->getType());
-                                }
-
-                                if (syncItem) {                            
-                                    delete syncItem; syncItem = NULL;
-                                }
-                                else {
-                                    step++;
-                                    break;
-                                }
-                                tot++;
-                                sItem = NULL;
-                            } while( tot < maxModPerMsg);                                                      
-                        } 
-
-                        //
-                        // Deleted Item
-                        //
-                        if (step == 4) {
-
-                            if (modificationCommand) {
-                                list->add(*modificationCommand);
-                                delete modificationCommand; 
-                                modificationCommand = NULL;
-                            }
-
-                            sItem = sources[count]->getFirstDeletedItem();
-
-                            if (sItem)
-                                syncItem = (SyncItem*)sItem->clone();
-
-                            step++;
-                            if (syncItem == NULL)
-                                step++;    
-                        }
-                        if (step == 5) {
-                            do {
-                                if (syncItem == NULL) {
-                                    sItem = sources[count]->getNextDeletedItem(); 
-                                    if (sItem)
-                                        syncItem = (SyncItem*)sItem->clone();                        
-                                }
-                                if (modificationCommand == NULL) {
-                                    modificationCommand = syncMLBuilder.prepareModificationCommand(DELETE_COMMAND_NAME, 
-                                            syncItem, sources[count]->getType());
-                                } else {
-                                    syncMLBuilder.addItem(modificationCommand, DELETE_COMMAND_NAME, 
-                                            syncItem, sources[count]->getType());
-                                }
-
-                                if (syncItem) {                            
-                                    delete syncItem; syncItem = NULL;
-                                }
-                                else {
-                                    step++;
-                                    break;
-                                }
-                                tot++;
-                                sItem = NULL;
-                            } while( tot < maxModPerMsg);           
-                        }
-                        if (step == 6 && syncItem == NULL)
-                            last = TRUE;
-
-                        break;
-                    }
-            }
-
-            if (modificationCommand) {
-                list->add(*modificationCommand);
-                delete modificationCommand; 
-                modificationCommand = NULL;
-            }                     
-            sync->setCommands(list);
-            delete list;
-            commands->add(*sync);
-            delete sync;
-
-            //
-            // Check if all the sources were synced.
-            // If not the prepareSync doesn't use the <final/> tag 
-            //
-            syncml = syncMLBuilder.prepareSyncML(commands, (iterator != toSync ? FALSE : last));
-            msg    = syncMLBuilder.prepareMsg(syncml);       
-
-            deleteSyncML(&syncml);
-            deleteArrayList(&commands);
-
-            if (msg == NULL) {
-                ret = lastErrorCode;
-                goto finally;
-            }
-
-            // Synchronization message:
-
-            LOG.debug(MSG_MODIFICATION_MESSAGE);
-            LOG.debug("%s", msg);
-
-            responseMsg = transportAgent->sendMessage(msg);
-            if (responseMsg == NULL) {
-                ret=lastErrorCode;
-                goto finally;
-            }
-            // increment the msgRef after every send message
-            syncMLBuilder.increaseMsgRef();
-            syncMLBuilder.resetCommandID();
-
-            syncml = syncMLProcessor.processMsg(responseMsg);
-            safeDelete(&responseMsg);
-            safeDelete(&msg);
-
-            if (syncml == NULL) {
-                ret = lastErrorCode;
-                goto finally;
-            }               
-
-            isFinalfromServer = syncml->isLastMessage();
-            ret = syncMLProcessor.processSyncHdrStatus(syncml);
-
-            if (isErrorStatus(ret)) {
-                lastErrorCode = ret;
-                bsprintf(lastErrorMsg, T("Server Failure: server returned error code %i"), ret);
-                LOG.error(lastErrorMsg);
-                goto finally;
-
-            }
-            ret = 0;
-            // 
-            // Process the status of the item sent by client. It invokes the 
-            // source method 
-            //
-            int itemret = syncMLProcessor.processItemStatus(*sources[count], syncml->getSyncBody());
-            if(itemret){
-                char *name = toMultibyte(sources[count]->getName());
-                LOG.error("Error #%d in source %s", itemret, name);
-                delete [] name;
-                // skip the source, and set an error
-                check[count] = 0;
-                lastErrorCode = itemret;
-                break;
-            }
-
-            // deleteSyncML(&syncml);
-
-        } while (last == FALSE);
-
-    } // end for (count = 0; count < sourcesNumber; count ++)
-    
-    if (isToExit(check, sourcesNumber)) {
-        // error. no source to sync
-        ret = lastErrorCode;
-        goto finally;
-    }
-    
-    deleteSyncML(&syncml);
-
-    //
-    // If this was the last chunk, we move the state to STATE_PKG3_SENT
-    // At this time "last" is always true. The client is going to send
-    // the 222 package for to get the server modification if at least a source is correct
-    //
-    last = TRUE;
-    currentState = STATE_PKG3_SENT;    
-
-    //
-    // send 222 alert code to retrieve the item from server
-    //    
-    if ((FALSE == isFinalfromServer) && (TRUE == isAtLeastOneSourceCorrect))
-    {
-        status = syncMLBuilder.prepareSyncHdrStatus(NULL, 200);
-        commands->add(*status);
-        deleteStatus(&status); 
-        for (count = 0; count < sourcesNumber; count ++) {
-            if(!check[count])
-                continue;
-            if ((sources[count]->getSyncMode() != SYNC_ONE_WAY_FROM_CLIENT) &&
-                (sources[count]->getSyncMode() != SYNC_REFRESH_FROM_CLIENT))
-            {
-                alert = syncMLBuilder.prepareRequestAlert(*sources[count]);
-                commands->add(*alert);
-                deleteAlert(&alert);
-            }
-        }
-
-        syncml = syncMLBuilder.prepareSyncML(commands, last);
-        msg    = syncMLBuilder.prepareMsg(syncml);        
-
-        LOG.debug(T("Alert to request server changes"));
-        LOG.debug("%s", msg);
-
-        responseMsg = transportAgent->sendMessage(msg);
-        if (responseMsg == NULL) {
-            ret=lastErrorCode;
-            goto finally;
-        }      
-        // increment the msgRef after every send message
-        syncMLBuilder.increaseMsgRef();
-        syncMLBuilder.resetCommandID();
-
-        deleteSyncML(&syncml);
-        safeDelete(&msg);
-
-        syncml = syncMLProcessor.processMsg(responseMsg);
-        safeDelete(&responseMsg);
-        deleteArrayList(&commands);
-
-        if (syncml == NULL) {
-            ret = lastErrorCode;
-            goto finally;
-        }  
-        ret = syncMLProcessor.processSyncHdrStatus(syncml);
-
-        if (isErrorStatus(ret)) {
-            lastErrorCode = ret;
-            bsprintf(lastErrorMsg, T("Server Failure: server returned error code %i"), ret);
-            LOG.error(lastErrorMsg);
-            goto finally;
-        }
-        ret = 0;
-
-        //
-        // Process the items returned from server
-        //
-
-        do {              
-            last = syncml->getSyncBody()->getFinalMsg();
-            ArrayList statusList;
-
-            status = syncMLBuilder.prepareSyncHdrStatus(NULL, 200);
-            commands->add(*status);
-            deleteStatus(&status); 
-
-            /* The server should not send any alert...
-               list = syncMLProcessor.getCommands(syncml->getSyncBody(), ALERT);   
-               status = syncMLBuilder.prepareAlertStatus(*sources[0], list, 200);
-
-               if (status) {
-               commands->add(*status);
-               deleteStatus(&status);    
-               }
-               deleteArrayList(&list);
-             */
-            for (count = 0; count < sourcesNumber; count ++) {
-                if (!check[count])
-                    continue;
-
-                Sync* sync = syncMLProcessor.processSyncResponse(*sources[count], syncml);
-
-                if (sync) {
-     
-                    ArrayList* items = sync->getCommands();
-                    status = syncMLBuilder.prepareSyncStatus(*sources[count], sync);
-                    statusList.add(*status);
-                    deleteStatus(&status);
-
-                    ArrayList* previousStatus = new ArrayList();
-                    for (int i = 0; i < items->size(); i++) {
-                        CommandInfo cmdInfo;
-                        modificationCommand = (ModificationCommand*)(items->get(i));
-                        Meta* meta = modificationCommand->getMeta();
-                        ArrayList* list = modificationCommand->getItems();
-                        
-                        cmdInfo.commandName = modificationCommand->getName();
-                        cmdInfo.cmdRef = modificationCommand->getCmdID()->getCmdID();
-
-                        if (meta) {
-                            cmdInfo.dataType = meta->getType();
-                            cmdInfo.format = meta->getFormat(); 
-                        }
-                        else {
-                            cmdInfo.dataType = 0;
-                            cmdInfo.format = 0;
-                        }
-
-                        for (int j = 0; j < list->size(); j++) {
-                            Item *item = (Item*)list->get(j);
-                            if (item == NULL) {
-                                LOG.error("SyncManager::sync() - unexpected NULL item.");
-                                goto finally;
-                            }
-
-                            //
-                            // set the syncItem element
-                            //
-                            status = processSyncItem(item, cmdInfo);
-
-                            syncMLBuilder.addItemStatus(previousStatus, status);
-                            deleteStatus(&status);            
-                        }
-
-                        if (previousStatus) {
-                            statusList.add(previousStatus);
-                            deleteArrayList(&previousStatus);                    
-                        }
-
-                    }
-                }                               
-
-            } // End for (count = 0; count < sourcesNumber; count ++) 
-
-            commands->add(&statusList);
-
-            if (!last) {
-                deleteSyncML(&syncml);
-                syncml = syncMLBuilder.prepareSyncML(commands, last);
-                msg    = syncMLBuilder.prepareMsg(syncml);        
-
-                LOG.debug(T("Status to the server"));
-                LOG.debug("%s", msg);
-
-                responseMsg = transportAgent->sendMessage(msg);
-                if (responseMsg == NULL) {
-                    ret=lastErrorCode;
-                    goto finally;
-                }      
-                // increment the msgRef after every send message
-                syncMLBuilder.increaseMsgRef();
-                syncMLBuilder.resetCommandID();
-
-                deleteSyncML(&syncml);
-                safeDelete(&msg);
-
-                syncml = syncMLProcessor.processMsg(responseMsg);
-                safeDelete(&responseMsg);
-                deleteArrayList(&commands);
-                if (syncml == NULL) {
-                    ret = lastErrorCode;
-                    goto finally;
-                }  
-                ret = syncMLProcessor.processSyncHdrStatus(syncml);
-
-                if (isErrorStatus(ret)) {
-                    lastErrorCode = ret;
-                    bsprintf(lastErrorMsg, T("Server Failure: server returned error code %i"), ret);
-                    LOG.error(lastErrorMsg);
-                    goto finally;
-                }
-                ret = 0;
-            }        
-        } while (last == FALSE);
-
-    }
-finally:
-
-    if (isAtLeastOneSourceCorrect == TRUE)
-    {
-        safeDelete(&responseMsg);
-        safeDelete(&msg);    
-        deleteSyncML(&syncml);    
-    }
-    else
-    {
-        ret = -1;
-        LOG.debug("sources not available");
-    }
-    return ret;
-}
-
-
-int SyncManager::endSync() {
-
-    BCHAR* mapMsg         = NULL;
-    BCHAR* responseMsg    = NULL;
-    SyncML*  syncml         = NULL;
-    BOOL     last           = TRUE;
-    int ret                 = 0;   
-    Map* map                = NULL;
-    Status* status          = NULL;
-    ArrayList* list         = new ArrayList();
-    unsigned int iterator   = 0;
-    unsigned int toSync     = 0;
-    int i = 0, tot = -1;
-
-    // The real number of source to sync
-    for (count = 0; count < sourcesNumber; count ++) {
-        if (!check[count])
-            continue;
-        if ((sources[count]->getSyncMode()) != SYNC_ONE_WAY_FROM_CLIENT &&
-            (sources[count]->getSyncMode()) != SYNC_REFRESH_FROM_CLIENT )
-
-        toSync++;
-    }
-
-    for (count = 0; count < sourcesNumber; count ++) {
-        if (!check[count])
-            continue;
-
-        if ((sources[count]->getSyncMode()) != SYNC_ONE_WAY_FROM_CLIENT &&
-                (sources[count]->getSyncMode()) != SYNC_REFRESH_FROM_CLIENT )
-        {
-            iterator++;
-            last = FALSE;
-            i = 0;
-            do {
-                tot = -1;
-                if (commands->isEmpty()) {
-                    status = syncMLBuilder.prepareSyncHdrStatus(NULL, 200);
-                    commands->add(*status);
-                    deleteStatus(&status); 
-
-                    /* The server should not send any alert...
-                       list = syncMLProcessor.getCommands(syncml->getSyncBody(), ALERT);   
-                       status = syncMLBuilder.prepareAlertStatus(*sources[0], list, 200);
-                       if (status) {
-                       commands->add(*status);
-                       deleteStatus(&status);    
-                       }
-                       deleteArrayList(&list),
-                     */
-                }
-
-                if (mappings[count]->size() > 0)
-                    map = syncMLBuilder.prepareMapCommand(*sources[count]);
-                else if (iterator != toSync)
-                    break;
-                else
-                    last = TRUE;
-
-                for (i; i < mappings[count]->size(); i++) {                                                      
-                    tot++;
-                    MapItem* mapItem = syncMLBuilder.prepareMapItem((SyncMap*)mappings[count]->get(i));
-                    syncMLBuilder.addMapItem(map, mapItem);
-
-                    deleteMapItem(&mapItem);                        
-
-                    if (tot == ((int)maxModPerMsg - 1)) {
-                        i++;
-                        last = FALSE;
-                        break; 
-
-                    }
-                    last = TRUE;
-                }
-
-                if (i == mappings[count]->size()) {
-                    last = TRUE;
-                }
-
-                if (mappings[count]->size() > 0)
-                    commands->add(*map);
-
-                syncml = syncMLBuilder.prepareSyncML(commands, iterator != toSync ? FALSE : last);
-                mapMsg = syncMLBuilder.prepareMsg(syncml);                   
-
-                LOG.debug(T("Mapping"));
-                LOG.debug("%s", mapMsg);
-
-                responseMsg = transportAgent->sendMessage(mapMsg);
-                if (responseMsg == NULL) {
-                    ret=lastErrorCode;
-                    goto finally;
-                }      
-                // increment the msgRef after every send message
-                syncMLBuilder.increaseMsgRef();
-                syncMLBuilder.resetCommandID();
-
-                deleteSyncML(&syncml);
-                safeDelete(&mapMsg);
-
-                syncml = syncMLProcessor.processMsg(responseMsg);
-                safeDelete(&responseMsg);
-                deleteArrayList(&commands);
-
-                if (syncml == NULL) {
-                    ret = lastErrorCode;
-                    goto finally;
-                }  
-                ret = syncMLProcessor.processSyncHdrStatus(syncml);
-
-                if (isErrorStatus(ret)) {
-                    lastErrorCode = ret;
-                    bsprintf(lastErrorMsg, T("Server Failure: server returned error code %i"), ret);
-                    LOG.error(lastErrorMsg);
-                    goto finally;
-                }
-                ret = 0;
-
-                //
-                // Process the status of mapping
-                //                        
-                ret = syncMLProcessor.processMapResponse(*sources[count], syncml->getSyncBody());
-                deleteSyncML(&syncml);
-                if (ret == -1) {
-                    ret = lastErrorCode;
-                    goto finally;
-                }
-
-            } while(!last);           
-
-            if(allItemsList[count]) {
-                int size = allItemsList[count]->size();
-                for(int i = 0; i < size; i++) {
-                    SyncItem* syncItem = (SyncItem*)((SyncItem*)allItemsList[count]->get(i));
-                    if(syncItem) {
-                        sources[count]->deleteItem(*syncItem);
-                        delete syncItem;
-                    }
-                }
-            }
-
-            int sret = sources[count]->endSync();
-            if (sret) {
-                lastErrorCode = sret;
-            }
-        }        
-    }         
-            
- finally:
-
-    for (count = 0; count < sourcesNumber; count ++) {
-        if (!check[count])
-            continue;
-        commitChanges(*sources[count]);
-    }
-    /*
-	if (mappings) {
-        for (int i=0; i<sourcesNumber; i++) {
-            deleteArrayList(&mappings[i]);
-            if (mappings[i]) { delete mappings[i]; mappings[i] = NULL; } 
-        }
-        delete [] mappings; mappings = NULL;
-    }
-    */
-    config.getAccessConfig().setEndSync((unsigned long)time(NULL));
-    safeDelete(&responseMsg);
-    safeDelete(&mapMsg);
-    BCHAR g[768]; bsprintf(g, "ret: %i, lastErrorCode: %i, lastErrorMessage: %s", ret, lastErrorCode, lastErrorMsg); LOG.debug(g);
-    //
-    // This commitSync is not used because the saving of the configuration
-    // is done into the Sync4jClient.
-    // The operation of save the config is ONLY for the default config (the DMConfig)
-    //
-    //config.save();
-    if (ret){
-        return ret;
-    }
-    else if (lastErrorCode){
-        return lastErrorCode;
-    }
-    else
-        return 0;
-}
-
-BOOL SyncManager::readSyncSourceDefinition(SyncSource& source) {
-    SyncSourceConfig ssc;
-    BCHAR anchor[DIM_ANCHOR];
-    
-    if (config.getSyncSourceConfig(_wcc(source.getName()), ssc) == FALSE) {
-        return FALSE;
-    }
-
-    /* This check could be removed because the sync type is decided later from server.
-       This kind of sync should be read by the settings
-       So, the follow code was used in the previous version of the api.
-
-    // syncMode set only if value has no good value...
-    if (source.getPreferredSyncMode() == NULL ||
-        source.getPreferredSyncMode() < 0     ||
-        source.getPreferredSyncMode() > 210      )  {
-
-        //source.setPreferredSyncMode(syncModeCode(ssc.getSync()));
-    }
-    */
-    source.setPreferredSyncMode(syncModeCode(ssc.getSync()));
-
-    source.setType(ssc.getType());
-    source.setLastSync(ssc.getLast());
-    timestampToAnchor(ssc.getLast(), anchor);
-    source.setLastAnchor(anchor);
-    timestampToAnchor(source.getNextSync(), anchor);
-    source.setNextAnchor(anchor);
-
-    wchar_t *remuri = toWideChar(ssc.getURI());
-    wchar_t *enc = toWideChar(ssc.getEncoding());
-    source.setRemoteURI(remuri);
-    source.setEncoding(enc);
-
-    delete [] remuri; delete [] enc;
-
-    return TRUE;
-}
-
-
-BOOL SyncManager::commitChanges(SyncSource& source) {
-    unsigned int n = config.getSyncSourceConfigsCount();
-    SyncSourceConfig* configs = config.getSyncSourceConfigs();
-
-    const BCHAR* name = _wcc(source.getName());
-    unsigned long next = source.getNextSync();
-
-    BCHAR anchor[DIM_ANCHOR];
-    timestampToAnchor(next, anchor);
-
-    bsprintf(logmsg, DBG_COMMITTING_SOURCE, name, anchor);
-    LOG.debug(logmsg);
-
-    for (unsigned int i = 0; i<n; ++i) {
-        if (bstrcmp(name, configs[i].getName()) == NULL) {
-            configs[i].setLast(next);
-            return TRUE;
-        }
-    }
-
-    return FALSE;
-}
-
-
-int SyncManager::assignSources(SyncSource** sources) {
-    
-    int count = 0, i = 0;
-    
-    if (sources == NULL)
-        goto finally;;    
-
-    while(1) {
-        if (sources[count])
-            count++;
-        else
-            break;
-    }
-    this->sources = new SyncSource*[count + 1];
-    for (i = 0; i < count + 1; i++) {
-        this->sources[i] = sources[i];
-    }
-
-finally:
-
-    return count;
-
-}
-
-/**
- * Buid a new SyncItem, using the data in Item
- *
- * @param item - the item data
- * @param format - the format specified in the command, or NULL
- * @return - the new SyncItem. Must be deleted by the caller
- */
-Status *SyncManager::processSyncItem(Item* item, const CommandInfo &cmdInfo)
-{
-    int code = 0;
-    const BCHAR* itemName;
-
-    Source* s = item->getSource();
-    if (s) { 
-        itemName = s->getLocURI();
-    }
-    else {
-        Target* t = item->getTarget();                
-        itemName = t->getLocURI();
-    }
-
-    // Fill item -------------------------------------------------
-    wchar_t *iname = toWideChar(itemName);
-    SyncItem syncItem(iname);
-    delete [] iname;
-
-    ComplexData *cdata = item->getData();
-    if (cdata) {
-        BCHAR* data = cdata->getData();
-        BCHAR* format = 0;
-
-        //
-        // Retrieving how the content has been encoded
-        // and then processing the content accordingly
-        //
-        if (cmdInfo.format) {
-            format = cmdInfo.format;
-        }
-        else {
-            Meta* m = item->getMeta();
-            if (m) {
-                format = m->getFormat();                            
-            }
-        }
-        if (format) {
-            long size = 0;
-            char *convertedData = processItemContent(data, format, &size);
-            syncItem.setData(convertedData, size);
-            delete [] convertedData;
-        }
-        else {
-            syncItem.setData(data, strlen(data));
-        }
-    }
-    if (cmdInfo.dataType) {
-        wchar_t *dtype = toWideChar(cmdInfo.dataType);
-        syncItem.setDataType(dtype);
-        delete [] dtype;
-    }
-    wchar_t *sparent = toWideChar(item->getSourceParent());
-    syncItem.setSourceParent(sparent);
-    delete [] sparent;
-    wchar_t *tparent = toWideChar(item->getTargetParent());
-    syncItem.setTargetParent(tparent);
-    delete [] tparent;
-
-    syncItem.setModificationTime(sources[count]->getNextSync());
-
-    // Process item ------------------------------------------------------------
-    Status *status = 0;
-    if ( bstrcmp(cmdInfo.commandName, ADD) == 0) {   
-        syncItem.setState(SYNC_STATE_NEW);
-        code = sources[count]->addItem(syncItem);      
-        status = syncMLBuilder.prepareItemStatus(ADD, itemName, cmdInfo.cmdRef, code);
-        // If the add was successful, set the id mapping
-        if (code >= 200 && code <= 299) {
-            BCHAR *key = toMultibyte(syncItem.getKey());
-            SyncMap syncMap(item->getSource()->getLocURI(), key);
-            mappings[count]->add(syncMap);
-            delete [] key;
-        }                    
-    }
-    else if (bstrcmp(cmdInfo.commandName, REPLACE) == 0) {        
-        syncItem.setState(SYNC_STATE_UPDATED);
-        code = sources[count]->updateItem(syncItem);
-        status = syncMLBuilder.prepareItemStatus(REPLACE, itemName, cmdInfo.cmdRef, code);                
-    }
-    else if (bstrcmp(cmdInfo.commandName, DEL) == 0) {
-        syncItem.setState(SYNC_STATE_DELETED);
-        code = sources[count]->deleteItem(syncItem);        
-        status = syncMLBuilder.prepareItemStatus(DEL, itemName, cmdInfo.cmdRef, code);            
-    }                
-    return status;
-}
-
-char* SyncManager::processItemContent(const BCHAR* toConvert,
-                                      const BCHAR* format,
-                                      long *size) {
-    
-    BCHAR* p = NULL;
-    BCHAR* encodings = stringdup(format);
-    BCHAR* encoding = NULL;
-    TransformationInfo info;
-
-    char* c = wc2utf8(toConvert);
-    info.size = strlen(c);
-    info.password = credentialInfo; //(BCHAR*)config.getAccessConfig().getPassword();
-
-    while ((p = strrchr(encodings, CHR(';')))) {
-        encoding = p+1;
-        decodeSyncItemContent(&c, info, encoding);
-        if (lastErrorCode != ERR_NONE) {
-            break;
-        }
-        *p = 0;
-    }
-
-    if (bstrlen(encodings) > 0) {
-        decodeSyncItemContent(&c, info, encodings);
-    }
-    c[info.size] = 0;
-    *size = info.size;
-    
-    if (encodings) { delete [] encodings; encodings = NULL; }
-    return c;
-    
-}
-
-void SyncManager::decodeSyncItemContent(char** c,
-                                        TransformationInfo& info,
-                                        const BCHAR* encoding) {
-    
-    char* decodedData = NULL;
-   
-    resetError();
-   
-    DataTransformer* dt = DataTransformerFactory::getDecoder(encoding);
-
-    if (dt == NULL) {
-        //
-        // lastErrorCode contains already the error
-        //
-        goto exit;
-    }
-    
-    decodedData = dt->transform(*c, info);
-
-    if (lastErrorCode == ERR_UNSPECIFIED) {
-        goto exit;
-    }
-    
-    //
-    // If the transformer has allocated new memory, we set it into the 
-    // sync item, otherwise we just need to adjust the data size.
-    //
-    if (info.newReturnedData) {   
-        /// FIXME!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-        strncpy(*c, decodedData, info.size);
-        if (decodedData) {
-            delete [] decodedData;
-        }
-        
-    } else {               
-       
-    }       
-
-exit:
-
-    if (dt) {
-        delete dt;
-    }
-    
-}
-
-
+/*
+ * Copyright (C) 2003-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include "base/fscapi.h"
+#include "base/Log.h"
+#include "base/debug.h"
+#include "base/util/utils.h"
+#include "base/messages.h"
+#include "http/TransportAgentFactory.h"
+#include "spds/constants.h"
+#include "spds/DataTransformer.h"
+#include "spds/DataTransformerFactory.h"
+#include "spds/SyncManagerConfig.h"
+#include "spds/SyncManager.h"
+#include "spds/SyncMLProcessor.h"
+#include "spds/spdsutils.h"
+#include "syncml/core/TagNames.h"
+#include "syncml/core/ObjectDel.h"
+
+/**
+ * Is the given status code an error status code? Error codes are the ones
+ * outside the range 200-299.
+ *
+ * @param status the status code to check
+ */
+inline static bool isErrorStatus(int status) {
+    return (status) && ((status < 200) || (status > 299));
+}
+
+/**
+ * Return true if the status code is authentication failed
+ *
+ * @param status the status code to check
+ */
+inline static bool isAuthFailed(int status) {
+    return (status) && ((status == 401) || (status == 407));
+}
+
+/**
+ * Return true if there's no more work to do
+ *
+ * @param check - the array of flags to set
+ * @param size - the size of the array
+ */
+static bool isToExit(int* check, int size) {
+    for (int i = 0; i < size; i++) {
+        if (check[i] == 1) 
+            return false; 
+    }
+    return true;
+}
+
+SyncManager::SyncManager(SyncManagerConfig* c) : config(*c) {
+    initialize();
+}
+
+SyncManager::SyncManager(SyncManagerConfig& c) : config(c) {
+    initialize();
+}
+
+void SyncManager::initialize() {
+    AccessConfig& c = config.getAccessConfig();   
+    
+    credentialHandler = CredentialHandler();
+
+    bstrncpy(syncURL, c.getSyncURL(), 511);
+    bstrncpy(deviceId, c.getDeviceId(), 31);
+    
+    credentialHandler.setUsername           (c.getUsername());
+    credentialHandler.setPassword           (c.getPassword());
+    credentialHandler.setClientNonce        (c.getClientNonce());
+    credentialHandler.setClientAuthType     (c.getClientAuthType());
+
+    credentialHandler.setServerID           (c.getServerID());
+    credentialHandler.setServerPWD          (c.getServerPWD());
+    credentialHandler.setServerNonce        (c.getServerNonce());
+    credentialHandler.setServerAuthType     (c.getServerAuthType());
+    credentialHandler.setServerAuthRequired (c.getServerAuthRequired());
+            
+    transportAgent = NULL;
+    
+    currentState = STATE_START;
+
+    commands = new ArrayList();
+    mappings      = NULL;
+    check         = NULL;
+    sourcesNumber = 0;
+    count         = 0;
+
+    maxMsgSize   = c.getMaxMsgSize();
+    maxModPerMsg = 150;  // dafault value
+    readBufferSize = 5000; // default value    
+
+    if (c.getMaxModPerMsg() > 0)
+        maxModPerMsg = c.getMaxModPerMsg();
+    
+    if (c.getReadBufferSize() > 0)
+        readBufferSize = c.getReadBufferSize();
+    
+    memset(userAgent, 0, 128*sizeof(BCHAR));
+    bstrcpy(userAgent, c.getUserAgent());
+    if (bstrlen(userAgent) == 0) {
+        bstrcpy(userAgent, BCHAR_USER_AGENT);
+    }
+                  
+    syncMLBuilder.set(syncURL, deviceId, maxMsgSize);
+    memset(credentialInfo, 0, 256*sizeof(BCHAR));
+}
+
+SyncManager::~SyncManager() {
+    if (transportAgent) {
+        delete transportAgent;
+    }
+    if (commands) {
+        commands->clear(); delete commands; commands = NULL;
+    }
+    if (check) {
+        delete [] check; check = NULL;
+    }
+    if (mappings) {
+        for (int i=0; i<sourcesNumber; i++) {
+            deleteArrayList(&mappings[i]);
+            delete mappings[i];
+        }
+        delete [] mappings; mappings = NULL;
+    }
+    if (sources) {
+        // This deletes only SyncSource array
+        // We DON'T want to release SyncSource objects here!
+        delete [] sources;
+    }
+}
+
+/*
+ * Modification to perform the sync of an array of sync sources.
+ */
+
+int SyncManager::prepareSync(SyncSource** s) {
+    
+    BCHAR* initMsg            = NULL;
+    BCHAR* respURI            = NULL;
+    BCHAR* responseMsg        = NULL;
+    SyncML*  syncml             = NULL;
+    int ret                     = 0;
+    int serverRet               = 0;
+    int count                   = 0;    
+    const BCHAR* requestedAuthType  = NULL;
+    ArrayList* list             = new ArrayList();
+    ArrayList* alerts           = new ArrayList();
+    
+    // for authentication improvments
+    BOOL isServerAuthRequired   = credentialHandler.getServerAuthRequired();
+    int clientAuthRetries       = 1;
+    int serverAuthRetries       = 1;    
+    int authStatusCode          = 200;
+
+    BOOL isClientAuthenticated  = FALSE;
+    BOOL isServerAuthenticated  = FALSE;
+    Chal*   clientChal          = NULL; // The chal of the server to the client
+    Chal*   serverChal          = NULL; // The chal of the client to the server
+    Status* status              = NULL; // The status from the client to the server
+    Cred*   cred                = NULL;
+    Alert*  alert               = NULL;
+    SyncSource** buf            = NULL;
+    const BCHAR *syncURL;
+    
+    syncURL = config.getAccessConfig().getSyncURL(); //sizeof(syncURL));
+
+    URL url(syncURL);
+    Proxy proxy;
+
+    // Set proxy username/password if proxy is used.
+    if (config.getAccessConfig().getUseProxy()) {
+        //BCHAR* proxyHost = config.getAccessConfig().getProxyHost();
+        //int    proxyPort = config.getAccessConfig().getProxyPort();
+        BCHAR* proxyUser = config.getAccessConfig().getProxyUsername();
+        BCHAR* proxyPwd  = config.getAccessConfig().getProxyPassword();
+        proxy.setProxy(NULL, 0, proxyUser, proxyPwd);
+    }
+    
+    const BCHAR* sourceName = NULL;
+    
+    sourcesNumber = assignSources(s);
+    check = new int[sourcesNumber + 1];
+    mappings = new ArrayList*[sourcesNumber + 1];
+    for (count = 0; count < sourcesNumber; count++) {
+        check[count] = 1;
+        mappings[count] = new ArrayList();
+    }
+    check[sourcesNumber] = 0;
+
+    // --- INFO
+    bsprintf(logmsg, MSG_SYNC_URL, syncURL);
+    LOG.info(logmsg);
+    for (count = 0; count < sourcesNumber; count++) {
+        bsprintf(logmsg, MSG_PREPARING_SYNC, _wcc(sources[count]->getName()));
+        LOG.info(logmsg);
+    }
+    // ---
+
+    syncMLBuilder.resetMessageID();
+    syncMLBuilder.resetCommandID();
+    syncMLBuilder.resetMessageID();
+    unsigned long timestamp = (unsigned long)time(NULL);
+    config.getAccessConfig().setBeginSync(timestamp);
+    for (count = 0; count < sourcesNumber; count ++) {
+        if (readSyncSourceDefinition(*sources[count]) == false) {
+            ret = lastErrorCode = ERR_SOURCE_DEFINITION_NOT_FOUND;
+            bsprintf(lastErrorMsg, ERRMSG_SOURCE_DEFINITION_NOT_FOUND,
+                                   _wcc(sources[count]->getName()));
+            LOG.debug(lastErrorMsg);
+            check[count] = 0;
+        }
+    }
+    
+    for (count = 0; count < sourcesNumber; count ++) {
+        if (!check[count])
+            continue;
+
+        if (sources[count]->getSyncMode() == SYNC_NONE) {
+            check[count] = 0;
+        }
+    }
+        
+    if (isToExit(check, sourcesNumber)) {
+        // error. no source to sync
+        ret = lastErrorCode = ERR_NO_SOURCE_TO_SYNC;
+        bsprintf(lastErrorMsg, ERRMSG_NO_SOURCE_TO_SYNC);
+
+        goto finally;
+    }
+          
+    if (isServerAuthRequired == FALSE) 
+        isServerAuthenticated = TRUE;
+
+    do {
+        deleteCred(&cred);
+        deleteAlert(&alert);
+        deleteSyncML(&syncml);
+        deleteArrayList(&alerts);
+
+        bool addressChange = false;
+
+        // credential of the client
+        if (isClientAuthenticated == FALSE) {
+            BCHAR anc[DIM_ANCHOR];
+            timestamp = (unsigned long)time(NULL);
+            for (count = 0; count < sourcesNumber; count ++) {
+                if (!check[count])
+                    continue;
+                sources[count]->setNextSync(timestamp);
+                timestampToAnchor(sources[count]->getNextSync(), anc);
+                sources[count]->setNextAnchor(anc);
+                // Test if this source is for AddressChangeNotification
+                int prefmode = sources[count]->getPreferredSyncMode();
+                if( prefmode == SYNC_ADDR_CHANGE_NOTIFICATION ) {
+                    alert = syncMLBuilder.prepareAddrChangeAlert(*sources[count]);
+                    if(!alert) {
+                        ret = lastErrorCode = 745; // FIXME
+                        goto finally;
+                    }
+                    addressChange = true;   // remember that this sync is for
+                                            // address change notification
+                }
+                else {
+                    alert = syncMLBuilder.prepareInitAlert(*sources[count]);
+                }
+                alerts->add(*alert);
+                deleteAlert(&alert);
+            }
+            cred = credentialHandler.getClientCredential();             
+            bstrcpy(credentialInfo, cred->getAuthentication()->getData(NULL));
+        }
+        // "cred" only contains an encoded strings as username, also
+        // need the original username for LocName
+        syncml = syncMLBuilder.prepareInitObject(credentialHandler.getUsername(), cred, alerts, commands);
+        if (syncml == NULL) {
+            ret = lastErrorCode;
+            goto finally;
+        }  
+       
+        initMsg = syncMLBuilder.prepareMsg(syncml);
+        if (initMsg == NULL) {
+            ret = lastErrorCode;
+            goto finally;
+        }        
+
+        LOG.debug(MSG_INITIALIZATATION_MESSAGE);
+        LOG.debug("%s", initMsg);
+
+        currentState = STATE_PKG1_SENDING;
+
+        if (transportAgent == NULL) {
+            transportAgent = TransportAgentFactory::getTransportAgent(url, proxy);
+            transportAgent->setReadBufferSize(readBufferSize);
+            transportAgent->setUserAgent(userAgent);            
+            
+            if (maxMsgSize > 0) {
+                transportAgent->setMaxMsgSize(maxMsgSize);
+            }
+            
+        } else {
+            transportAgent->setURL(url);
+        }
+        if (lastErrorCode != 0) { // connection: lastErrorCode = 2005: Impossible to establish internet connection
+            ret = lastErrorCode;
+            goto finally;
+        }  
+
+        deleteSyncML(&syncml);         
+        deleteChal(&serverChal);
+        deleteArrayList(&commands);
+        deleteCred(&cred);
+
+        responseMsg = transportAgent->sendMessage(initMsg);
+        // Non-existant or empty reply?
+        // Synthesis server replies with empty message to
+        // a message that it cannot parse.
+        if (responseMsg == NULL || !responseMsg[0]) {
+            if (responseMsg) {
+                delete [] responseMsg;
+                responseMsg = NULL;
+            }
+
+            // This is an error only is it is not an AddressChange
+            if ( addressChange && lastErrorCode == ERR_READING_CONTENT ) {
+                ret = 0;
+            }
+            else {
+                // use last error code if one has been set (might not be the case)
+                ret = lastErrorCode;
+                if (!ret) {
+                    ret = ERR_READING_CONTENT;
+                }
+            }
+            goto finally;
+        }
+
+        // increment the msgRef after every send message
+        syncMLBuilder.increaseMsgRef();
+        syncMLBuilder.resetCommandID();
+
+        syncml = syncMLProcessor.processMsg(responseMsg);
+        safeDelete(&responseMsg);
+        safeDelete(&initMsg);
+        
+        if (syncml == NULL) {
+            ret = lastErrorCode;
+            LOG.error(T("Error processing alert response."));
+            goto finally;
+        }
+        
+        // ret = syncMLProcessor.processInitResponse(*sources[0], syncml, alerts);
+
+        ret = syncMLProcessor.processSyncHdrStatus(syncml);
+
+        if (ret == -1) {
+            ret = lastErrorCode;
+            LOG.error(T("Error processing SyncHdr Status"));
+            goto finally;
+
+        } else if (isErrorStatus(ret) && ! isAuthFailed(ret)) {
+            lastErrorCode = ret;
+            bsprintf(logmsg, T("Error from server %d"), ret);
+            LOG.error(logmsg);
+            goto finally;
+        }
+
+        for (count = 0; count < sourcesNumber; count ++) {
+            if (!check[count])
+                continue;
+
+            int sourceRet = syncMLProcessor.processAlertStatus(*sources[count], syncml, alerts);
+            if (isAuthFailed(ret) && sourceRet == -1) {
+                // Synthesis server does not include SourceRefs if
+                // authentication failed. Remember the authentication
+                // failure in that case, otherwise we'll never get to the getChal() below.
+            } else {
+                ret = sourceRet;
+            }
+            if (ret == -1 || ret == 404 || ret == 415) {
+                lastErrorCode = ret;
+                bsprintf(logmsg, T("AlertStatus from server %d"), ret);
+                LOG.error(logmsg);
+                check[count] = 0;   
+            }
+        } 
+        if (isToExit(check, sourcesNumber)) {
+            // error. no source to sync
+            ret = lastErrorCode;
+            goto finally;
+        }
+        
+        //
+        // Set the uri with session
+        //
+        respURI = syncMLProcessor.getRespURI(syncml->getSyncHdr());
+        if (respURI) {
+            url = respURI;
+            transportAgent->setURL(url);
+        }
+        //
+        // Server Authentication
+        //
+        if (isServerAuthenticated == FALSE) {
+            
+            cred = syncml->getSyncHdr()->getCred();
+            if (cred == NULL) {
+                if (serverAuthRetries == 1) {
+                    // create the serverNonce if needed and set into the CredentialHendler, serverNonce property
+                    serverChal = credentialHandler.getServerChal(isServerAuthenticated); 
+                    authStatusCode = 407;                    
+                    serverAuthRetries++;
+                } else {
+                     ret = -1;
+                     goto finally;
+                }
+
+            } else {                
+                isServerAuthenticated = credentialHandler.performServerAuth(cred);                                
+                if (isServerAuthenticated) {
+                    serverChal   = credentialHandler.getServerChal(isServerAuthenticated); 
+                    authStatusCode = 212;                    
+                }
+                else {
+                    if (bstrcmp(credentialHandler.getServerAuthType(NULL), AUTH_TYPE_MD5) == 0 ||
+                        serverAuthRetries == 1)
+                    {
+                        serverChal   = credentialHandler.getServerChal(isServerAuthenticated);
+                        authStatusCode = 401;
+                        
+                    } else {
+                        ret = -1;   //XXX
+                        LOG.error(T("Server not authenticated"));
+                        goto finally;
+                    }
+                    serverAuthRetries++;
+                }
+            } 
+            cred = NULL; // this cred is only a reference
+        } else  {
+            authStatusCode = 200;            
+        }
+        status = syncMLBuilder.prepareSyncHdrStatus(serverChal, authStatusCode);
+        commands->add(*status);
+        deleteStatus(&status);
+        list = syncMLProcessor.getCommands(syncml->getSyncBody(), ALERT);    
+        for (count = 0; count < sourcesNumber; count ++) {
+            if (!check[count])
+                continue;
+
+            status = syncMLBuilder.prepareAlertStatus(*sources[count], list, authStatusCode);    
+            if (status) {
+                commands->add(*status);
+                deleteStatus(&status);    
+            }
+        }  
+        
+        //
+        // Client Authentication. The auth of the client on the server
+        //
+        clientChal = syncMLProcessor.getChal(syncml->getSyncBody());
+
+        if (isAuthFailed(ret)) {
+            if (clientChal == NULL) {
+                requestedAuthType = credentialHandler.getClientAuthType();
+            } else {
+                requestedAuthType = clientChal->getType(NULL);
+            }
+            if (bstrcmp(credentialHandler.getClientAuthType(NULL),requestedAuthType) != 0 ) {           
+                if (clientChal && bstrcmp(requestedAuthType, AUTH_TYPE_MD5) == 0) {
+                    credentialHandler.setClientNonce(clientChal->getNextNonce()->getValueAsBase64());
+                }                 
+            } else { 
+                if (bstrcmp(requestedAuthType, AUTH_TYPE_MD5) == 0 && clientAuthRetries == 1)  {
+                    credentialHandler.setClientNonce(clientChal->getNextNonce()->getValueAsBase64());
+                 
+                } else {
+                    ret = 401;
+                    LOG.error(T("Client not authenticated"));
+                    goto finally;
+                }                                    
+            }
+            credentialHandler.setClientAuthType(requestedAuthType); 
+            clientAuthRetries++;            
+
+       } else {            
+            if (clientChal && bstrcmp(clientChal->getType(NULL), AUTH_TYPE_MD5) == 0) {                    
+                credentialHandler.setClientNonce(clientChal->getNextNonce()->getValueAsBase64());                
+            }
+            isClientAuthenticated = TRUE;
+            for (count = 0; count < sourcesNumber; count ++) {
+                if (!check[count])
+                    continue;
+                ret = syncMLProcessor.processServerAlert(*sources[count], syncml);
+                if (isErrorStatus(ret)) {
+                    check[count] = 0;   
+                }
+            }  
+       }
+    
+    } while(isClientAuthenticated == FALSE || isServerAuthenticated == FALSE);
+
+    config.getAccessConfig().setClientNonce(credentialHandler.getClientNonce(NULL));
+    config.getAccessConfig().setServerNonce(credentialHandler.getServerNonce(NULL));
+    
+    if (isToExit(check, sourcesNumber)) {
+        // error. no source to sync
+        ret = -1;
+        goto finally;
+    }
+
+    currentState = STATE_PKG1_SENT;
+    
+// ---------------------------------------------------------------------------------------
+finally:
+
+    if (respURI) {
+        delete [] respURI;
+    }
+    if (responseMsg) {
+        safeDelete(&responseMsg);
+    }
+    if (initMsg) {
+        safeDelete(&initMsg);
+    }
+
+    deleteSyncML(&syncml);
+    deleteCred(&cred);
+    deleteAlert(&alert);
+    deleteStatus(&status);
+    deleteChal(&serverChal);    
+    return ret;
+}
+
+//
+// utility function to process any <Sync> command that the server might
+// have included in its <SyncBody>
+//
+// @param syncml       the server response
+// @param statusList   list to which statuses for changes are to be added
+// @return TRUE if a fatal error occurred
+//
+BOOL SyncManager::checkForServerChanges(SyncML* syncml, ArrayList &statusList)
+{
+    BOOL result = FALSE;
+    
+    // Danger, danger: count is a member variable!
+    // It has to be because that's the context for some of
+    // the other methods. Modifying it has to be careful to
+    // restore the initial value before returning because
+    // our caller might use it, too.
+    int oldCount = this->count;
+    
+    for (count = 0; count < sourcesNumber; count ++) {
+        if (!check [count])
+            continue;
+
+        Sync* sync = syncMLProcessor.processSyncResponse(*sources[count], syncml);
+
+        if (sync) {
+            ArrayList* items = sync->getCommands();
+            Status* status = syncMLBuilder.prepareSyncStatus(*sources[count], sync);
+            statusList.add(*status);
+            deleteStatus(&status);
+
+            ArrayList* previousStatus = new ArrayList();
+            for (int i = 0; i < items->size(); i++) {
+                CommandInfo cmdInfo;
+                ModificationCommand* modificationCommand = (ModificationCommand*)(items->get(i));
+                Meta* meta = modificationCommand->getMeta();
+                ArrayList* list = modificationCommand->getItems();
+                        
+                cmdInfo.commandName = modificationCommand->getName();
+                cmdInfo.cmdRef = modificationCommand->getCmdID()->getCmdID();
+
+                if (meta) {
+                    cmdInfo.dataType = meta->getType();
+                    cmdInfo.format = meta->getFormat(); 
+                }
+                else {
+                    cmdInfo.dataType = 0;
+                    cmdInfo.format = 0;
+                }
+
+                for (int j = 0; j < list->size(); j++) {
+                    Item *item = (Item*)list->get(j);
+                    if (item == NULL) {
+                        LOG.error("SyncManager::sync() - unexpected NULL item.");
+                        result = TRUE;
+                        goto finally;
+                    }
+
+                    //
+                    // set the syncItem element
+                    //
+                    status = processSyncItem(item, cmdInfo);
+
+                    syncMLBuilder.addItemStatus(previousStatus, status);
+                    deleteStatus(&status);            
+                }
+
+                if (previousStatus) {
+                    statusList.add(previousStatus);
+                    deleteArrayList(&previousStatus);                    
+                }
+            }
+        }                               
+    } // End for (count = 0; count < sourcesNumber; count ++)
+
+    
+  finally:
+    this->count = oldCount;
+    return result;
+}
+
+
+int SyncManager::sync() {
+
+    BCHAR* msg         = NULL;
+    BCHAR* responseMsg = NULL;
+    Status* status       = NULL;
+    SyncML* syncml       = NULL;
+    SyncItem* syncItem   = NULL;
+    SyncItem* sItem      = NULL;
+    Alert* alert         = NULL;
+    ModificationCommand* modificationCommand = NULL;
+    unsigned int tot     = 0; 
+    unsigned int step    = 0; 
+    unsigned int toSync  = 0;
+    unsigned int iterator= 0;
+    int ret              = 0;  
+    BOOL last            = FALSE;
+    ArrayList* list      = new ArrayList();
+    BOOL isFinalfromServer = FALSE;
+    BOOL isAtLeastOneSourceCorrect = FALSE;
+
+    //for refresh from server sync
+    allItemsList = new ArrayList*[sourcesNumber]; 
+
+    //
+    // If this is the first message, currentState is STATE_PKG1_SENT,
+    // otherwise it is already in STATE_PKG3_SENDING.
+    //
+    if (currentState == STATE_PKG1_SENT) {
+        currentState = STATE_PKG3_SENDING;
+    }
+
+    // The real number of source to sync
+    for (count = 0; count < sourcesNumber; count ++) {
+        allItemsList[count] = NULL;
+        if (!check[count])
+            continue;
+        toSync++;
+    }
+
+    for (count = 0; count < sourcesNumber; count ++) {
+        if (!check[count])
+            continue;
+
+        tot  = 0;
+        step = 0;
+        last = FALSE;        
+        iterator++;
+
+        if ( sources[count]->beginSync() ) {
+            // Error from SyncSource
+            lastErrorCode = ERR_UNSPECIFIED;
+            ret = lastErrorCode;
+            check[count]=0;            
+            continue;
+        }
+        else
+        {
+            isAtLeastOneSourceCorrect = TRUE;
+        }
+
+        do {
+
+            //
+            // Sets the proper encoding for the content of the items.
+            //
+            if (config.isEncryption()) {
+                syncMLBuilder.setEncPassword(credentialInfo);
+                syncMLBuilder.setEncoding(DESB64);
+            } else {
+                // TBD: if we are using vcard/icalendar, we need to 
+                // set the encoding to PLAIN
+                if (bstrcmp(_wcc(sources[count]->getEncoding()), B64_ENCODING) == 0) {
+                    syncMLBuilder.setEncoding(B64);
+                } else {
+                    syncMLBuilder.setEncoding(PLAIN);
+                }   
+
+            }
+
+            if (modificationCommand) {
+                delete modificationCommand; 
+                modificationCommand = NULL;
+            }
+
+            if (commands->isEmpty()) {
+
+                status = syncMLBuilder.prepareSyncHdrStatus(NULL, 200);
+                commands->add(*status);
+                deleteStatus(&status);
+
+                /* The server should not send any alert...
+                   list = syncMLProcessor.getCommands(syncml->getSyncBody(), ALERT);   
+                   status = syncMLBuilder.prepareAlertStatus(*sources[0], list, 200);
+
+                   if (status) {
+                   commands->add(*status);
+                   deleteStatus(&status);    
+                   }
+                   deleteArrayList(&list);
+                 */
+            }
+
+            deleteSyncML(&syncml);
+
+            Sync* sync = syncMLBuilder.prepareSyncCommand(*sources[count]);
+            ArrayList* list = new ArrayList();
+
+            switch (sources[count]->getSyncMode()) {
+                case SYNC_SLOW: 
+                    {   
+                        sItem = NULL;
+                        if (tot == 0) {                    
+                            sItem = sources[count]->getFirstItem();                        
+                            if (sItem) {
+                                syncItem = (SyncItem*)sItem->clone();
+                            }
+                        }
+                        tot = 0;
+                        do {
+                            if (syncItem == NULL) {
+                                sItem = sources[count]->getNextItem();
+                                if (sItem)
+                                    syncItem = (SyncItem*)sItem->clone();                     
+                            }
+                            if (modificationCommand == NULL) {
+                                modificationCommand = 
+                                    syncMLBuilder.prepareModificationCommand(
+                                                            REPLACE_COMMAND_NAME, 
+                                                            syncItem,
+                                                            sources[count]->getType()
+                                                  );
+                            } else {
+                                syncMLBuilder.addItem(modificationCommand,
+                                                      REPLACE_COMMAND_NAME,
+                                                      syncItem, 
+                                                      sources[count]->getType());
+                            }
+
+                            if (syncItem) {
+                                // the item is only the pointer not another instance. to save mem
+                                delete syncItem; syncItem = NULL;
+                            }
+                            else {
+                                last = TRUE;
+                                break;
+                            }
+                            tot++;
+                            sItem = NULL;
+                        } while( tot < maxModPerMsg);                                                    
+                    }
+                    break;
+
+                case SYNC_REFRESH_FROM_SERVER:
+                    last = TRUE; 
+
+                    allItemsList[count] = new ArrayList();
+                    sItem = sources[count]->getFirstItemKey();
+                    if(sItem) {
+                        allItemsList[count]->add((ArrayElement&)*sItem);
+                    }
+                    sItem = sources[count]->getNextItemKey();
+                    while(sItem) {
+                        allItemsList[count]->add((ArrayElement&)*sItem);
+                        sItem = sources[count]->getNextItemKey();	
+                    } 
+                    break;
+
+                case SYNC_ONE_WAY_FROM_SERVER:
+                    last = TRUE;
+                    break;
+
+                case SYNC_REFRESH_FROM_CLIENT:
+                    {   
+                        sItem = NULL;
+                        if (tot == 0) {                    
+                            sItem = sources[count]->getFirstItem();                        
+                            if (sItem) {
+                                syncItem = (SyncItem*)sItem->clone();
+                            }
+                        }
+                        tot = 0;
+                        do {
+                            if (syncItem == NULL) {
+                                sItem = sources[count]->getNextItem();
+                                if (sItem)
+                                    syncItem = (SyncItem*)sItem->clone();                     
+                            }
+                            if (modificationCommand == NULL) {
+                                modificationCommand = syncMLBuilder.prepareModificationCommand(REPLACE_COMMAND_NAME, 
+                                        syncItem, sources[count]->getType());
+                            } else {
+                                syncMLBuilder.addItem(modificationCommand, REPLACE_COMMAND_NAME, syncItem, 
+                                        sources[count]->getType());
+                            }
+
+                            if (syncItem) {
+                                delete syncItem; syncItem = NULL;// the item is only the pointer not another instance. to save mem                        
+                            }
+                            else {
+                                last = TRUE;
+                                break;
+                            }
+                            tot++;
+                            sItem = NULL;
+                        } while( tot < maxModPerMsg);                                                    
+                    }
+                    break;
+
+                default:
+                    {    
+                        tot = 0;
+                        //
+                        // New Item
+                        //
+                        sItem = NULL;
+                        if (step == 0) {
+                            sItem = sources[count]->getFirstNewItem(); 
+                            if (sItem)
+                                syncItem = (SyncItem*)sItem->clone();
+                            step++;
+                            if (syncItem == NULL)
+                                step++;                        
+                        }
+                        if (step == 1) {                                                          
+                            do {
+                                if (syncItem == NULL) {
+                                    sItem = sources[count]->getNextNewItem();
+                                    if (sItem)   
+                                        syncItem = (SyncItem*)sItem->clone(); 
+                                }
+                                if (modificationCommand == NULL) {
+                                    modificationCommand = syncMLBuilder.prepareModificationCommand(ADD_COMMAND_NAME, 
+                                            syncItem, sources[count]->getType());
+                                } else {
+                                    syncMLBuilder.addItem(modificationCommand, ADD_COMMAND_NAME, 
+                                            syncItem, sources[count]->getType());
+                                }
+
+                                if (syncItem) {
+                                    delete syncItem; syncItem = NULL;
+                                }
+                                else {
+                                    step++;
+                                    break;
+                                }
+                                tot++;
+                                sItem = NULL;
+                            } while( tot < maxModPerMsg);
+                        }
+
+                        //
+                        // Updated Item
+                        //
+                        if (step == 2) {
+
+                            if (modificationCommand) {
+                                list->add(*modificationCommand);
+                                delete modificationCommand; 
+                                modificationCommand = NULL;
+                            }
+
+                            sItem = sources[count]->getFirstUpdatedItem();
+                            if (sItem)
+                                syncItem = (SyncItem*)sItem->clone();
+
+                            step++;
+                            if (syncItem == NULL)
+                                step++;    
+                        }
+                        if (step == 3) {
+                            do {
+                                if (syncItem == NULL) {
+                                    sItem = sources[count]->getNextUpdatedItem();
+                                    if (sItem)
+                                        syncItem = (SyncItem*)sItem->clone();
+
+                                }
+                                if (modificationCommand == NULL) {
+                                    modificationCommand = syncMLBuilder.prepareModificationCommand(REPLACE_COMMAND_NAME, 
+                                            syncItem, sources[count]->getType());
+                                } else {
+                                    syncMLBuilder.addItem(modificationCommand, REPLACE_COMMAND_NAME, 
+                                            syncItem, sources[count]->getType());
+                                }
+
+                                if (syncItem) {                            
+                                    delete syncItem; syncItem = NULL;
+                                }
+                                else {
+                                    step++;
+                                    break;
+                                }
+                                tot++;
+                                sItem = NULL;
+                            } while( tot < maxModPerMsg);                                                      
+                        } 
+
+                        //
+                        // Deleted Item
+                        //
+                        if (step == 4) {
+
+                            if (modificationCommand) {
+                                list->add(*modificationCommand);
+                                delete modificationCommand; 
+                                modificationCommand = NULL;
+                            }
+
+                            sItem = sources[count]->getFirstDeletedItem();
+
+                            if (sItem)
+                                syncItem = (SyncItem*)sItem->clone();
+
+                            step++;
+                            if (syncItem == NULL)
+                                step++;    
+                        }
+                        if (step == 5) {
+                            do {
+                                if (syncItem == NULL) {
+                                    sItem = sources[count]->getNextDeletedItem(); 
+                                    if (sItem)
+                                        syncItem = (SyncItem*)sItem->clone();                        
+                                }
+                                if (modificationCommand == NULL) {
+                                    modificationCommand = syncMLBuilder.prepareModificationCommand(DELETE_COMMAND_NAME, 
+                                            syncItem, sources[count]->getType());
+                                } else {
+                                    syncMLBuilder.addItem(modificationCommand, DELETE_COMMAND_NAME, 
+                                            syncItem, sources[count]->getType());
+                                }
+
+                                if (syncItem) {                            
+                                    delete syncItem; syncItem = NULL;
+                                }
+                                else {
+                                    step++;
+                                    break;
+                                }
+                                tot++;
+                                sItem = NULL;
+                            } while( tot < maxModPerMsg);           
+                        }
+                        if (step == 6 && syncItem == NULL)
+                            last = TRUE;
+
+                        break;
+                    }
+            }
+
+            if (modificationCommand) {
+                list->add(*modificationCommand);
+                delete modificationCommand; 
+                modificationCommand = NULL;
+            }                     
+            sync->setCommands(list);
+            delete list;
+            commands->add(*sync);
+            delete sync;
+
+            //
+            // Check if all the sources were synced.
+            // If not the prepareSync doesn't use the <final/> tag 
+            //
+            syncml = syncMLBuilder.prepareSyncML(commands, (iterator != toSync ? FALSE : last));
+            msg    = syncMLBuilder.prepareMsg(syncml);       
+
+            deleteSyncML(&syncml);
+            deleteArrayList(&commands);
+
+            if (msg == NULL) {
+                ret = lastErrorCode;
+                goto finally;
+            }
+
+            // Synchronization message:
+
+            LOG.debug(MSG_MODIFICATION_MESSAGE);
+            LOG.debug("%s", msg);
+
+            responseMsg = transportAgent->sendMessage(msg);
+            if (responseMsg == NULL) {
+                ret=lastErrorCode;
+                goto finally;
+            }
+            // increment the msgRef after every send message
+            syncMLBuilder.increaseMsgRef();
+            syncMLBuilder.resetCommandID();
+
+            syncml = syncMLProcessor.processMsg(responseMsg);
+            safeDelete(&responseMsg);
+            safeDelete(&msg);
+
+            if (syncml == NULL) {
+                ret = lastErrorCode;
+                goto finally;
+            }               
+
+            isFinalfromServer = syncml->isLastMessage();
+            ret = syncMLProcessor.processSyncHdrStatus(syncml);
+
+            if (isErrorStatus(ret)) {
+                lastErrorCode = ret;
+                bsprintf(lastErrorMsg, T("Server Failure: server returned error code %i"), ret);
+                LOG.error(lastErrorMsg);
+                goto finally;
+
+            }
+            ret = 0;
+            // 
+            // Process the status of the item sent by client. It invokes the 
+            // source method 
+            //
+            int itemret = syncMLProcessor.processItemStatus(*sources[count], syncml->getSyncBody());
+            if(itemret){
+                char *name = toMultibyte(sources[count]->getName());
+                LOG.error("Error #%d in source %s", itemret, name);
+                delete [] name;
+                // skip the source, and set an error
+                check[count] = 0;
+                lastErrorCode = itemret;
+                break;
+            }
+
+            // The server might have included a <Sync> command without waiting
+            // for a 222 alert. If it hasn't, then nothing is done here.
+            ArrayList statusList;
+            if (checkForServerChanges(syncml, statusList)) {
+                goto finally;
+            }
+            if (statusList.size()) {
+                Status* status = syncMLBuilder.prepareSyncHdrStatus(NULL, 200);
+                commands->add(*status);
+                deleteStatus(&status);
+                commands->add(&statusList);
+            }
+
+            // deleteSyncML(&syncml);
+
+        } while (last == FALSE);
+
+    } // end for (count = 0; count < sourcesNumber; count ++)
+    
+    if (isToExit(check, sourcesNumber)) {
+        // error. no source to sync
+        ret = lastErrorCode;
+        goto finally;
+    }
+    
+    deleteSyncML(&syncml);
+
+    //
+    // If this was the last chunk, we move the state to STATE_PKG3_SENT
+    // At this time "last" is always true. The client is going to send
+    // the 222 package for to get the server modification if at least a source is correct
+    //
+    last = TRUE;
+    currentState = STATE_PKG3_SENT;    
+
+    //
+    // send 222 alert code to retrieve the item from server
+    //    
+    if ((FALSE == isFinalfromServer) && (TRUE == isAtLeastOneSourceCorrect))
+    {
+        status = syncMLBuilder.prepareSyncHdrStatus(NULL, 200);
+        commands->add(*status);
+        deleteStatus(&status); 
+        for (count = 0; count < sourcesNumber; count ++) {
+            if(!check[count])
+                continue;
+            if ((sources[count]->getSyncMode() != SYNC_ONE_WAY_FROM_CLIENT) &&
+                (sources[count]->getSyncMode() != SYNC_REFRESH_FROM_CLIENT))
+            {
+                alert = syncMLBuilder.prepareRequestAlert(*sources[count]);
+                commands->add(*alert);
+                deleteAlert(&alert);
+            }
+        }
+
+        syncml = syncMLBuilder.prepareSyncML(commands, last);
+        msg    = syncMLBuilder.prepareMsg(syncml);        
+
+        LOG.debug(T("Alert to request server changes"));
+        LOG.debug("%s", msg);
+
+        responseMsg = transportAgent->sendMessage(msg);
+        if (responseMsg == NULL) {
+            ret=lastErrorCode;
+            goto finally;
+        }      
+        // increment the msgRef after every send message
+        syncMLBuilder.increaseMsgRef();
+        syncMLBuilder.resetCommandID();
+
+        deleteSyncML(&syncml);
+        safeDelete(&msg);
+
+        syncml = syncMLProcessor.processMsg(responseMsg);
+        safeDelete(&responseMsg);
+        deleteArrayList(&commands);
+
+        if (syncml == NULL) {
+            ret = lastErrorCode;
+            goto finally;
+        }  
+        ret = syncMLProcessor.processSyncHdrStatus(syncml);
+
+        if (isErrorStatus(ret)) {
+            lastErrorCode = ret;
+            bsprintf(lastErrorMsg, T("Server Failure: server returned error code %i"), ret);
+            LOG.error(lastErrorMsg);
+            goto finally;
+        }
+        ret = 0;
+
+        //
+        // Process the items returned from server
+        //
+
+        do {              
+            last = syncml->getSyncBody()->getFinalMsg();
+            ArrayList statusList;
+
+            status = syncMLBuilder.prepareSyncHdrStatus(NULL, 200);
+            commands->add(*status);
+            deleteStatus(&status); 
+
+            if (checkForServerChanges(syncml, statusList)) {
+                goto finally;
+            }
+
+            commands->add(&statusList);
+
+            if (!last) {
+                deleteSyncML(&syncml);
+                syncml = syncMLBuilder.prepareSyncML(commands, last);
+                msg    = syncMLBuilder.prepareMsg(syncml);        
+
+                LOG.debug(T("Status to the server"));
+                LOG.debug("%s", msg);
+
+                responseMsg = transportAgent->sendMessage(msg);
+                if (responseMsg == NULL) {
+                    ret=lastErrorCode;
+                    goto finally;
+                }      
+                // increment the msgRef after every send message
+                syncMLBuilder.increaseMsgRef();
+                syncMLBuilder.resetCommandID();
+
+                deleteSyncML(&syncml);
+                safeDelete(&msg);
+
+                syncml = syncMLProcessor.processMsg(responseMsg);
+                safeDelete(&responseMsg);
+                deleteArrayList(&commands);
+                if (syncml == NULL) {
+                    ret = lastErrorCode;
+                    goto finally;
+                }  
+                ret = syncMLProcessor.processSyncHdrStatus(syncml);
+
+                if (isErrorStatus(ret)) {
+                    lastErrorCode = ret;
+                    bsprintf(lastErrorMsg, T("Server Failure: server returned error code %i"), ret);
+                    LOG.error(lastErrorMsg);
+                    goto finally;
+                }
+                ret = 0;
+            }        
+        } while (last == FALSE);
+
+    }
+finally:
+
+    if (isAtLeastOneSourceCorrect == TRUE)
+    {
+        safeDelete(&responseMsg);
+        safeDelete(&msg);    
+        deleteSyncML(&syncml);    
+    }
+    else
+    {
+        ret = -1;
+        LOG.debug("sources not available");
+    }
+    return ret;
+}
+
+
+int SyncManager::endSync() {
+
+    BCHAR* mapMsg         = NULL;
+    BCHAR* responseMsg    = NULL;
+    SyncML*  syncml         = NULL;
+    BOOL     last           = TRUE;
+    int ret                 = 0;   
+    Map* map                = NULL;
+    Status* status          = NULL;
+    ArrayList* list         = new ArrayList();
+    unsigned int iterator   = 0;
+    unsigned int toSync     = 0;
+    int i = 0, tot = -1;
+
+    // The real number of source to sync
+    for (count = 0; count < sourcesNumber; count ++) {
+        if (!check[count])
+            continue;
+        if ((sources[count]->getSyncMode()) != SYNC_ONE_WAY_FROM_CLIENT &&
+            (sources[count]->getSyncMode()) != SYNC_REFRESH_FROM_CLIENT )
+
+        toSync++;
+    }
+
+    for (count = 0; count < sourcesNumber; count ++) {
+        if (!check[count])
+            continue;
+
+        if ((sources[count]->getSyncMode()) != SYNC_ONE_WAY_FROM_CLIENT &&
+                (sources[count]->getSyncMode()) != SYNC_REFRESH_FROM_CLIENT )
+        {
+            iterator++;
+            last = FALSE;
+            i = 0;
+            do {
+                tot = -1;
+                if (commands->isEmpty()) {
+                    status = syncMLBuilder.prepareSyncHdrStatus(NULL, 200);
+                    commands->add(*status);
+                    deleteStatus(&status); 
+
+                    /* The server should not send any alert...
+                       list = syncMLProcessor.getCommands(syncml->getSyncBody(), ALERT);   
+                       status = syncMLBuilder.prepareAlertStatus(*sources[0], list, 200);
+                       if (status) {
+                       commands->add(*status);
+                       deleteStatus(&status);    
+                       }
+                       deleteArrayList(&list),
+                     */
+                }
+
+                if (mappings[count]->size() > 0)
+                    map = syncMLBuilder.prepareMapCommand(*sources[count]);
+                else if (iterator != toSync)
+                    break;
+                else
+                    last = TRUE;
+
+                for (i; i < mappings[count]->size(); i++) {                                                      
+                    tot++;
+                    MapItem* mapItem = syncMLBuilder.prepareMapItem((SyncMap*)mappings[count]->get(i));
+                    syncMLBuilder.addMapItem(map, mapItem);
+
+                    deleteMapItem(&mapItem);                        
+
+                    if (tot == ((int)maxModPerMsg - 1)) {
+                        i++;
+                        last = FALSE;
+                        break; 
+
+                    }
+                    last = TRUE;
+                }
+
+                if (i == mappings[count]->size()) {
+                    last = TRUE;
+                }
+
+                if (mappings[count]->size() > 0)
+                    commands->add(*map);
+
+                syncml = syncMLBuilder.prepareSyncML(commands, iterator != toSync ? FALSE : last);
+                mapMsg = syncMLBuilder.prepareMsg(syncml);                   
+
+                LOG.debug(T("Mapping"));
+                LOG.debug("%s", mapMsg);
+
+                responseMsg = transportAgent->sendMessage(mapMsg);
+                if (responseMsg == NULL) {
+                    ret=lastErrorCode;
+                    goto finally;
+                }      
+                // increment the msgRef after every send message
+                syncMLBuilder.increaseMsgRef();
+                syncMLBuilder.resetCommandID();
+
+                deleteSyncML(&syncml);
+                safeDelete(&mapMsg);
+
+                syncml = syncMLProcessor.processMsg(responseMsg);
+                safeDelete(&responseMsg);
+                deleteArrayList(&commands);
+
+                if (syncml == NULL) {
+                    ret = lastErrorCode;
+                    goto finally;
+                }  
+                ret = syncMLProcessor.processSyncHdrStatus(syncml);
+
+                if (isErrorStatus(ret)) {
+                    lastErrorCode = ret;
+                    bsprintf(lastErrorMsg, T("Server Failure: server returned error code %i"), ret);
+                    LOG.error(lastErrorMsg);
+                    goto finally;
+                }
+                ret = 0;
+
+                //
+                // Process the status of mapping
+                //                        
+                ret = syncMLProcessor.processMapResponse(*sources[count], syncml->getSyncBody());
+                deleteSyncML(&syncml);
+                if (ret == -1) {
+                    ret = lastErrorCode;
+                    goto finally;
+                }
+
+            } while(!last);           
+
+            if(allItemsList[count]) {
+                int size = allItemsList[count]->size();
+                for(int i = 0; i < size; i++) {
+                    SyncItem* syncItem = (SyncItem*)((SyncItem*)allItemsList[count]->get(i));
+                    if(syncItem) {
+                        sources[count]->deleteItem(*syncItem);
+                        delete syncItem;
+                    }
+                }
+            }
+
+            int sret = sources[count]->endSync();
+            if (sret) {
+                lastErrorCode = sret;
+            }
+        }        
+    }         
+            
+ finally:
+
+    for (count = 0; count < sourcesNumber; count ++) {
+        if (!check[count])
+            continue;
+        commitChanges(*sources[count]);
+    }
+    /*
+	if (mappings) {
+        for (int i=0; i<sourcesNumber; i++) {
+            deleteArrayList(&mappings[i]);
+            if (mappings[i]) { delete mappings[i]; mappings[i] = NULL; } 
+        }
+        delete [] mappings; mappings = NULL;
+    }
+    */
+    config.getAccessConfig().setEndSync((unsigned long)time(NULL));
+    safeDelete(&responseMsg);
+    safeDelete(&mapMsg);
+    BCHAR g[768]; bsprintf(g, "ret: %i, lastErrorCode: %i, lastErrorMessage: %s", ret, lastErrorCode, lastErrorMsg); LOG.debug(g);
+    //
+    // This commitSync is not used because the saving of the configuration
+    // is done into the Sync4jClient.
+    // The operation of save the config is ONLY for the default config (the DMConfig)
+    //
+    //config.save();
+    if (ret){
+        return ret;
+    }
+    else if (lastErrorCode){
+        return lastErrorCode;
+    }
+    else
+        return 0;
+}
+
+BOOL SyncManager::readSyncSourceDefinition(SyncSource& source) {
+    SyncSourceConfig ssc;
+    BCHAR anchor[DIM_ANCHOR];
+    
+    if (config.getSyncSourceConfig(_wcc(source.getName()), ssc) == FALSE) {
+        return FALSE;
+    }
+
+    /* This check could be removed because the sync type is decided later from server.
+       This kind of sync should be read by the settings
+       So, the follow code was used in the previous version of the api.
+
+    // syncMode set only if value has no good value...
+    if (source.getPreferredSyncMode() == NULL ||
+        source.getPreferredSyncMode() < 0     ||
+        source.getPreferredSyncMode() > 210      )  {
+
+        //source.setPreferredSyncMode(syncModeCode(ssc.getSync()));
+    }
+    */
+    source.setPreferredSyncMode(syncModeCode(ssc.getSync()));
+
+    source.setType(ssc.getType());
+    source.setLastSync(ssc.getLast());
+    timestampToAnchor(ssc.getLast(), anchor);
+    source.setLastAnchor(anchor);
+    timestampToAnchor(source.getNextSync(), anchor);
+    source.setNextAnchor(anchor);
+
+    wchar_t *remuri = toWideChar(ssc.getURI());
+    wchar_t *enc = toWideChar(ssc.getEncoding());
+    source.setRemoteURI(remuri);
+    source.setEncoding(enc);
+
+    delete [] remuri; delete [] enc;
+
+    return TRUE;
+}
+
+
+BOOL SyncManager::commitChanges(SyncSource& source) {
+    unsigned int n = config.getSyncSourceConfigsCount();
+    SyncSourceConfig* configs = config.getSyncSourceConfigs();
+
+    const BCHAR* name = _wcc(source.getName());
+    unsigned long next = source.getNextSync();
+
+    BCHAR anchor[DIM_ANCHOR];
+    timestampToAnchor(next, anchor);
+
+    bsprintf(logmsg, DBG_COMMITTING_SOURCE, name, anchor);
+    LOG.debug(logmsg);
+
+    for (unsigned int i = 0; i<n; ++i) {
+        if (bstrcmp(name, configs[i].getName()) == NULL) {
+            configs[i].setLast(next);
+            return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+
+int SyncManager::assignSources(SyncSource** sources) {
+    
+    int count = 0, i = 0;
+    
+    if (sources == NULL)
+        goto finally;;    
+
+    while(1) {
+        if (sources[count])
+            count++;
+        else
+            break;
+    }
+    this->sources = new SyncSource*[count + 1];
+    for (i = 0; i < count + 1; i++) {
+        this->sources[i] = sources[i];
+    }
+
+finally:
+
+    return count;
+
+}
+
+/**
+ * Buid a new SyncItem, using the data in Item
+ *
+ * @param item - the item data
+ * @param format - the format specified in the command, or NULL
+ * @return - the new SyncItem. Must be deleted by the caller
+ */
+Status *SyncManager::processSyncItem(Item* item, const CommandInfo &cmdInfo)
+{
+    int code = 0;
+    const BCHAR* itemName;
+
+    Source* s = item->getSource();
+    if (s) { 
+        itemName = s->getLocURI();
+    }
+    else {
+        Target* t = item->getTarget();                
+        itemName = t->getLocURI();
+    }
+
+    // Fill item -------------------------------------------------
+    wchar_t *iname = toWideChar(itemName);
+    SyncItem syncItem(iname);
+    delete [] iname;
+
+    ComplexData *cdata = item->getData();
+    if (cdata) {
+        BCHAR* data = cdata->getData();
+        BCHAR* format = 0;
+
+        //
+        // Retrieving how the content has been encoded
+        // and then processing the content accordingly
+        //
+        if (cmdInfo.format) {
+            format = cmdInfo.format;
+        }
+        else {
+            Meta* m = item->getMeta();
+            if (m) {
+                format = m->getFormat();                            
+            }
+        }
+        if (format) {
+            long size = 0;
+            char *convertedData = processItemContent(data, format, &size);
+            syncItem.setData(convertedData, size);
+            delete [] convertedData;
+        }
+        else {
+            syncItem.setData(data, strlen(data));
+        }
+    }
+    if (cmdInfo.dataType) {
+        wchar_t *dtype = toWideChar(cmdInfo.dataType);
+        syncItem.setDataType(dtype);
+        delete [] dtype;
+    }
+    wchar_t *sparent = toWideChar(item->getSourceParent());
+    syncItem.setSourceParent(sparent);
+    delete [] sparent;
+    wchar_t *tparent = toWideChar(item->getTargetParent());
+    syncItem.setTargetParent(tparent);
+    delete [] tparent;
+
+    syncItem.setModificationTime(sources[count]->getNextSync());
+
+    // Process item ------------------------------------------------------------
+    Status *status = 0;
+    if ( bstrcmp(cmdInfo.commandName, ADD) == 0) {   
+        syncItem.setState(SYNC_STATE_NEW);
+        code = sources[count]->addItem(syncItem);      
+        status = syncMLBuilder.prepareItemStatus(ADD, itemName, cmdInfo.cmdRef, code);
+        // If the add was successful, set the id mapping
+        if (code >= 200 && code <= 299) {
+            BCHAR *key = toMultibyte(syncItem.getKey());
+            SyncMap syncMap(item->getSource()->getLocURI(), key);
+            mappings[count]->add(syncMap);
+            delete [] key;
+        }                    
+    }
+    else if (bstrcmp(cmdInfo.commandName, REPLACE) == 0) {        
+        syncItem.setState(SYNC_STATE_UPDATED);
+        code = sources[count]->updateItem(syncItem);
+        status = syncMLBuilder.prepareItemStatus(REPLACE, itemName, cmdInfo.cmdRef, code);                
+    }
+    else if (bstrcmp(cmdInfo.commandName, DEL) == 0) {
+        syncItem.setState(SYNC_STATE_DELETED);
+        code = sources[count]->deleteItem(syncItem);        
+        status = syncMLBuilder.prepareItemStatus(DEL, itemName, cmdInfo.cmdRef, code);            
+    }                
+    return status;
+}
+
+char* SyncManager::processItemContent(const BCHAR* toConvert,
+                                      const BCHAR* format,
+                                      long *size) {
+    
+    BCHAR* p = NULL;
+    BCHAR* encodings = stringdup(format);
+    BCHAR* encoding = NULL;
+    TransformationInfo info;
+
+    char* c = wc2utf8(toConvert);
+    info.size = strlen(c);
+    info.password = credentialInfo; //(BCHAR*)config.getAccessConfig().getPassword();
+
+    while ((p = strrchr(encodings, CHR(';')))) {
+        encoding = p+1;
+        decodeSyncItemContent(&c, info, encoding);
+        if (lastErrorCode != ERR_NONE) {
+            break;
+        }
+        *p = 0;
+    }
+
+    if (bstrlen(encodings) > 0) {
+        decodeSyncItemContent(&c, info, encodings);
+    }
+    c[info.size] = 0;
+    *size = info.size;
+    
+    if (encodings) { delete [] encodings; encodings = NULL; }
+    return c;
+    
+}
+
+void SyncManager::decodeSyncItemContent(char** c,
+                                        TransformationInfo& info,
+                                        const BCHAR* encoding) {
+    
+    char* decodedData = NULL;
+   
+    resetError();
+   
+    DataTransformer* dt = DataTransformerFactory::getDecoder(encoding);
+
+    if (dt == NULL) {
+        //
+        // lastErrorCode contains already the error
+        //
+        goto exit;
+    }
+    
+    decodedData = dt->transform(*c, info);
+
+    if (lastErrorCode == ERR_UNSPECIFIED) {
+        goto exit;
+    }
+    
+    //
+    // If the transformer has allocated new memory, we set it into the 
+    // sync item, otherwise we just need to adjust the data size.
+    //
+    if (info.newReturnedData) {   
+        /// FIXME!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+        strncpy(*c, decodedData, info.size);
+        if (decodedData) {
+            delete [] decodedData;
+        }
+        
+    } else {               
+       
+    }       
+
+exit:
+
+    if (dt) {
+        delete dt;
+    }
+    
+}
+
+
--- native/src/c++/common/spds/SyncMLBuilder.cpp~synthesis
+++ native/src/c++/common/spds/SyncMLBuilder.cpp
@@ -480,7 +480,7 @@
     return alert;
 }
 
-SyncHdr* SyncMLBuilder::prepareSyncHdr(Cred* cred) {
+SyncHdr* SyncMLBuilder::prepareSyncHdr(Cred* cred, const BCHAR *username) {
 
     ++msgID;
 
@@ -489,7 +489,7 @@
     SessionID* sessID    = new SessionID(ltow(sessionID));
     BCHAR*   messageID = itow(msgID);
     Target*    tar       = new Target(target);
-    Source*    sou       = new Source(device);       
+    Source*    sou       = new Source(device, username);       
     Meta* meta           = NULL;
 
     if (maxMsgSize > 0) {
@@ -513,9 +513,9 @@
     return syncHdr;    
 }
 
-SyncML* SyncMLBuilder::prepareInitObject(Cred* cred, ArrayList* alerts, ArrayList* commands) {
+SyncML* SyncMLBuilder::prepareInitObject(const BCHAR *username, Cred* cred, ArrayList* alerts, ArrayList* commands) {
 
-    SyncHdr* syncHdr     = prepareSyncHdr(cred);
+    SyncHdr* syncHdr     = prepareSyncHdr(cred, username);
     SyncML*  syncml      = NULL;               
     ArrayList* list      = new ArrayList();
     SyncBody* syncBody   = NULL;
--- native/src/c++/common/spds/SyncMLProcessor.cpp~synthesis
+++ native/src/c++/common/spds/SyncMLProcessor.cpp
@@ -1,492 +1,510 @@
-/*
- * Copyright (C) 2003-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <stdlib.h>
-
-#include "base/Log.h"  // TBR
-#include "base/util/ArrayList.h"
-#include "base/util/utils.h"
-#include "spds/constants.h"
-#include "spds/SyncMLProcessor.h"
-#include "spds/spdsutils.h"
-
-
-/*
- * This class is responsible for the processing of the incoming messages.
- */
-/*
- * Constructor
- */
-SyncMLProcessor::SyncMLProcessor() : XMLProcessor() {
-}
-
-SyncML* SyncMLProcessor::processMsg(BCHAR* msg) {
-    SyncML* syncml      = Parser::getSyncML(msg);
-    return syncml;
-}
-
-
-int SyncMLProcessor::processSyncHdrStatus(SyncML* syncml) {
-    return getStatusCode(syncml->getSyncBody(), NULL, SYNC_HDR);
-}
-
-int SyncMLProcessor::processAlertStatus(SyncSource& source, SyncML* syncml, ArrayList* alerts) {
-
-    int ret = -1;
-    ArrayList* list     = new ArrayList();
-    BCHAR* name = NULL;
-    Status* s     = NULL;
-    Data* data    = NULL;
-    SourceRef* sourceRef    = NULL;
-
-    if (alerts->size()) {
-        list = syncml->getSyncBody()->getCommands();
-        
-        for (int i = 0; i < list->size(); i++) {
-            // is returned the pointer to the element not a new element
-            name = ((AbstractCommand*)(list->get(i)))->getName();
-            if (name && bstrcmp(name, STATUS) == 0) {
-                s = (Status*)list->get(i);
-                if (bstrcmp(s->getCmd(), ALERT) == 0) { 
-                    sourceRef = (SourceRef*)(s->getSourceRef()->get(0));
-
-                    if (bstrcmp(_wcc(source.getName()),
-                                sourceRef->getValue()) == 0) {
-                        ret = getAlertStatusCode(s, _wcc(source.getName()));
-                        break;
-                    }
-                }
-            }
-        }
-    }
-
-    return ret;
-
-}
-
-
-/*
- * Processes the initialization response. Returns 0 in case of success, an
- * error code in case of error.
- *
- * @param msg the response from the server
- */
-int SyncMLProcessor::processServerAlert(SyncSource& source, SyncML* syncml) {
-    
-    int ret             = -1;
-    int iterator        = 0;
-    AbstractCommand* a  = NULL;   
-    Item* item          = NULL;
-    ArrayList* list     = new ArrayList();
-    BOOL found          = FALSE;    
-
-    ret = 0;
-    do {
-        a = getCommand(syncml->getSyncBody(), ALERT, iterator);                   
-        if (a == NULL) {
-            lastErrorCode = ERR_REPRESENTATION;
-            bsprintf(lastErrorMsg, T("SyncBody/Alert not found!"));
-            goto finally;
-        }
-        Alert* alert = (Alert*)a;
-        Item* item = NULL;
-        ArrayList* itemList = alert->getItems();
-
-        for (int i = 0; i < itemList->size(); i++) {
-            item = (Item*)getArrayElement(itemList, i);
-            const BCHAR *locURI = ((Target*)item->getTarget())->getLocURI();
-            if (bstrcmp( locURI, _wcc(source.getName()) ) == 0) {                   
-                if (alert->getData() == NULL) {
-                    lastErrorCode = ERR_REPRESENTATION;
-                    bsprintf(lastErrorMsg, T("SyncBody/Alert/Data not found!"));
-                    goto finally;
-                }
-
-            source.setSyncMode((SyncMode)alert->getData());
-            ret = 0;
-            found = TRUE;
-            break;        
-            }
-        }                        
-        iterator++;
-        if (found)
-            break;
-
-    } while(a);
-   
-finally:
-    
-    return ret;
-}
-
-int SyncMLProcessor::processItemStatus(SyncSource& source, SyncBody* syncBody) {
-    
-    ArrayList* items = NULL;
-    Item* item       = NULL;
-    SourceRef* sourceRef = NULL;
-    Status* s = NULL;
-    BCHAR* name = NULL;
-    Data* data = NULL;
-    int ret = 0;
-
-    ArrayList* list = getCommands(syncBody, STATUS);
-
-    for (int i = 0; i < list->size(); i++) {
-        s = (Status*)list->get(i);
-        name = s->getCmd();    
-        data = s->getData();
-        if (bstrcmp(name, SYNC) == 0){
-            char *srcname = toMultibyte(source.getName());
-            int alertStatus = getAlertStatusCode(s, srcname);
-            
-            delete [] srcname;
-            
-            if(alertStatus < 0 || alertStatus >=300){
-                if ((ret = alertStatus) < 0)
-                    LOG.error("processItemStatus: status not found in SYNC");
-                else
-                    LOG.error("processItemStatus: server sent status %d in SYNC", alertStatus);                
-                break;            
-            }
-            
-        }         
-        
-        else if (bstrcmp(name, ADD) == 0 ||
-            bstrcmp(name, REPLACE) == 0 ||
-            bstrcmp(name, DEL) == 0) {
-
-            int k;
-
-            items = s->getItems();
-            long val = bstrtol(data->getData() , NULL, 10);
-            for (k = 0; k < items->size(); k++) {
-                item = (Item*)items->get(k);
-                if (item) {
-                    wchar_t *uri = toWideChar(item->getSource()->getLocURI());
-                    source.setItemStatus(uri, val);
-                    delete [] uri;
-                }
-            }
-            items = s->getSourceRef();
-            for (k = 0; k < items->size(); k++) {
-                sourceRef = (SourceRef*)items->get(k);
-                if (sourceRef) {
-                    WCHAR *srcref = toWideChar(sourceRef->getValue());
-                    source.setItemStatus(srcref, val);
-                    delete [] srcref;
-                }
-            }
-        }
-    }
-
-    deleteArrayList(&list);    
-    return ret;
-}
-
-/*
- * Processes the initialization response. Returns 0 in case of success, an
- * error code in case of error.
- *
- * @param msg the response from the server
- */
-
-Sync* SyncMLProcessor::processSyncResponse(SyncSource& source, SyncML* syncml) {    
-    
-    int iterator = 0, ret = 0;    
-    
-    AbstractCommand* a  = NULL;           
-    Sync* sync          = NULL;
-
-    ret = getStatusCode(syncml->getSyncBody(), &source, SYNC_HDR);
-    if ((ret < 200) || (ret > 299)) {
-        goto finally;
-    }
-
-    while((a = getCommand(syncml->getSyncBody(), SYNC, iterator)) != NULL){  
-        sync = (Sync*)a;
-        const BCHAR *locuri = ((Target*)(sync->getTarget()))->getLocURI();
-        if (bstrcmp(locuri, _wcc(source.getName())) == 0) {                   
-            break;
-        }  
-        sync = NULL;
-        iterator++;
-    }
-        
-finally:
-    
-    return sync;
- 
-}
-
-/*
- * Processes the map message response. Returns 0 in case of success, an
- * error code in case of error.
- * It feeds the given source with the server side modifications
- *
- * @param source the source
- * @param msg the response from the server
- */
-int SyncMLProcessor::processMapResponse(SyncSource& source, SyncBody* syncBody) {
-    int ret = -1;
-
-    //
-    // for now it is always ok
-    //
-    //
-    // First of all check the status for the SyncHead
-    //
-    // TBD
-    ret = getStatusCode(syncBody, &source, SYNC_HDR);
-    if ((ret < 200) || (ret >299)) {
-        goto finally;
-    }
-
-    ret = 0;
-
-finally:
-
-    return ret;
-}
-
-/*
- * Returns the SyncHeader/RespURI element of the given message. If the element is not
- * found it returns NULL. The returned respURI is allocated with the new operator
- * and must be discarded with delete by the caller.
- *
- * @param SyncHdr - the SyncHdr object - NOT NULL
- */
-BCHAR* SyncMLProcessor::getRespURI(SyncHdr* syncHdr) {
-    
-    BCHAR* respURI = NULL;
-    
-    if (syncHdr == NULL) {
-        goto finally;
-    }
-    respURI = stringdup(syncHdr->getRespURI(NULL));
-    
-finally:
-
-    return respURI;
-}
-
-
-Chal* SyncMLProcessor::getChal(SyncBody* syncBody) {    
-    
-    ArrayList* list = syncBody->getCommands();
-    BCHAR* name = NULL;
-    Status* s     = NULL;
-    Chal* chal    = NULL;
-
-    for (int i = 0; i < list->size(); i++) {
-        name = ((AbstractCommand*)(list->get(i)))->getName();    // is returned the pointer to the element not a new element
-        if (name && bstrcmp(name, STATUS) == 0) {
-            s = (Status*)list->get(i);
-            if (bstrcmp(s->getCmd(NULL), SYNC_HDR) == 0) {
-                if (bstrcmp(s->getCmdRef(NULL), T("0")) != 0) {
-
-                    bsprintf(lastErrorMsg, T("Status/CmdRef either not found or not referring to SyncHeader!"));
-                    lastErrorCode = ERR_REPRESENTATION;
-                    goto finally;
-                }      
-                
-                chal = s->getChal();
-                if (chal == NULL) {
-                    //
-                    // no chal found
-                    //
-                    goto finally;
-                }                
-                break;
-            }                                 
-        }    
-    }    
-   
-finally:
-   
-    return chal;
-} 
-
-/*
-* Return an array list of commands of the given command name. It return an ArrayList that have to be 
-* discarded by the caller
-*/
-ArrayList* SyncMLProcessor::getCommands(SyncBody* syncBody, BCHAR* commandName) {
-        
-    ArrayList* ret = new ArrayList();
-    AbstractCommand* a = NULL;
-
-    for (int i = 0; i < syncBody->getCommands()->size(); i++) {    
-        a = getCommand(syncBody, commandName, i);
-        if (a) 
-            ret->add(*a);
-    }
-    return ret;
-}
-
-// ------------------------------------------------------------- Private methods
-
-/*
-* To get a generic array element. It returns the <index> arrayElement it founds.
-* 0-based.
-*/
-ArrayElement* SyncMLProcessor::getArrayElement(ArrayList* list, int index) {
-    
-    if (list == NULL)
-        return NULL;
-
-    ArrayElement* a     = NULL;    
-    int count           = 0;
-    for (int i = 0; i < list->size(); i++) {               
-            if (count == index) {
-                a = list->get(i);
-                break;
-            }        
-            ++ count;         
-    }   
-    return a;
-}
-
-/*
-* Return the index number of occurrence of this command. If doesn't exists return NULL;
-* The first command has number 0.
-*/
-AbstractCommand* SyncMLProcessor::getCommand(SyncBody* syncBody, BCHAR* commandName, int index) {
-      
-    int iterator = 0, found = 0;
-    ArrayList* list     = syncBody->getCommands();
-    int l = list->size();
-    AbstractCommand* a  = NULL;
-    BCHAR* name = NULL;
-    do {
-        a = (AbstractCommand*)getArrayElement(list, iterator);
-        if (a) {
-            name = a->getName();    // is returned the pointer to the element not a new element
-            if (name && bstrcmp(name, commandName) == 0) {                       
-                if (found == index)
-                    break;
-                else
-                    found++;
-            }    
-        }        
-        ++iterator;
-    } while(a);
-    
-    return a;
-}
-
-
-int SyncMLProcessor::getStatusCode(SyncBody* syncBody, SyncSource* source, BCHAR* commandName) {    
-    int ret = -1;
-    
-    ArrayList* list = syncBody->getCommands();
-    BCHAR* name = NULL;
-    Status* s     = NULL;
-    Data* data    = NULL;
-
-    for (int i = 0; i < list->size(); i++) {
-        name = ((AbstractCommand*)(list->get(i)))->getName();    // is returned the pointer to the element not a new element
-        if (name && bstrcmp(name, STATUS) == 0) {
-            s = (Status*)list->get(i);
-            if (bstrcmp(s->getCmd(), commandName) == 0) {
-                if (bstrcmp(commandName, SYNC_HDR) == 0) {
-                    ret = getSyncHeaderStatusCode(s);
-                } else if (bstrcmp(commandName, ALERT) == 0) {
-                    ret = getAlertStatusCode(s, (BCHAR*)source->getName());
-                }    
-                break;
-            }                                 
-        }    
-    }    
-   
-    return ret;
-
-}
-
-/*
- * Returns the status code for the SyncHeader command included
- * in the message sent by the client.
- *
- * @param syncBody - the SyncBody content
- */
-int SyncMLProcessor::getSyncHeaderStatusCode(Status* s) {
-    
-    int ret = -1;    
-    Data* data    = NULL;
-   
-    if (s == NULL) 
-        goto finally;
-
-    if (bstrcmp(s->getCmdRef(NULL), T("0")) != 0) {
-
-        bsprintf(lastErrorMsg, T("Status/CmdRef either not found or not referring to SyncHeader!"));
-        lastErrorCode = ERR_REPRESENTATION;
-        goto finally;
-    }                
-    
-    data = s->getData();
-    if (data->getData(NULL) == NULL) {
-         //
-        // It should not happen
-        //
-        bsprintf(lastErrorMsg, T("Status/Data not found!"));
-        lastErrorCode = ERR_REPRESENTATION;
-        goto finally;
-    }
-    ret = bstrtol(data->getData() , NULL, 10);    
-                                
-
-finally:
-   
-    return ret;
-} 
-
-/*
- * Returns the status code for the Alert relative to the given source.
- *
- * @param syncBody - the SyncBody content
- * @param sourceName - the name of the source
- */
-
- int SyncMLProcessor::getAlertStatusCode(Status* s, const BCHAR* sourceName) {
-    int ret = -1;
-    
-    Data* data    = NULL;
-    ArrayList* sourceRefs = new ArrayList();
-    
-    if (s == NULL)
-        goto finally;
-
-    sourceRefs = s->getSourceRef();
-    if (bstrcmp(((SourceRef*)(sourceRefs->get(0)))->getValue(), sourceName) == 0) {                    
-        data = s->getData();
-        if (data->getData(NULL) == NULL) {
-            //
-            // It should not happen
-            //
-            bsprintf(lastErrorMsg, T("Status/Data not found!"));
-            lastErrorCode = ERR_REPRESENTATION;
-            goto finally;
-        }
-        ret = bstrtol(data->getData(), NULL, 10);        
-    }                
-
-finally:
-    return ret;
-
-}
-
+/*
+ * Copyright (C) 2003-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdlib.h>
+
+#include "base/Log.h"  // TBR
+#include "base/util/ArrayList.h"
+#include "base/util/utils.h"
+#include "spds/constants.h"
+#include "spds/SyncMLProcessor.h"
+#include "spds/spdsutils.h"
+
+
+/*
+ * This class is responsible for the processing of the incoming messages.
+ */
+/*
+ * Constructor
+ */
+SyncMLProcessor::SyncMLProcessor() : XMLProcessor() {
+}
+
+SyncML* SyncMLProcessor::processMsg(BCHAR* msg) {
+    SyncML* syncml      = Parser::getSyncML(msg);
+    return syncml;
+}
+
+
+int SyncMLProcessor::processSyncHdrStatus(SyncML* syncml) {
+    return getStatusCode(syncml->getSyncBody(), NULL, SYNC_HDR);
+}
+
+int SyncMLProcessor::processAlertStatus(SyncSource& source, SyncML* syncml, ArrayList* alerts) {
+
+    int ret = -1;
+    ArrayList* list     = new ArrayList();
+    BCHAR* name = NULL;
+    Status* s     = NULL;
+    Data* data    = NULL;
+    SourceRef* sourceRef    = NULL;
+
+    if (alerts->size()) {
+        list = syncml->getSyncBody()->getCommands();
+        
+        for (int i = 0; i < list->size(); i++) {
+            // is returned the pointer to the element not a new element
+            name = ((AbstractCommand*)(list->get(i)))->getName();
+            if (name && bstrcmp(name, STATUS) == 0) {
+                s = (Status*)list->get(i);
+                if (bstrcmp(s->getCmd(), ALERT) == 0) { 
+                    sourceRef = (SourceRef*)(s->getSourceRef()->get(0));
+
+                    if (sourceRef) {
+                        if (bstrcmp(_wcc(source.getName()),
+                                    sourceRef->getValue()) == 0) {
+                            ret = getAlertStatusCode(s, _wcc(source.getName()));
+                            break;
+                        }
+                    } else {
+                        // Server did not include <SourceRef>, which
+                        // is a violation of the standard for commands
+                        // which were sent with <SourceRef>. Happens
+                        // with Synthesis server if authentication
+                        // failed, in which case we can simply ignore
+                        // it.
+                    }
+                }
+            }
+        }
+    }
+
+    return ret;
+
+}
+
+
+/*
+ * Processes the initialization response. Returns 0 in case of success, an
+ * error code in case of error.
+ *
+ * @param msg the response from the server
+ */
+int SyncMLProcessor::processServerAlert(SyncSource& source, SyncML* syncml) {
+    
+    int ret             = -1;
+    int iterator        = 0;
+    AbstractCommand* a  = NULL;   
+    Item* item          = NULL;
+    ArrayList* list     = new ArrayList();
+    BOOL found          = FALSE;    
+
+    ret = 0;
+    do {
+        a = getCommand(syncml->getSyncBody(), ALERT, iterator);                   
+        if (a == NULL) {
+            // This happens with the Synthesis server's reply:
+            // instead of sending SyncBody/Alert we get SyncBody/Put
+            // with device infos and a SyncBody/Get requesting our own
+            // device infos. Ignoring the request is not correct, but
+            // allows synchronization to proceed and complete eventually
+            // without any further errors. For that to work we must not
+            // set lastErrorCode here, as it will be checked at the end of
+            // the sync.
+            //
+            // lastErrorCode = ERR_REPRESENTATION;
+            // bsprintf(lastErrorMsg, T("SyncBody/Alert not found!"));
+            goto finally;
+        }
+        Alert* alert = (Alert*)a;
+        Item* item = NULL;
+        ArrayList* itemList = alert->getItems();
+
+        for (int i = 0; i < itemList->size(); i++) {
+            item = (Item*)getArrayElement(itemList, i);
+            const BCHAR *locURI = ((Target*)item->getTarget())->getLocURI();
+            if (bstrcmp( locURI, _wcc(source.getName()) ) == 0) {                   
+                if (alert->getData() == NULL) {
+                    lastErrorCode = ERR_REPRESENTATION;
+                    bsprintf(lastErrorMsg, T("SyncBody/Alert/Data not found!"));
+                    goto finally;
+                }
+
+            source.setSyncMode((SyncMode)alert->getData());
+            ret = 0;
+            found = TRUE;
+            break;        
+            }
+        }                        
+        iterator++;
+        if (found)
+            break;
+
+    } while(a);
+   
+finally:
+    
+    return ret;
+}
+
+int SyncMLProcessor::processItemStatus(SyncSource& source, SyncBody* syncBody) {
+    
+    ArrayList* items = NULL;
+    Item* item       = NULL;
+    SourceRef* sourceRef = NULL;
+    Status* s = NULL;
+    BCHAR* name = NULL;
+    Data* data = NULL;
+    int ret = 0;
+
+    ArrayList* list = getCommands(syncBody, STATUS);
+
+    for (int i = 0; i < list->size(); i++) {
+        s = (Status*)list->get(i);
+        name = s->getCmd();    
+        data = s->getData();
+        if (bstrcmp(name, SYNC) == 0){
+            char *srcname = toMultibyte(source.getName());
+            int alertStatus = getAlertStatusCode(s, srcname);
+            
+            delete [] srcname;
+            
+            if(alertStatus < 0 || alertStatus >=300){
+                if ((ret = alertStatus) < 0)
+                    LOG.error("processItemStatus: status not found in SYNC");
+                else
+                    LOG.error("processItemStatus: server sent status %d in SYNC", alertStatus);                
+                break;            
+            }
+            
+        }         
+        
+        else if (bstrcmp(name, ADD) == 0 ||
+            bstrcmp(name, REPLACE) == 0 ||
+            bstrcmp(name, DEL) == 0) {
+
+            int k;
+
+            items = s->getItems();
+            long val = bstrtol(data->getData() , NULL, 10);
+            for (k = 0; k < items->size(); k++) {
+                item = (Item*)items->get(k);
+                if (item) {
+                    wchar_t *uri = toWideChar(item->getSource()->getLocURI());
+                    source.setItemStatus(uri, val);
+                    delete [] uri;
+                }
+            }
+            items = s->getSourceRef();
+            for (k = 0; k < items->size(); k++) {
+                sourceRef = (SourceRef*)items->get(k);
+                if (sourceRef) {
+                    WCHAR *srcref = toWideChar(sourceRef->getValue());
+                    source.setItemStatus(srcref, val);
+                    delete [] srcref;
+                }
+            }
+        }
+    }
+
+    deleteArrayList(&list);    
+    return ret;
+}
+
+/*
+ * Processes the initialization response. Returns 0 in case of success, an
+ * error code in case of error.
+ *
+ * @param msg the response from the server
+ */
+
+Sync* SyncMLProcessor::processSyncResponse(SyncSource& source, SyncML* syncml) {    
+    
+    int iterator = 0, ret = 0;    
+    
+    AbstractCommand* a  = NULL;           
+    Sync* sync          = NULL;
+
+    ret = getStatusCode(syncml->getSyncBody(), &source, SYNC_HDR);
+    if ((ret < 200) || (ret > 299)) {
+        goto finally;
+    }
+
+    while((a = getCommand(syncml->getSyncBody(), SYNC, iterator)) != NULL){  
+        sync = (Sync*)a;
+        const BCHAR *locuri = ((Target*)(sync->getTarget()))->getLocURI();
+        if (bstrcmp(locuri, _wcc(source.getName())) == 0) {                   
+            break;
+        }  
+        sync = NULL;
+        iterator++;
+    }
+        
+finally:
+    
+    return sync;
+ 
+}
+
+/*
+ * Processes the map message response. Returns 0 in case of success, an
+ * error code in case of error.
+ * It feeds the given source with the server side modifications
+ *
+ * @param source the source
+ * @param msg the response from the server
+ */
+int SyncMLProcessor::processMapResponse(SyncSource& source, SyncBody* syncBody) {
+    int ret = -1;
+
+    //
+    // for now it is always ok
+    //
+    //
+    // First of all check the status for the SyncHead
+    //
+    // TBD
+    ret = getStatusCode(syncBody, &source, SYNC_HDR);
+    if ((ret < 200) || (ret >299)) {
+        goto finally;
+    }
+
+    ret = 0;
+
+finally:
+
+    return ret;
+}
+
+/*
+ * Returns the SyncHeader/RespURI element of the given message. If the element is not
+ * found it returns NULL. The returned respURI is allocated with the new operator
+ * and must be discarded with delete by the caller.
+ *
+ * @param SyncHdr - the SyncHdr object - NOT NULL
+ */
+BCHAR* SyncMLProcessor::getRespURI(SyncHdr* syncHdr) {
+    
+    BCHAR* respURI = NULL;
+    
+    if (syncHdr == NULL) {
+        goto finally;
+    }
+    respURI = stringdup(syncHdr->getRespURI(NULL));
+    
+finally:
+
+    return respURI;
+}
+
+
+Chal* SyncMLProcessor::getChal(SyncBody* syncBody) {    
+    
+    ArrayList* list = syncBody->getCommands();
+    BCHAR* name = NULL;
+    Status* s     = NULL;
+    Chal* chal    = NULL;
+
+    for (int i = 0; i < list->size(); i++) {
+        name = ((AbstractCommand*)(list->get(i)))->getName();    // is returned the pointer to the element not a new element
+        if (name && bstrcmp(name, STATUS) == 0) {
+            s = (Status*)list->get(i);
+            if (bstrcmp(s->getCmd(NULL), SYNC_HDR) == 0) {
+                if (bstrcmp(s->getCmdRef(NULL), T("0")) != 0) {
+
+                    bsprintf(lastErrorMsg, T("Status/CmdRef either not found or not referring to SyncHeader!"));
+                    lastErrorCode = ERR_REPRESENTATION;
+                    goto finally;
+                }      
+                
+                chal = s->getChal();
+                if (chal == NULL) {
+                    //
+                    // no chal found
+                    //
+                    goto finally;
+                }                
+                break;
+            }                                 
+        }    
+    }    
+   
+finally:
+   
+    return chal;
+} 
+
+/*
+* Return an array list of commands of the given command name. It return an ArrayList that have to be 
+* discarded by the caller
+*/
+ArrayList* SyncMLProcessor::getCommands(SyncBody* syncBody, BCHAR* commandName) {
+        
+    ArrayList* ret = new ArrayList();
+    AbstractCommand* a = NULL;
+
+    for (int i = 0; i < syncBody->getCommands()->size(); i++) {    
+        a = getCommand(syncBody, commandName, i);
+        if (a) 
+            ret->add(*a);
+    }
+    return ret;
+}
+
+// ------------------------------------------------------------- Private methods
+
+/*
+* To get a generic array element. It returns the <index> arrayElement it founds.
+* 0-based.
+*/
+ArrayElement* SyncMLProcessor::getArrayElement(ArrayList* list, int index) {
+    
+    if (list == NULL)
+        return NULL;
+
+    ArrayElement* a     = NULL;    
+    int count           = 0;
+    for (int i = 0; i < list->size(); i++) {               
+            if (count == index) {
+                a = list->get(i);
+                break;
+            }        
+            ++ count;         
+    }   
+    return a;
+}
+
+/*
+* Return the index number of occurrence of this command. If doesn't exists return NULL;
+* The first command has number 0.
+*/
+AbstractCommand* SyncMLProcessor::getCommand(SyncBody* syncBody, BCHAR* commandName, int index) {
+      
+    int iterator = 0, found = 0;
+    ArrayList* list     = syncBody->getCommands();
+    int l = list->size();
+    AbstractCommand* a  = NULL;
+    BCHAR* name = NULL;
+    do {
+        a = (AbstractCommand*)getArrayElement(list, iterator);
+        if (a) {
+            name = a->getName();    // is returned the pointer to the element not a new element
+            if (name && bstrcmp(name, commandName) == 0) {                       
+                if (found == index)
+                    break;
+                else
+                    found++;
+            }    
+        }        
+        ++iterator;
+    } while(a);
+    
+    return a;
+}
+
+
+int SyncMLProcessor::getStatusCode(SyncBody* syncBody, SyncSource* source, BCHAR* commandName) {    
+    int ret = -1;
+    
+    ArrayList* list = syncBody->getCommands();
+    BCHAR* name = NULL;
+    Status* s     = NULL;
+    Data* data    = NULL;
+
+    for (int i = 0; i < list->size(); i++) {
+        name = ((AbstractCommand*)(list->get(i)))->getName();    // is returned the pointer to the element not a new element
+        if (name && bstrcmp(name, STATUS) == 0) {
+            s = (Status*)list->get(i);
+            if (bstrcmp(s->getCmd(), commandName) == 0) {
+                if (bstrcmp(commandName, SYNC_HDR) == 0) {
+                    ret = getSyncHeaderStatusCode(s);
+                } else if (bstrcmp(commandName, ALERT) == 0) {
+                    ret = getAlertStatusCode(s, (BCHAR*)source->getName());
+                }    
+                break;
+            }                                 
+        }    
+    }    
+   
+    return ret;
+
+}
+
+/*
+ * Returns the status code for the SyncHeader command included
+ * in the message sent by the client.
+ *
+ * @param syncBody - the SyncBody content
+ */
+int SyncMLProcessor::getSyncHeaderStatusCode(Status* s) {
+    
+    int ret = -1;    
+    Data* data    = NULL;
+   
+    if (s == NULL) 
+        goto finally;
+
+    if (bstrcmp(s->getCmdRef(NULL), T("0")) != 0) {
+
+        bsprintf(lastErrorMsg, T("Status/CmdRef either not found or not referring to SyncHeader!"));
+        lastErrorCode = ERR_REPRESENTATION;
+        goto finally;
+    }                
+    
+    data = s->getData();
+    if (data->getData(NULL) == NULL) {
+         //
+        // It should not happen
+        //
+        bsprintf(lastErrorMsg, T("Status/Data not found!"));
+        lastErrorCode = ERR_REPRESENTATION;
+        goto finally;
+    }
+    ret = bstrtol(data->getData() , NULL, 10);    
+                                
+
+finally:
+   
+    return ret;
+} 
+
+/*
+ * Returns the status code for the Alert relative to the given source.
+ *
+ * @param syncBody - the SyncBody content
+ * @param sourceName - the name of the source
+ */
+
+ int SyncMLProcessor::getAlertStatusCode(Status* s, const BCHAR* sourceName) {
+    int ret = -1;
+    
+    Data* data    = NULL;
+    ArrayList* sourceRefs = new ArrayList();
+    
+    if (s == NULL)
+        goto finally;
+
+    sourceRefs = s->getSourceRef();
+    if (bstrcmp(((SourceRef*)(sourceRefs->get(0)))->getValue(), sourceName) == 0) {                    
+        data = s->getData();
+        if (data->getData(NULL) == NULL) {
+            //
+            // It should not happen
+            //
+            bsprintf(lastErrorMsg, T("Status/Data not found!"));
+            lastErrorCode = ERR_REPRESENTATION;
+            goto finally;
+        }
+        ret = bstrtol(data->getData(), NULL, 10);        
+    }                
+
+finally:
+    return ret;
+
+}
+
--- native/src/c++/common/syncml/formatter/Formatter.cpp~synthesis
+++ native/src/c++/common/syncml/formatter/Formatter.cpp
@@ -1,2400 +1,2403 @@
-/*
- * Copyright (C) 2003-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
- 
-#include "syncml/formatter/Formatter.h"
-#include "base/Log.h"
-
-#define EMPTY_VALUE  T("__EMPTY__")
-
-/*
-* Returns a StringBuffer giving the tag and the value as long. To use for generic simple value
-*/
-StringBuffer* Formatter::getValue(BCHAR* tagName, long value) {    
-    if (!value)
-        return NULL;
-
-    BCHAR* t1 = new BCHAR[bstrlen(tagName) + 3]; // <  >  0
-    BCHAR* t2 = new BCHAR[bstrlen(tagName) + 5]; // </ > \n 0
-    bsprintf(t1, T("<%s>"), tagName);
-    bsprintf(t2, T("</%s>\n"), tagName);
-
-    StringBuffer* s = new StringBuffer();
-    s->append(t1);       
-    s->append(value);
-    s->append(t2);    
-    safeDel(&t1);
-    safeDel(&t2);
-
-    return s;    
-}
-
-/*
-* Returns a StringBuffer giving the tag and the value as BOOL. If true return only the tag, nothing otherwise
-*/
-StringBuffer* Formatter::getValue(BCHAR* tagName, BOOL value) {    
-    if (!value)
-        return NULL;
-
-    BCHAR* t1 = new BCHAR[bstrlen(tagName) + 3]; // <  >  0
-    BCHAR* t2 = new BCHAR[bstrlen(tagName) + 5]; // </ > \n 0
-    bsprintf(t1, T("<%s>"), tagName);
-    bsprintf(t2, T("</%s>\n"), tagName);
-
-    StringBuffer* s = new StringBuffer();
-    s->append(t1);        
-    s->append(t2);    
-    safeDel(&t1);
-    safeDel(&t2);
-
-    return s;    
-}
-
-
-/*
-* Returns a StringBuffer giving the tag and the value as wchar. To use for generic simple value
-*/
-StringBuffer* Formatter::getValue(BCHAR* tagName, const BCHAR* value) {    
-    return getValue(tagName, (BCHAR*) value);
-}
-
-
-/*
-* Returns a StringBuffer giving the tag and the value as wchar.
-* To use for generic simple value
-*/
-StringBuffer* Formatter::getValue(BCHAR* tagName, BCHAR* value) {    
-    if (!value)
-        return NULL;
-
-    BCHAR* t1 = new BCHAR[bstrlen(tagName) + 3]; // <  >  0
-    BCHAR* t2 = new BCHAR[bstrlen(tagName) + 5]; // </ > \n 0
-    bsprintf(t1, T("<%s>"), tagName);
-    bsprintf(t2, T("</%s>\n"), tagName);
-
-    StringBuffer* s = new StringBuffer(t1);
-
-    if (bstrcmp(value, EMPTY_VALUE) != 0)
-        s->append(value);
-
-    s->append(t2);
-    
-    safeDel(&t1);
-    safeDel(&t2);
-
-    return s;    
-}
-
-/*
-* Returns a StringBuffer giving the tag and the value as StringBuffer. To use to include other stuffs
-*/
-StringBuffer* Formatter::getValue(BCHAR* tagName, StringBuffer* value) {    
-    if (!value)
-        return NULL;
-
-    BCHAR* t1 = new BCHAR[bstrlen(tagName) + 3]; // <  >  0
-    BCHAR* t2 = new BCHAR[bstrlen(tagName) + 5]; // </ > \n 0
-    bsprintf(t1, T("<%s>"), tagName);
-    bsprintf(t2, T("</%s>\n"), tagName);
-
-    StringBuffer* s = new StringBuffer();
-    s->append(t1);
-    s->append(value);
-    s->append(t2);
-    
-    safeDel(&t1);
-    safeDel(&t2);
-
-    return s;    
-}
-
-
-StringBuffer* Formatter::getSyncML(SyncML* syncML) {
-        
-    StringBuffer*   sBody = NULL;
-    StringBuffer*   sHdr  = NULL;
-    StringBuffer*   sML   = NULL; 
-    
-    if (syncML == NULL) {
-        return NULL;
-    }
-
-    sHdr  = getSyncHdr (syncML->getSyncHdr ());
-    sBody = getSyncBody(syncML->getSyncBody());
-    
-    sML = new StringBuffer(T("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"));
-    sML->append(T("<SyncML>\n"));    
-    sML->append(sHdr);
-    sML->append(sBody);
-    sML->append(T("</SyncML>"));
-    
-    deleteAllStringBuffer(2,&sHdr, &sBody);
-
-    return sML;     
-}
-
-StringBuffer* Formatter::getSyncHdr(SyncHdr* syncHdr) {
-    
-    StringBuffer*   ret = NULL;    
-    StringBuffer*   s = NULL;    
-           
-    StringBuffer* sessionID = NULL;
-    StringBuffer* verDTD    = NULL;
-    StringBuffer* verProto  = NULL;
-    StringBuffer* source    = NULL;
-    StringBuffer* target    = NULL;    
-    StringBuffer* cred      = NULL;
-    StringBuffer* msgID     = NULL;
-    StringBuffer* respURI   = NULL;
-    StringBuffer* meta      = NULL;
-    
-    sessionID = getSessionID(syncHdr->getSessionID());
-    verDTD    = getVerDTD   (syncHdr->getVerDTD());
-    verProto  = getVerProto (syncHdr->getVerProto());
-    source    = getSource   (syncHdr->getSource());
-    target    = getTarget   (syncHdr->getTarget());    
-    cred      = getCred     (syncHdr->getCred());
-    msgID     = getValue    (MSG_ID,  syncHdr->getMsgID(NULL));
-    respURI   = getValue    (RESP_URI, syncHdr->getRespURI(NULL));
-    meta      = getMeta     (syncHdr->getMeta());
-    
-    if (NotZeroStringBufferLenght(9, sessionID, verDTD, verProto, source, target, cred, msgID, respURI, meta)) {
-        s = new StringBuffer();
-        s->append(verDTD);
-        s->append(verProto);
-        s->append(sessionID);
-        s->append(msgID);
-        s->append(target);
-        s->append(source);
-        s->append(respURI);
-        s->append(cred);
-        s->append(meta);        
-    }
-    
-    ret = getValue(SYNC_HDR, s);
-    
-    deleteAllStringBuffer(10, &s, &sessionID, &verDTD, &verProto, &msgID, &respURI, &target, &source, &cred, &meta);
-
-    return ret;
-}
-
-StringBuffer* Formatter::getCred(Cred* cred) {
-     if (!cred)
-        return NULL;
-    
-    StringBuffer* ret  = NULL;
-    StringBuffer* auth = NULL;
-    auth = getAuthentication(cred->getAuthentication());
-            
-    if (auth) { 
-        //ret = new StringBuffer();
-        ret = getValue(CRED, auth);
-    }        
-    deleteStringBuffer(&auth);
-
-    return ret;
-}
-
-StringBuffer* Formatter::getAuthentication(Authentication* auth) {
-    
-    if (!auth)
-        return NULL;
-
-    StringBuffer* ret          = NULL;
-    StringBuffer* data         = NULL;
-    StringBuffer* meta         = NULL;
-    
-    data = getValue(DATA, auth->getData(NULL));
-    meta = getMeta(auth->getMeta());
-    
-    if (NotZeroStringBufferLenght(2, data, meta)) {
-        ret = new StringBuffer();
-        ret->append(meta);
-        ret->append(data);
-    }
-    deleteAllStringBuffer(2, &meta, &data);
-    
-    return ret;
-}
-
-StringBuffer* Formatter::getMeta(Meta* meta) {
-    
-    if (!meta) 
-        return NULL;    
-
-    StringBuffer* ret        = NULL;
-    StringBuffer* metInf     = NULL;    
-    
-    metInf = getMetInf(meta->getMetInf());            
-
-    if (NotZeroStringBufferLenght(1, metInf)) {
-        ret = getValue(META, metInf);  
-    }    
-    deleteStringBuffer(&metInf);    
-
-    return ret;        
-}
-
-StringBuffer* Formatter::getMetInf(MetInf* metInf) {
-    if (!metInf)
-        return NULL;
-
-    StringBuffer* ret       = NULL;    
-    
-    StringBuffer*     format     = NULL;
-    StringBuffer*     type       = NULL;
-    StringBuffer*     mark       = NULL;
-    StringBuffer*     anchor     = NULL;
-    StringBuffer*     version    = NULL;
-    StringBuffer*     nextNonce  = NULL;
-    StringBuffer*     maxMsgSize = NULL;
-    StringBuffer*     maxObjSize = NULL;
-    StringBuffer*     size       = NULL;
-    //ArrayList*   emi        = NULL;
-    StringBuffer*     mem        = NULL; 
-
-    // get all the values
-
-    format       = getValue(FORMAT, metInf->getFormat(NULL));
-    type         = getValue(TYPE,   metInf->getType(NULL)); 
-    mark         = getValue(MARK,   metInf->getMark(NULL));
-    
-    anchor       = getAnchor(metInf->getAnchor());
-    version      = getValue(VERSIONSTR, metInf->getVersion(NULL)); 
-
-    nextNonce    = getNextNonce(metInf->getNextNonce());
-    
-    maxMsgSize   = getValue(MAX_MESSAGE_SIZE, metInf->getMaxMsgSize());
-    maxObjSize   = getValue(MAX_OBJ_SIZE, metInf->getMaxObjSize());
-    size         = getValue(SIZE,         metInf->getSize());             
-        
-    //emi          = getEMI(xml);
-    mem          = getMem(metInf->getMem());    
-    
-    if (NotZeroStringBufferLenght(8, format, type, mark, size, anchor, version, maxMsgSize, maxObjSize)) {
-        ret = new StringBuffer();
-        ret ->append(format);
-        ret ->append(type);
-        ret ->append(mark);
-        ret ->append(size);
-        ret ->append(anchor);
-        ret ->append(version);
-        ret ->append(nextNonce);
-        ret ->append(maxMsgSize);
-        ret ->append(maxObjSize);               
-        ret ->append(mem);               
-    }             
-    deleteAllStringBuffer(10, &format, &type, &mark, &version, &maxMsgSize, &maxObjSize, &size, &nextNonce, &mem, &anchor);
-       
-    return ret;    
-}
-
-StringBuffer* Formatter::getMem(Mem* mem) {    
-    if (!mem)
-        return NULL;
-
-    StringBuffer* ret = new StringBuffer();                
-    StringBuffer* tmp = NULL;
-
-    tmp = getValue(SHARED_MEM, mem->getSharedMem());
-    ret->append(tmp);
-    if (tmp) { delete tmp; tmp = NULL; }
-    
-    tmp = getValue(FREE_MEM,   mem->getFreeMem());
-    ret->append(tmp);
-    if (tmp) { delete tmp; tmp = NULL; }
-
-    tmp = getValue(FREE_ID,    mem->getFreeID());
-    ret->append(tmp);
-    if (tmp) { delete tmp; tmp = NULL; }
-
-    return ret;    
-}
-
-StringBuffer* Formatter::getNextNonce(NextNonce* nextNonce) {    
-    if (!nextNonce)
-        return NULL;
-
-    StringBuffer* ret = new StringBuffer();             
-    ret = getValue(NEXT_NONCE, nextNonce->getValueAsBase64());
-    return ret;    
-}
-
-StringBuffer* Formatter::getAnchor(Anchor* anchor) {    
-    if (!anchor)
-        return NULL;
-
-    StringBuffer* ret = NULL;   
-    StringBuffer* buf = new StringBuffer();   
-    StringBuffer* tmp = NULL;
-
-    tmp = getValue(LAST,  anchor->getLast());
-    buf->append(tmp);
-    if (tmp) { delete tmp; tmp = NULL; }
-    
-    tmp = getValue(NEXT,  anchor->getNext());
-    buf->append(tmp);
-    if (tmp) { delete tmp; tmp = NULL; }
-        
-    ret = getValue(ANCHOR, buf);    
-    
-    if (buf) {delete buf; buf = NULL; }
-    return ret;    
-}
-
-/*
-* Returns a series of 
-*  <Source> ... </Source> 
-*  <Source> ... </Source> 
-*  <Source> ... </Source> 
-* 
-*  use a SourceArray class type
-*/
-StringBuffer* Formatter::getSources(ArrayList* sources) {
-    
-    if (!sources || !NotZeroArrayLenght(1, sources))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-    
-    for (int i = 0; i < sources->size(); i++) {
-        tmp = getSourceArray(((SourceArray*)sources->get(i)));
-        ret->append(tmp);   
-        if (tmp) { delete tmp; tmp = NULL; }
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getSourceArray(SourceArray* sourceArray) {    
-    if (!sourceArray)
-        return NULL;
-
-    StringBuffer* ret = new StringBuffer(); 
-    StringBuffer* s   = new StringBuffer(); 
-    StringBuffer* tmp = NULL;
-    
-    tmp = getValue(LOC_URI,  sourceArray->getSource()->getLocURI());
-    s->append(tmp);
-    if (tmp) { delete tmp; tmp = NULL; }
-
-    tmp = getValue(LOC_NAME, sourceArray->getSource()->getLocName());
-    s->append(tmp);
-    if (tmp) { delete tmp; tmp = NULL; }
-
-    if (NotZeroStringBufferLenght(1, s)) {     
-        ret = getValue(SOURCE, s);    
-    }    
-    
-    deleteAllStringBuffer(1, &s);
-
-    return ret;    
-}
-
-
-StringBuffer* Formatter::getSource(Source* source) {    
-    if (!source)
-        return NULL;
-
-    StringBuffer* ret = new StringBuffer(); 
-    StringBuffer* s   = new StringBuffer(); 
-    StringBuffer* tmp = NULL;
-
-    tmp = getValue(LOC_URI,  source->getLocURI());
-    s->append(tmp);
-    if (tmp) { delete tmp; tmp = NULL; }
-
-    tmp = getValue(LOC_NAME, source->getLocName());
-    s->append(tmp);
-    if (tmp) { delete tmp; tmp = NULL; }
-
-    if (NotZeroStringBufferLenght(1, s)) {     
-        delete ret; ret = NULL;
-        ret = getValue(SOURCE, s);    
-    }    
-    
-    deleteStringBuffer(&s);
-
-    return ret;    
-}
-
-StringBuffer* Formatter::getTarget(Target* target) {    
-    if (!target)
-        return NULL;    
-
-    StringBuffer* ret    = new StringBuffer();
-    StringBuffer* s      = new StringBuffer();
-    StringBuffer* filter = new StringBuffer();
-    StringBuffer* tmp    = NULL;
-    
-    tmp = getValue(LOC_URI,  target->getLocURI());
-    s->append(tmp);
-    if (tmp) { delete tmp; tmp = NULL; }
-    
-    tmp = getValue(LOC_NAME, target->getLocName());
-    s->append(tmp);
-    if (tmp) { delete tmp; tmp = NULL; }
-
-    //
-    // And now the filter (if any)
-    //
-    if (target->getFilter()) {
-        filter = getFilter(target->getFilter());
-        s->append(filter);
-    }
-    
-    if (NotZeroStringBufferLenght(1, s)) {    
-        delete ret; ret = NULL;
-        ret = getValue(TARGET, s);
-        
-    } 
-    
-    deleteAllStringBuffer(2, &s, &filter);
-
-    return ret;    
-}
-
-StringBuffer* Formatter::getSessionID(SessionID* sessionID) {    
-    if (!sessionID)
-        return NULL;
-
-    StringBuffer* s = NULL;
-    s = getValue(SESSION_ID, sessionID->getSessionID(NULL));    
-    return s;    
-}
-
-StringBuffer* Formatter::getVerDTD(VerDTD* verDTD) {    
-    if (!verDTD)
-        return NULL;
-
-    StringBuffer* s = NULL;
-    s = getValue(VER_DTD, verDTD->getValue(NULL));    
-    return s;    
-}
-
-StringBuffer* Formatter::getCmdID(CmdID* cmdID) {    
-    if (!cmdID)
-        return NULL;
-
-    StringBuffer* s = NULL;
-    s = getValue(CMD_ID, cmdID->getCmdID());    
-    return s;    
-}
-
-StringBuffer* Formatter::getVerProto(VerProto* verProto) {    
-    if (!verProto)
-        return NULL;
-
-    StringBuffer* s = NULL;
-    s = getValue(VER_PROTO, verProto->getVersion(NULL));
-    return s;    
-}
-
-/*
-* Used to retrieve the extra command list that are 
-* Exec
-* Alert
-* Get
-* Map
-*/
-StringBuffer* Formatter::getExtraCommandList(ArrayList* commands) {
-    
-    StringBuffer*   s               = NULL;    
-    
-    StringBuffer*   exec            = NULL;
-    StringBuffer*   map             = NULL;
-    StringBuffer*   alert           = NULL;
-    StringBuffer*   get             = NULL;
-    BCHAR*          name            = NULL;
-    StringBuffer*   tmp             = NULL;
-    /*
-    * Use the name of the command to get the proper action to invoke
-    */
-    for (int i = 0; i < commands->size(); i++) {
-        name = ((AbstractCommand*)(commands->get(i)))->getName();    
-        if (name && bstrcmp(name, EXEC) == 0) {
-            if (!exec) {
-                exec = new StringBuffer();
-            }
-            tmp = getExec((Exec*)commands->get(i));
-            exec->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, ALERT) == 0) {
-            if (!alert) {
-                alert = new StringBuffer();
-            }
-            tmp = getAlert((Alert*)commands->get(i));
-            alert->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, GET) == 0) {
-            if (!get) {
-                get = new StringBuffer();
-            }
-            tmp = getGet((Get*)commands->get(i));
-            get->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, MAP) == 0) {
-            if (!map) {
-                map = new StringBuffer();
-            }
-            tmp = getMap((Map*)commands->get(i));
-            map->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        }
-    }    
-
-    if (NotZeroStringBufferLenght(4, exec, map, alert, get)) {
-        s = new StringBuffer();
-        s->append(exec);
-        s->append(map);
-        s->append(alert);
-        s->append(get);        
-    }    
-    deleteAllStringBuffer(4, &exec, &map, &alert, &get);
-    return s;   
-}
-
-
-
-/*
-* Used to retrieve the common command list that are 
-* Add
-* Replace
-* Copy
-* Delete
-*/
-StringBuffer* Formatter::getCommonCommandList(ArrayList* commands) {
-    
-    StringBuffer*   s               = NULL;    
-    
-    StringBuffer*   adds            = NULL;
-    StringBuffer*   dels            = NULL;
-    StringBuffer*   replaces        = NULL;
-    StringBuffer*   copies          = NULL;
-    BCHAR*          name            = NULL;
-    StringBuffer*   tmp             = NULL;
-    /*
-    * Use the name of the command to get the proper action to invoke
-    */
-    for (int i = 0; i < commands->size(); i++) {
-        name = ((AbstractCommand*)(commands->get(i)))->getName();    
-        if (name && bstrcmp(name, COPY) == 0) {
-            if (!copies) {
-                copies = new StringBuffer();
-            }
-            tmp = getCopy((Copy*)commands->get(i));
-            copies->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, ADD) == 0) {
-            if (!adds) {
-                adds = new StringBuffer();
-            }
-            tmp = getAdd((Add*)commands->get(i));
-            adds->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-
-        } else if (name && bstrcmp(name, DEL) == 0) {
-            if (!dels) {
-                dels = new StringBuffer();
-            }
-            tmp = getDelete((Delete*)commands->get(i));
-            dels->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, REPLACE) == 0) {
-            if (!replaces) {
-                replaces = new StringBuffer();
-            }
-            tmp = getReplace((Replace*)commands->get(i));
-            replaces->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        }
-    }    
-
-    if (NotZeroStringBufferLenght(4, copies, adds, replaces, dels)) {
-        s = new StringBuffer();
-        s->append(copies);
-        s->append(adds);
-        s->append(replaces);
-        s->append(dels);        
-    }    
-    deleteAllStringBuffer(4, &copies, &adds, &replaces, &dels);
-    return s;   
-}
-
-/*
-* Used to retrieve a specific command like SYNC or ATOMIC or SEQUENCE
-*/
-StringBuffer* Formatter::getSpecificCommand(ArrayList* commands, BCHAR* commandName) {
-    
-    StringBuffer*   s               = NULL;        
-    StringBuffer*   ret             = NULL;   
-    BCHAR*          name            = NULL;
-    StringBuffer*   tmp             = NULL;
-    /*
-    * Use the name of the command to get the proper action to invoke
-    */
-    for (int i = 0; i < commands->size(); i++) {
-        name = ((AbstractCommand*)(commands->get(i)))->getName();    
-        if (name && bstrcmp(name, SYNC) == 0 && bstrcmp(SYNC, commandName) == 0) {
-            if (!ret) {
-                ret = new StringBuffer();
-            }
-            tmp = getSync((Sync*)commands->get(i));
-            ret->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, ATOMIC) == 0 && bstrcmp(ATOMIC, commandName) == 0) {
-            if (!ret) {
-                ret = new StringBuffer();
-            }
-            tmp = getAtomic((Atomic*)commands->get(i));
-            ret->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, SEQUENCE) == 0 && bstrcmp(SEQUENCE, commandName) == 0) {
-            if (!ret) {
-                ret = new StringBuffer();
-            }
-            tmp = getSequence((Sequence*)commands->get(i));
-            ret->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } 
-    }    
-
-    if (NotZeroStringBufferLenght(1, ret)) {
-        s = new StringBuffer();
-        s->append(ret);        
-    }    
-    deleteAllStringBuffer(1, &ret);
-    
-    return s;   
-}
-
-
-
-StringBuffer* Formatter::getSyncBody(SyncBody* syncBody) {
-       
-    StringBuffer*   ret             = NULL;
-    StringBuffer*   s               = NULL;    
-    ArrayList*      commands        = NULL;
-    BCHAR* name                     = NULL;
-
-    StringBuffer*   alerts          = NULL;
-    StringBuffer*   statusArray     = NULL;    
-    StringBuffer*   sync            = NULL;    
-    StringBuffer*   commonCommandList = NULL;    
-    StringBuffer*   map             = NULL;    
-    StringBuffer*   exec            = NULL;    
-    StringBuffer*   get             = NULL;    
-    StringBuffer*   put             = NULL;    
-    StringBuffer*   results         = NULL;    
-    StringBuffer*   search          = NULL;    
-    StringBuffer*   sequence        = NULL;    
-    StringBuffer*   atomic          = NULL;    
-
-    
-    StringBuffer*   finalMessage    = NULL;
-    
-    commands = syncBody->getCommands();
-    StringBuffer* tmp               = NULL;
-
-    /*
-    * Use the name of the command to get the proper action to invoke
-    */
-    for (int i = 0; i < commands->size(); i++) {
-        name = ((AbstractCommand*)(commands->get(i)))->getName();    
-        if (name && bstrcmp(name, STATUS) == 0) {
-            if (!statusArray) {
-                statusArray = new StringBuffer();
-            }
-            tmp = getStatus((Status*)commands->get(i));
-            statusArray->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, ALERT) == 0) {
-            if (!alerts) {
-                alerts = new StringBuffer();
-            }
-            tmp = getAlert((Alert*)commands->get(i));
-            alerts->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, SYNC) == 0) {
-            if (!sync) {
-                sync = new StringBuffer();
-            }
-            tmp = getSync((Sync*)commands->get(i));
-            sync->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, MAP) == 0) {
-            if (!map) {
-                map = new StringBuffer();
-            }
-            tmp = getMap((Map*)commands->get(i));
-            map->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, EXEC) == 0) {
-            if (!exec) {
-                exec = new StringBuffer();
-            }
-            tmp = getExec((Exec*)commands->get(i));
-            exec->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, GET) == 0) {
-            if (!get) {
-                get = new StringBuffer();
-            }
-            tmp = getGet((Get*)commands->get(i));
-            get->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, RESULTS) == 0) {
-            if (!results) {
-                results = new StringBuffer();
-            }
-            tmp = getResults((Results*)commands->get(i));
-            results->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, PUT) == 0) {
-            if (!put) {
-                put = new StringBuffer();
-            }
-            tmp = getPut((Put*)commands->get(i));
-            put->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, SEARCH) == 0) {
-            if (!search) {
-                search = new StringBuffer();
-            }
-            tmp = getSearch((Search*)commands->get(i));
-            search->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, SEQUENCE) == 0) {
-            if (!sequence) {
-                sequence = new StringBuffer();
-            }
-            tmp = getSequence((Sequence*)commands->get(i));
-            sequence->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        } else if (name && bstrcmp(name, ATOMIC) == 0) {
-            if (!atomic) {
-                atomic = new StringBuffer();
-            }
-            tmp = getAtomic((Atomic*)commands->get(i));
-            atomic->append(tmp);
-            if (tmp) { delete tmp; tmp = NULL; }
-        }  
-        
-    }    
-     //
-    // get the common command copy, add, delete, replace
-    //
-    commonCommandList = getCommonCommandList(commands);
-    
-    finalMessage = getValue(FINAL_MSG, syncBody->getFinalMsg());
-
-    if (finalMessage || NotZeroStringBufferLenght(11, alerts, commonCommandList, statusArray, sync, map, 
-                                                     exec, get, put, results, search, sequence)) {
-        s = new StringBuffer();
-        s->append(statusArray);
-        s->append(alerts);
-        s->append(atomic);
-        s->append(exec);
-        s->append(get);
-        s->append(map);
-        s->append(put);
-        s->append(results);
-        s->append(search);
-        s->append(sequence);
-        s->append(sync);
-        s->append(commonCommandList); 
-        s->append(finalMessage);        
-    }
-    ret = getValue(SYNC_BODY, s);
-    deleteAllStringBuffer(12, &s, &alerts, &finalMessage, &statusArray, &sync, &map, &exec, &get, &put, &results, &search, &sequence);
-
-    return ret;   
-}
-
-StringBuffer* Formatter::getSearch(Search* search) {
-    
-    if (!search)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-
-    StringBuffer* cmdID     = NULL;
-    StringBuffer* cred      = NULL;
-    StringBuffer* meta      = NULL;    
-    StringBuffer* noResp    = NULL;
-    StringBuffer* noResults = NULL;
-    StringBuffer* lang      = NULL;
-    StringBuffer* data      = NULL;
-    StringBuffer* target    = NULL;
-    StringBuffer* sources   = NULL;
-
-    cmdID     = getCmdID   (search->getCmdID());
-    cred      = getCred    (search->getCred());
-    meta      = getMeta    (search->getMeta());    
-    noResp    = getValue   (NO_RESP, search->getNoResp());
-    noResults = getValue   (NO_RESULTS, search->getNoResults());
-    lang      = getValue   (LANG, search->getLang());    
-    data      = getData    (search->getData());    
-    target    = getTarget  (search->getTarget());
-    sources   = getSources (search->getSources());
-
-    if (NotZeroStringBufferLenght(9, cmdID, cred, meta, noResults, noResp, lang, data, target, sources)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(noResp);
-        s->append(noResults);
-        s->append(cred);
-        s->append(target);
-        s->append(sources);
-        s->append(lang);
-        s->append(meta);
-        s->append(data);
-    }
-
-    ret = getValue(SEARCH, s);
-    deleteAllStringBuffer(10, &s, &cred, &cmdID, &meta, &noResults, &noResp, &lang, &data, &target, &sources);
-   
-    return ret;
-}
-
-
-StringBuffer* Formatter::getGet(Get* get) {
-    
-    if (!get)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-
-    StringBuffer* cmdID     = NULL;
-    StringBuffer* cred      = NULL;
-    StringBuffer* meta      = NULL;
-    StringBuffer* items     = NULL;
-    StringBuffer* noResp    = NULL;
-    StringBuffer* lang      = NULL;
-    
-    cmdID     = getCmdID   (get->getCmdID());
-    cred      = getCred    (get->getCred());
-    meta      = getMeta    (get->getMeta());
-    items     = getItems   (get->getItems());    
-    noResp    = getValue   (NO_RESP, get->getNoResp());
-    lang      = getValue   (LANG, get->getNoResp());    
-
-    if (NotZeroStringBufferLenght(6, cmdID, cred, meta, items, noResp, lang)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(noResp);
-        s->append(lang);
-        s->append(cred);
-        s->append(meta);
-        s->append(items);
-    }
-
-    ret = getValue(GET, s);
-    deleteAllStringBuffer(7, &s, &cred, &cmdID, &meta, &items, &noResp, &lang);
-   
-    return ret;
-}
-
-StringBuffer* Formatter::getExec(Exec* exec) {
-    
-    if (!exec)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-    
-    StringBuffer* cmdID     = NULL;
-    StringBuffer* cred      = NULL;
-    StringBuffer* items     = NULL;
-    StringBuffer* noResp    = NULL;
-    
-    cmdID     = getCmdID   (exec->getCmdID());
-    cred      = getCred    (exec->getCred());
-    items     = getItems   (exec->getItems());    
-    noResp    = getValue   (NO_RESP, exec->getNoResp());
-    
-    if (NotZeroStringBufferLenght(4, cmdID, cred, items, noResp)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(noResp);
-        s->append(cred);
-        s->append(items);
-    }
-
-    ret = getValue(EXEC, s);
-    deleteAllStringBuffer(5, &s, &cred, &cmdID, &items, &noResp);
-   
-    return ret;
-}
-
-StringBuffer* Formatter::getMap(Map* map) {
-    
-    if (!map)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-
-    StringBuffer* cmdID     = NULL;
-    StringBuffer* target    = NULL;
-    StringBuffer* source    = NULL;
-    StringBuffer* cred      = NULL;
-    StringBuffer* meta      = NULL;
-    
-    StringBuffer* mapItems  = NULL;
-           
-    cmdID     = getCmdID   (map->getCmdID());
-    cred      = getCred    (map->getCred());
-    meta      = getMeta    (map->getMeta());
-    source    = getSource  (map->getSource());
-    target    = getTarget  (map->getTarget());
-    mapItems  = getMapItems(map->getMapItems());
-
-    if (NotZeroStringBufferLenght(6, cmdID, cred, meta, source, target, mapItems)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(target);
-        s->append(source);
-        s->append(cred);
-        s->append(meta);
-        s->append(mapItems);
-    }
-
-    ret = getValue(MAP, s);
-    deleteAllStringBuffer(7, &s, &cred, &cmdID, &meta, &source, &target, &mapItems);
-   
-    return ret;
-}
-
-/*
-* Returns a series of 
-*  <MapItem> ... </MapItem> 
-*  <MapItem> ... </MapItem> 
-*  <MapItem> ... </MapItem> 
-* 
-*/
-StringBuffer* Formatter::getMapItems(ArrayList* mapItems) {
-    
-    if (!mapItems || !NotZeroArrayLenght(1, mapItems))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-        
-    for (int i = 0; i < mapItems->size(); i++) {
-        tmp = getMapItem(((MapItem*)mapItems->get(i)));
-        ret->append(tmp);   
-        if (tmp) { delete tmp; tmp = NULL; }
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getMapItem(MapItem* mapItem) {
-    
-    if (!mapItem)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-        
-    StringBuffer* target     = NULL;
-    StringBuffer* source      = NULL;
-    
-    target      = getTarget (mapItem->getTarget());
-    source      = getSource (mapItem->getSource());
-    
-    if (NotZeroStringBufferLenght(2, target, source)) {
-        s = new StringBuffer();
-        s->append(target);
-        s->append(source);        
-    }
-
-    ret = getValue(MAP_ITEM, s);
-    deleteAllStringBuffer(2, &s, &target, &source);
-   
-    return ret;
-}
-
-
-StringBuffer* Formatter::getSync(Sync* sync) {
-    
-    if (!sync)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-        
-    StringBuffer* cmdID     = NULL;
-    StringBuffer* cred      = NULL;
-    StringBuffer* meta      = NULL;
-    StringBuffer* noResp    = NULL;
-    StringBuffer* target    = NULL;
-    StringBuffer* source    = NULL;
-    StringBuffer* numberOfChanges    = NULL;
-    StringBuffer* commonCommandList = NULL;
-    
-    StringBuffer* sequence = NULL;
-    StringBuffer* atomic   = NULL;
-    
-
-    cmdID     = getCmdID   (sync->getCmdID());
-    cred      = getCred    (sync->getCred());
-    meta      = getMeta    (sync->getMeta());
-    noResp    = getValue   (NO_RESP, sync->getNoResp());
-    source    = getSource  (sync->getSource());
-    target    = getTarget  (sync->getTarget());
-    numberOfChanges = getValue(NUMBER_OF_CHANGES, sync->getNumberOfChanges());    
-    commonCommandList = getCommonCommandList(sync->getCommands());
-    
-    sequence = getSpecificCommand(sync->getCommands(), SEQUENCE);
-    atomic   = getSpecificCommand(sync->getCommands(), ATOMIC);
-
-    if (NotZeroStringBufferLenght(10, cmdID, cred, meta, source, target, noResp, numberOfChanges, commonCommandList, sequence, atomic)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(noResp);
-        s->append(cred);
-        s->append(target);
-        s->append(source);
-        s->append(meta);
-        s->append(numberOfChanges);
-        s->append(atomic);
-        s->append(commonCommandList);
-        s->append(sequence);
-    }
-
-    ret = getValue(SYNC, s);
-    deleteAllStringBuffer(11, &s, &cred, &cmdID, &meta, &source, &target, &noResp, &numberOfChanges, &commonCommandList, &atomic, &sequence);
-   
-    return ret;
-}
-
-StringBuffer* Formatter::getSequence(Sequence* sequence) {
-    
-    if (!sequence)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-
-    StringBuffer* cmdID     = NULL;
-    StringBuffer* meta      = NULL;
-    StringBuffer* noResp    = NULL;
-    StringBuffer* commonCommandList = NULL;
-    StringBuffer* extraCommandList  = NULL;
-    StringBuffer* sync      = NULL;
-    StringBuffer* atomic      = NULL;
-
-    cmdID     = getCmdID   (sequence->getCmdID());
-    meta      = getMeta    (sequence->getMeta());
-    noResp    = getValue   (NO_RESP, sequence->getNoResp());
-    commonCommandList = getCommonCommandList(sequence->getCommands());    
-    extraCommandList  = getExtraCommandList(sequence->getCommands());
-    sync = getSpecificCommand(sequence->getCommands(), SYNC);
-    atomic = getSpecificCommand(sequence->getCommands(), ATOMIC);
-
-    if (NotZeroStringBufferLenght(7, cmdID, meta, noResp, commonCommandList, extraCommandList, sync, atomic)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(noResp);
-        s->append(meta);
-        s->append(commonCommandList);
-        s->append(extraCommandList);
-        s->append(atomic);
-        s->append(sync);
-        
-    }
-
-    ret = getValue(SEQUENCE, s);
-    deleteAllStringBuffer(8, &s, &cmdID, &meta, &noResp, &commonCommandList, &extraCommandList, &sync, &atomic);
-   
-    return ret;
-}
-
-StringBuffer* Formatter::getAtomic(Atomic* atomic) {
-    
-    if (!atomic)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-    
-    StringBuffer* cmdID     = NULL;
-    StringBuffer* noResp    = NULL;
-    StringBuffer* meta      = NULL;
-    StringBuffer* commonCommandList = NULL;
-    StringBuffer* extraCommandList  = NULL;
-    StringBuffer* sync      = NULL;
-    StringBuffer* sequence  = NULL;
-
-    cmdID     = getCmdID   (atomic->getCmdID());
-    noResp    = getValue   (NO_RESP, atomic->getNoResp());
-    meta      = getMeta    (atomic->getMeta());
-    commonCommandList = getCommonCommandList(atomic->getCommands());    
-    extraCommandList  = getExtraCommandList(atomic->getCommands());
-    sync      = getSpecificCommand(atomic->getCommands(), SYNC);
-    sequence  = getSpecificCommand(atomic->getCommands(), SEQUENCE);
-
-    if (NotZeroStringBufferLenght(7, cmdID, meta, noResp, commonCommandList, extraCommandList, sync, sequence)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(noResp);
-        s->append(meta);
-        s->append(commonCommandList);
-        s->append(extraCommandList);
-        s->append(sync);
-        s->append(sequence);
-
-    }
-
-    ret = getValue(ATOMIC, s);
-    deleteAllStringBuffer(8, &s, &cmdID, &meta, &noResp, &commonCommandList, &extraCommandList, &sync,&sequence);
-   
-    return ret;
-}
-
-
-/*
-* Returns a series of 
-*  <Copy> ... </Copy> 
-*  <Copy> ... </Copy> 
-*  <Copy> ... </Copy> 
-* 
-*/
-StringBuffer* Formatter::getCopies(ArrayList* copies) {
-    
-    if (!copies || !NotZeroArrayLenght(1, copies))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-        
-    for (int i = 0; i < copies->size(); i++) {
-        ret->append(getCopy(((Copy*)copies->get(i))));   
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getCopy(Copy* copy) {
-    
-    if (!copy)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-        
-    StringBuffer* cmdID     = NULL;
-    StringBuffer* cred      = NULL;
-    StringBuffer* meta      = NULL;
-    StringBuffer* items     = NULL;
-    StringBuffer* noResp    = NULL;
-    
-    cmdID     = getCmdID   (copy->getCmdID());
-    cred      = getCred    (copy->getCred());
-    meta      = getMeta    (copy->getMeta());
-    items     = getItems   (copy->getItems());    
-    noResp    = getValue   (NO_RESP, copy->getNoResp());
-    
-    if (NotZeroStringBufferLenght(5, cmdID, cred, meta, items, noResp)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(noResp);
-        s->append(cred);
-        s->append(meta);
-        s->append(items);
-    }
-
-    ret = getValue(COPY, s);
-    deleteAllStringBuffer(6, &s, &cred, &cmdID, &meta, &items, &noResp);
-   
-    return ret;
-}
-
-
-
-/*
-* Returns a series of 
-*  <Replace> ... </Replace> 
-*  <Replace> ... </Replace> 
-*  <Replace> ... </Replace> 
-* 
-*/
-StringBuffer* Formatter::getReplaces(ArrayList* replaces) {
-    
-    if (!replaces || !NotZeroArrayLenght(1, replaces))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-        
-    for (int i = 0; i < replaces->size(); i++) {
-        ret->append(getReplace(((Replace*)replaces->get(i))));   
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getReplace(Replace* replace) {
-    
-    if (!replace)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-
-    StringBuffer* cmdID     = NULL;
-    StringBuffer* cred      = NULL;
-    StringBuffer* meta      = NULL;
-    StringBuffer* items     = NULL;
-    StringBuffer* noResp    = NULL;
-    
-    cmdID     = getCmdID   (replace->getCmdID());
-    cred      = getCred    (replace->getCred());
-    meta      = getMeta    (replace->getMeta());
-    items     = getItems   (replace->getItems());    
-    noResp    = getValue   (NO_RESP, replace->getNoResp());
-    
-    if (NotZeroStringBufferLenght(5, cmdID, cred, meta, items, noResp)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(noResp);
-        s->append(cred);
-        s->append(meta);
-        s->append(items);
-    }
-
-    ret = getValue(REPLACE, s);
-    deleteAllStringBuffer(6, &s, &cred, &cmdID, &meta, &items, &noResp);
-   
-    return ret;
-}
-
-
-/*
-* Returns a series of 
-*  <Delete> ... </Delete> 
-*  <Delete> ... </Delete> 
-*  <Delete> ... </Delete> 
-* 
-*  The root is <SyncBody>
-*/
-StringBuffer* Formatter::getDels(ArrayList* dels) {
-    
-    if (!dels || !NotZeroArrayLenght(1, dels))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-        
-    for (int i = 0; i < dels->size(); i++) {
-        ret->append(getDelete(((Delete*)dels->get(i))));   
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getDelete(Delete* del) {
-    
-    if (!del)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-            
-    StringBuffer* cmdID     = NULL;
-    StringBuffer* cred      = NULL;
-    StringBuffer* meta      = NULL;
-    StringBuffer* items     = NULL;
-    StringBuffer* noResp    = NULL;
-    StringBuffer* archive   = NULL;
-    StringBuffer* sftdel    = NULL;
-    
-    cmdID     = getCmdID   (del->getCmdID());
-    cred      = getCred    (del->getCred());
-    meta      = getMeta    (del->getMeta());
-    items     = getItems   (del->getItems());    
-    noResp    = getValue   (NO_RESP, del->getNoResp());
-    archive   = getValue   (ARCHIVE, del->getArchive());
-    sftdel    = getValue   (SFT_DEL, del->getSftDel());
-    
-    if (NotZeroStringBufferLenght(7, cmdID, cred, meta, items, noResp, sftdel, archive)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(noResp);
-        s->append(archive);
-        s->append(sftdel);
-        s->append(cred);
-        s->append(meta);
-        s->append(items);
-    }
-
-    ret = getValue(DEL, s);
-    deleteAllStringBuffer(8, &s, &cred, &cmdID, &meta, &items, &noResp, &sftdel, &archive);
-   
-    return ret;
-}
-
-
-/*
-* Returns a series of 
-*  <Add> ... </Add> 
-*  <Add> ... </Add> 
-*  <Add> ... </Add> 
-* 
-*  The root is <SyncBody>
-*/
-StringBuffer* Formatter::getAdds(ArrayList* adds) {
-    
-    if (!adds || !NotZeroArrayLenght(1, adds))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-        
-    for (int i = 0; i < adds->size(); i++) {
-        ret->append(getAdd(((Add*)adds->get(i))));   
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getAdd(Add* add) {
-    
-    if (!add)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-    
-    StringBuffer* cmdID     = NULL;
-    StringBuffer* cred      = NULL;
-    StringBuffer* meta      = NULL;
-    StringBuffer* items     = NULL;
-    StringBuffer* noResp    = NULL;
-    
-    cmdID     = getCmdID   (add->getCmdID());
-    cred      = getCred    (add->getCred());
-    meta      = getMeta    (add->getMeta());
-    items     = getItems   (add->getItems());    
-    noResp    = getValue   (NO_RESP, add->getNoResp());
-    
-    if (NotZeroStringBufferLenght(5, cmdID, cred, meta, items, noResp)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(noResp);
-        s->append(cred);
-        s->append(meta);
-        s->append(items);
-    }
-
-    ret = getValue(ADD, s);
-    deleteAllStringBuffer(6, &s, &cred, &cmdID, &meta, &items, &noResp);
-   
-    return ret;
-}
-
-StringBuffer* Formatter::getPut(Put* put) {
-    
-    if (!put)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-
-    StringBuffer*        cmdID  = NULL;
-    StringBuffer*        meta   = NULL;
-    StringBuffer*        items  = NULL;
-    StringBuffer*        cred   = NULL;
-    StringBuffer*        noResp = NULL;
-    StringBuffer*        lang   = NULL;
-
-    cmdID     = getCmdID   (put->getCmdID());
-    noResp    = getValue   (NO_RESP, put->getNoResp());
-    lang      = getValue   (LANG, put->getNoResp());    
-    cred      = getCred    (put->getCred());
-    meta      = getMeta    (put->getMeta());
-    items     = getItems   (put->getItems());        
-
-    if (NotZeroStringBufferLenght(6, cmdID, lang, meta, items, cred, noResp)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(noResp);                        
-        s->append(lang);
-        s->append(cred);
-        s->append(meta);
-        s->append(items);        
-    }
-
-    ret = getValue(PUT, s);
-    deleteAllStringBuffer(7, &s, &cmdID, &items, &cred, &lang, &meta, &noResp);
-   
-    return ret;
-}
-
-StringBuffer* Formatter::getResults(Results* results) {
-    
-    if (!results)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-
-    StringBuffer*        cmdID  = NULL;
-    StringBuffer*        msgRef = NULL;
-    StringBuffer*        cmdRef = NULL;
-    StringBuffer*        meta   = NULL;
-    StringBuffer*        items  = NULL;
-    StringBuffer*        targetRefs  = NULL;
-    StringBuffer*        sourceRefs  = NULL;
-    
-    cmdID     = getCmdID   (results->getCmdID());
-    msgRef    = getValue   (MSG_REF, results->getMsgRef(NULL));
-    cmdRef    = getValue   (CMD_REF, results->getCmdRef(NULL));
-    meta      = getMeta    (results->getMeta());
-    items     = getItems   (results->getItems());        
-    sourceRefs = getSourceRefs(results->getSourceRef());
-    targetRefs = getTargetRefs(results->getTargetRef());    
-    
-    if (NotZeroStringBufferLenght(7, cmdID, msgRef, cmdRef, meta, items, sourceRefs, targetRefs)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(msgRef);
-        s->append(cmdRef);
-        s->append(meta);
-        s->append(targetRefs);        
-        s->append(sourceRefs);
-        s->append(items);        
-    }
-
-    ret = getValue(RESULTS, s);
-    deleteAllStringBuffer(8, &s, &cmdID, &items, &msgRef, &cmdRef, &meta, &sourceRefs, &targetRefs);
-   
-    return ret;
-}
-
-/*
-* Returns a series of 
-*  <Status> ... </Status> 
-*  <Status> ... </Status> 
-*  <Status> ... </Status> 
-* 
-*/
-StringBuffer* Formatter::getStatusArray(ArrayList* statusArray) {
-    
-    if (!statusArray || !NotZeroArrayLenght(1, statusArray))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-    
-    for (int i = 0; i < statusArray->size(); i++) {
-        tmp = getStatus(((Status*)statusArray->get(i)));
-        ret->append(tmp);   
-        if (tmp) { delete tmp; tmp = NULL; }
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getStatus(Status* status) {
-    
-    if (!status)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-    
-    StringBuffer*        cmdID  = NULL;
-    StringBuffer*        msgRef = NULL;
-    StringBuffer*        cmdRef = NULL;
-    StringBuffer*        cmd    = NULL;
-    StringBuffer*        cred   = NULL;
-    StringBuffer*        items  = NULL;
-    StringBuffer*        targetRefs  = NULL;
-    StringBuffer*        sourceRefs  = NULL;
-    StringBuffer*        data        = NULL;
-    StringBuffer*        chal        = NULL;
-    
-    cmdID     = getCmdID   (status->getCmdID());
-    msgRef    = getValue   (MSG_REF, status->getMsgRef(NULL));
-    cmdRef    = getValue   (CMD_REF, status->getCmdRef(NULL));
-    cmd       = getValue   (CMD     , status->getCmd(NULL));
-    items     = getItems   (status->getItems());        
-    cred      = getCred    (status->getCred());
-    sourceRefs = getSourceRefs(status->getSourceRef());
-    targetRefs = getTargetRefs(status->getTargetRef());    
-    chal      = getChal(status->getChal());    
-    data      = getData   (status->getData());    
-        
-    if (NotZeroStringBufferLenght(10, cmdID, msgRef, cmdRef, cmd, cred, data, items, sourceRefs, targetRefs, chal)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(msgRef);
-        s->append(cmdRef);
-        s->append(cmd);
-        s->append(targetRefs);        
-        s->append(sourceRefs);
-        s->append(cred);        
-        s->append(chal);
-        s->append(data);
-        s->append(items);
-    }
-
-    ret = getValue(STATUS, s);
-    deleteAllStringBuffer(11, &s, &cred, &cmdID, &data, &items, &msgRef, &cmdRef, &cmd, &sourceRefs, &targetRefs, &chal);
-   
-    return ret;
-}
-
-StringBuffer* Formatter::getChal(Chal* chal) {
-    if (!chal)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-    
-    StringBuffer* meta     = getMeta   (chal->getMeta());
-    
-    if (NotZeroStringBufferLenght(1, meta)) {
-        s = new StringBuffer();
-        s->append(meta);        
-    }
-
-    ret = getValue(CHAL, s);
-    deleteAllStringBuffer(2, &s, &meta);
-   
-    return ret;
-
-}
-
-/*
-* Returns a series of 
-*  <Alert> ... </Alert> 
-*  <Alert> ... </Alert> 
-*  <Alert> ... </Alert> 
-* 
-*  The root is <SyncBody>
-*/
-StringBuffer* Formatter::getAlerts(ArrayList* alerts) {
-    
-    if (!alerts || !NotZeroArrayLenght(1, alerts))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-    
-    for (int i = 0; i < alerts->size(); i++) {
-        tmp = getAlert(((Alert*)alerts->get(i)));
-        ret->append(tmp);   
-        if (tmp) { delete tmp; tmp = NULL; }
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getAlert(Alert* alert) {
-    
-    if (!alert)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;    
-    
-    StringBuffer* cmdID     = getCmdID   (alert->getCmdID());
-    StringBuffer* cred      = getCred    (alert->getCred());
-    StringBuffer* data      = getValue   (DATA, (long)alert->getData());
-    StringBuffer* items     = getItems   (alert->getItems());    
-    StringBuffer* noResp    = getValue   (NO_RESP, alert->getNoResp());
-    
-    if (NotZeroStringBufferLenght(5, cmdID, cred, data, items, noResp)) {
-        s = new StringBuffer();
-        s->append(cmdID);
-        s->append(noResp);
-        s->append(cred);
-        s->append(data);
-        s->append(items);
-    }
-
-    ret = getValue(ALERT, s);
-    deleteAllStringBuffer(6, &s, &cred, &cmdID, &data, &items, &noResp);
-   
-    return ret;
-}
-
-/*
-* Returns a series of 
-*  <Item> ... </Item> 
-*  <Item> ... </Item> 
-*  <Item> ... </Item> 
-* 
-*/
-StringBuffer* Formatter::getItems(ArrayList* items) {
-    
-    if (!items || !NotZeroArrayLenght(1, items))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-        
-    for (int i = 0; i < items->size(); i++) {
-        tmp = getItem(((Item*)items->get(i)));
-        ret->append(tmp);   
-        if (tmp) { delete tmp; tmp = NULL; }
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getItem(Item* item) {
-    
-    if (!item)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;
-    
-    StringBuffer*      target   = NULL;
-    StringBuffer*      source   = NULL;
-    StringBuffer*      meta     = NULL;
-    StringBuffer*      data     = NULL;
-    StringBuffer*      moreData = NULL;  
-    StringBuffer*      targetParent = NULL;
-    StringBuffer*      sourceParent = NULL;
-
-
-    
-    target    = getTarget   (item->getTarget());
-    source    = getSource   (item->getSource());
-    meta      = getMeta     (item->getMeta());    
-    data      = getData     (item->getData());
-    moreData  = getValue    (MORE_DATA, item->getMoreData());
-    targetParent  = getValue    (TARGET_PARENT, item->getTargetParent());
-    sourceParent  = getValue    (SOURCE_PARENT, item->getSourceParent());
-
-    
-    if (NotZeroStringBufferLenght(7, target, source, targetParent, sourceParent, meta, data, moreData)) {
-        s = new StringBuffer();
-        s->append(target);
-        s->append(source);
-        s->append(targetParent);
-        s->append(sourceParent);
-        s->append(meta);
-        s->append(data);
-        s->append(moreData);
-    }
-
-    ret = getValue(ITEM, s);
-    deleteAllStringBuffer(8, &s, &target, &source, &targetParent, &sourceParent, &meta, &data, &moreData);
-
-    return ret;
-}
-
-StringBuffer* Formatter::getData(Data* data) {
-    
-    if (!data)
-        return NULL;
-    
-    StringBuffer* ret       = NULL;
-    StringBuffer* s         = NULL;
-    BCHAR* simpleData     = NULL;
-
-    if ((simpleData = data->getData(NULL)) != NULL) {        
-        s = new StringBuffer();
-        s->append(simpleData);
-        ret = getValue(DATA, s);     
-    }
-    deleteAllStringBuffer(1, &s);
-    return ret;
-}
-
-StringBuffer* Formatter::getData(ComplexData* data) {
-    
-    if (!data)
-        return NULL;
-    
-    StringBuffer s;
-    
-    StringBuffer* anchor = getAnchor(data->getAnchor());
-    StringBuffer* devInf = getDevInf(data->getDevInf());
-    
-    if ((anchor != NULL && anchor->length() > 0) ||
-        (devInf != NULL && devInf->length() > 0)) {
-        s.append(anchor);
-        s.append(devInf);
-    } else {
-        StringBuffer tmp(data->getData());
-        tmp.replaceAll("&", "&amp;");
-        tmp.replaceAll("<", "&lt;");
-        s.append(tmp);        
-    }
-
-    deleteAllStringBuffer(2, &anchor, &devInf);
-
-    //
-    // Now let's process the list of Property (if any)
-    //
-    int nProps = 0;
-    ArrayList* properties = data->getProperties();
-    if (properties) {
-        nProps = properties->size();
-    }
-
-    StringBuffer* t1 = NULL;
-    for (int i=0; i<nProps; ++i) {
-        t1 = getProperty((Property*)properties->get(i));
-        s.append(t1);
-        delete t1; t1 = NULL;
-    }
-    
-    return getValue(DATA, &s);
-}
-
-StringBuffer* Formatter::getDevInf(DevInf* devInf) {
-    
-    if (!devInf)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;
-    
-    StringBuffer* verDTD    = NULL;
-    StringBuffer* man       = NULL;
-    StringBuffer* mod       = NULL;
-    StringBuffer* oem       = NULL;
-    StringBuffer* fwV       = NULL;
-    StringBuffer* swV       = NULL;
-    StringBuffer* hwV       = NULL;
-    StringBuffer* devID     = NULL;
-    StringBuffer* devTyp    = NULL;
-
-    StringBuffer* dataStores= NULL;     //DataStore[]
-    StringBuffer* ctCaps    = NULL;     // CTCap[]
-    StringBuffer* exts      = NULL;         // Ext[]
-
-    StringBuffer* utc                    = NULL;
-    StringBuffer* supportLargeObjs       = NULL;
-    StringBuffer* supportNumberOfChanges = NULL;      
-
-    StringBuffer* syncCap   = NULL;
-
-    verDTD  = getVerDTD   (devInf->getVerDTD());        
-    man     = getValue    (MAN, devInf->getMan(NULL));
-    mod     = getValue    (MOD, devInf->getMod(NULL));
-    oem     = getValue    (OEM, devInf->getOEM(NULL));
-    fwV     = getValue    (FWV, devInf->getFwV(NULL));
-    swV     = getValue    (SWV, devInf->getSwV(NULL));
-    hwV     = getValue    (HWV, devInf->getHwV(NULL));
-    devID   = getValue    (DEV_ID, devInf->getDevID(NULL));
-    devTyp  = getValue    (DEV_TYP, devInf->getDevTyp(NULL));
-    dataStores = getDataStores(devInf->getDataStore());
-    syncCap    = getSyncCap(devInf->getSyncCap());
-    ctCaps     = getCTCaps(devInf->getCTCap());
-    exts       = getExts(devInf->getExt());
-
-    utc                     = getValue    (UTC, devInf->getUTC());
-    supportLargeObjs        = getValue    (SUPPORT_LARGE_OBJECT, devInf->getSupportLargeObjs());
-    supportNumberOfChanges  = getValue    (SUPPORT_NUMBER_OF_CHANGES, devInf->getSupportNumberOfChanges());
-
-    if (NotZeroStringBufferLenght(15, verDTD, man, mod, oem, fwV, swV, hwV, devID, devTyp, 
-                                      dataStores, syncCap, ctCaps, utc, supportLargeObjs, supportNumberOfChanges)) {
-        s = new StringBuffer();
-        s->append(verDTD);
-        s->append(man);        
-        s->append(mod);        
-        s->append(oem);        
-        s->append(fwV);        
-        s->append(swV);        
-        s->append(hwV);        
-        s->append(devID);        
-        s->append(devTyp);    
-        s->append(dataStores);
-        s->append(ctCaps);
-        s->append(exts);
-        s->append(syncCap);
-        s->append(utc);    
-        s->append(supportLargeObjs);    
-        s->append(supportNumberOfChanges);            
-    }
-
-    ret = getValue(DEV_INF, s);
-    
-    deleteAllStringBuffer(16, &s, &verDTD, &man, &mod, &oem, &fwV, &swV, &hwV, 
-                              &devID, &devTyp, &dataStores, &ctCaps, &exts, &utc, 
-                              &supportLargeObjs, &supportNumberOfChanges);
-
-    return ret;
-}
-
-/*
-* Returns a series of 
-*  <Ext> ... </Ext> 
-*  <Ext> ... </Ext> 
-*  <Ext> ... </Ext> 
-* 
-*/
-StringBuffer* Formatter::getExts(ArrayList* exts) {
-    
-    if (!exts || !NotZeroArrayLenght(1, exts))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-        
-    for (int i = 0; i < exts->size(); i++) {
-        tmp = getExt(((Ext*)exts->get(i)));
-        ret->append(tmp);   
-        if (tmp) { delete tmp; tmp = NULL; }
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getExt(Ext* ext) {
-    
-    if (!ext)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;
-       
-    StringBuffer*  xNam    = NULL;
-    StringBuffer*  xVals   = NULL;
-    
-    xNam  = getValue (XNAM, ext->getXNam(NULL));
-    xVals = getXVals (ext->getXVal());
-    
-    if (NotZeroStringBufferLenght(2, xNam, xVals)) {
-        s = new StringBuffer();
-        s->append(xNam);
-        s->append(xVals);
-    }
-
-    ret = getValue(EXT, s);
-    deleteAllStringBuffer(3, &s, &xNam, &xVals);
-
-    return ret;
-}
-
-
-/*
-* Returns a series of 
-*  <XVal> ... </XVal> 
-*  <XVal> ... </XVal> 
-*  <XVal> ... </XVal> 
-* 
-*/
-StringBuffer* Formatter::getXVals(ArrayList* xVals) {
-    
-    if (!xVals || !NotZeroArrayLenght(1, xVals))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-        
-    for (int i = 0; i < xVals->size(); i++) {
-        tmp = getXVal(((StringElement*)xVals->get(i)));
-        ret->append(tmp);   
-        if (tmp) { delete tmp; tmp = NULL; }
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getXVal(StringElement* xVal) {
-    
-    if (!xVal)
-        return NULL;
-    
-    StringBuffer* ret = NULL;               
-    ret  = getValue (XVAL, xVal->getValue(NULL));               
-    return ret;
-}
-
-
-/*
-* Returns a series of 
-*  <DataStore> ... </DataStore> 
-*  <DataStore> ... </DataStore> 
-*  <DataStore> ... </DataStore> 
-* 
-*/
-StringBuffer* Formatter::getDataStores(ArrayList* dataStores) {
-    
-    if (!dataStores || !NotZeroArrayLenght(1, dataStores))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-        
-    for (int i = 0; i < dataStores->size(); i++) {
-        tmp = getDataStore(((DataStore*)dataStores->get(i)));
-        ret->append(tmp);   
-        if (tmp) { delete tmp; tmp = NULL; }
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getDataStore(DataStore* dataStore) {
-    
-    if (!dataStore)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;
-    
-    StringBuffer*    sourceRef      = NULL;
-    StringBuffer*    displayName    = NULL;
-    StringBuffer*    maxGUIDSize    = NULL;
-    StringBuffer*    rxPref         = NULL;
-    StringBuffer*    rx             = NULL; // ContentTypeInfo[]
-    StringBuffer*    txPref         = NULL;
-    StringBuffer*    tx             = NULL; // ContentTypeInfo[]
-    StringBuffer*    dsMem          = NULL;
-    StringBuffer*    syncCap        = NULL;  
-    
-    sourceRef   = getSourceRef(dataStore->getSourceRef());
-    displayName = getValue(DISPLAY_NAME, dataStore->getDisplayName(NULL));
-    maxGUIDSize = getValue(MAX_GUID_SIZE, dataStore->getMaxGUIDSize());
-    rxPref      = getContentTypeInfo(dataStore->getRxPref(), RX_PREF);
-    rx          = getContentTypeInfos(dataStore->getRx(), RX);
-    txPref      = getContentTypeInfo(dataStore->getTxPref(), TX_PREF);
-    tx          = getContentTypeInfos(dataStore->getTx(), TX);
-    dsMem       = getDSMem(dataStore->getDSMem());
-    syncCap     = getSyncCap(dataStore->getSyncCap());
-
-    if (NotZeroStringBufferLenght(9, sourceRef, displayName, maxGUIDSize, rxPref, rx, txPref, tx, dsMem, syncCap)) {
-        s = new StringBuffer();
-        s->append(sourceRef);
-        s->append(displayName);
-        s->append(maxGUIDSize);
-        s->append(rxPref);
-        s->append(rx);
-        s->append(txPref);
-        s->append(tx);
-        s->append(dsMem);
-        s->append(syncCap);
-    }
-
-    ret = getValue(DATA_STORE, s);
-    deleteAllStringBuffer(10, &s, &sourceRef  ,&displayName, &maxGUIDSize, &rxPref, &rx, &txPref, &tx, &dsMem, &syncCap);
-
-    return ret;
-}
-
-StringBuffer* Formatter::getSyncCap(SyncCap* syncCap) {
-    
-    if (!syncCap)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;
-
-    StringBuffer* syncTypes   = NULL;
-    
-    syncTypes   = getSyncTypes(syncCap->getSyncType());
-    
-    if (NotZeroStringBufferLenght(1, syncTypes)) {
-        s = new StringBuffer();
-        s->append(syncTypes);        
-    }
-
-    ret = getValue(SYNC_CAP, s);
-    deleteAllStringBuffer(2, &s, &syncTypes);
-
-    return ret;
-}
-
-StringBuffer* Formatter::getSyncTypes(ArrayList* syncTypes) {
-    
-    if (!syncTypes || !NotZeroArrayLenght(1, syncTypes))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-        
-    for (int i = 0; i < syncTypes->size(); i++) {
-        tmp = getSyncType(((SyncType*)syncTypes->get(i)));
-        ret->append(tmp);   
-        if (tmp) { delete tmp; tmp = NULL; }
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getSyncType(SyncType* syncType) {
-    
-    if (!syncType)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;       
-    int  value  = -1;
-        
-    value   = syncType->getType();
-    
-    if (value > -1) {
-        s = new StringBuffer();
-        s->append(value);        
-    }
-
-    ret = getValue(SYNC_TYPE, s);
-    deleteAllStringBuffer(1, &s);
-
-    return ret;
-}
-
-
-StringBuffer* Formatter::getDSMem(DSMem* dsMem) {    
-    if (!dsMem)
-        return NULL;
-
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-    
-    tmp = getValue(SHARED_MEM, dsMem->getSharedMem());
-    ret->append(tmp);    
-    if (tmp) { delete tmp; tmp = NULL; }
-
-    tmp = getValue(MAX_MEM,    dsMem->getMaxMem());
-    ret->append(tmp);
-    if (tmp) { delete tmp; tmp = NULL; }
-
-    tmp = getValue(MAX_ID,     dsMem->getMaxID());
-    ret->append(tmp);
-    if (tmp) { delete tmp; tmp = NULL; }
-    
-    return ret;    
-}
-
-
-StringBuffer* Formatter::getContentTypeInfos(ArrayList* contentTypeInfos, BCHAR* TAG) {
-    
-    if (!contentTypeInfos || !NotZeroArrayLenght(1, contentTypeInfos))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-        
-    for (int i = 0; i < contentTypeInfos->size(); i++) {
-        tmp = getContentTypeInfo(((ContentTypeInfo*)contentTypeInfos->get(i)), TAG);
-        ret->append(tmp);   
-        if (tmp) { delete tmp; tmp = NULL; }
-    }
-    return ret;
-}
-
-
-StringBuffer* Formatter::getContentTypeInfo(ContentTypeInfo* contentTypeInfo, BCHAR* TAG) {
-    
-    if (!contentTypeInfo)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;
-       
-    StringBuffer*  ctType  = NULL;
-    StringBuffer*  verCT   = NULL;
-    
-    ctType  = getValue (CT_TYPE, contentTypeInfo->getCTType(NULL));
-    verCT   = getValue (VER_CT, contentTypeInfo->getVerCT(NULL));
-    
-    if (NotZeroStringBufferLenght(2, ctType, verCT)) {
-        s = new StringBuffer();
-        s->append(ctType);
-        s->append(verCT);
-    }
-
-    ret = getValue(TAG, s);
-    deleteAllStringBuffer(3, &s, &ctType, &verCT);
-
-    return ret;
-}
-
-StringBuffer* Formatter::getTargetRefs(ArrayList* targetRefs) {
-    
-    if (!targetRefs || !NotZeroArrayLenght(1, targetRefs))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-        
-    for (int i = 0; i < targetRefs->size(); i++) {
-        tmp = getTargetRef(((TargetRef*)targetRefs->get(i)));
-        ret->append(tmp);   
-        if (tmp) { delete tmp; tmp = NULL; }
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getTargetRef(TargetRef* targetRef) {
-    
-    if (!targetRef)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;
-    
-    BCHAR*       value  = NULL;
-    StringBuffer*  target = NULL;
-    
-    if ((value = (BCHAR*)targetRef->getValue()) != NULL) {
-        ;  // the value value is arleady set.
-    } else {
-        target = getTarget(targetRef->getTarget());
-    }
-
-    if (value || NotZeroStringBufferLenght(1, target)) {
-        s = new StringBuffer();
-        s->append(value);
-        s->append(target);
-    }
-
-    ret = getValue(TARGET_REF, s);
-    deleteAllStringBuffer(2, &s, &target);
-    
-
-    return ret;
-}
-
-
-StringBuffer* Formatter::getSourceRefs(ArrayList* sourceRefs) {
-    
-    if (!sourceRefs || !NotZeroArrayLenght(1, sourceRefs))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-        
-    for (int i = 0; i < sourceRefs->size(); i++) {
-        tmp = getSourceRef(((SourceRef*)sourceRefs->get(i)));
-        ret->append(tmp);   
-        if (tmp) { delete tmp; tmp = NULL; }
-    }
-    return ret;
-}
-
-StringBuffer* Formatter::getSourceRef(SourceRef* sourceRef) {
-    
-    if (!sourceRef)
-        return NULL;
-    
-    StringBuffer* ret = NULL;
-    StringBuffer* s   = NULL;
-    
-    BCHAR*       value  = NULL;
-    StringBuffer*  source = NULL;
-    
-    if ((value = (BCHAR*)sourceRef->getValue()) != NULL) {
-        ;  // the value value is arleady set.
-    } else {
-        source = getSource(sourceRef->getSource());
-    }
-
-    if (value || NotZeroStringBufferLenght(1, source)) {
-        s = new StringBuffer();
-        s->append(value);
-        s->append(source);
-    }
-
-    ret = getValue(SOURCE_REF, s);
-    deleteAllStringBuffer(2, &s, &source);
-    
-
-    return ret;
-}
-
-/*
-* Returns a series of 
-*  <CTCap> ... </CTCap> 
-*  <CTCap> ... </CTCap> 
-*  <CTCap> ... </CTCap> 
-* 
-*/
-StringBuffer* Formatter::getCTCaps(ArrayList* ctCaps) {
-    
-    if (!ctCaps || !NotZeroArrayLenght(1, ctCaps))
-        return NULL;
-    
-    StringBuffer* ret = new StringBuffer();
-    StringBuffer* tmp = NULL;
-        
-    for (int i = 0; i < ctCaps->size(); i++) {
-        tmp = getCTCap(((CTCap*)ctCaps->get(i)));
-        ret->append(tmp);   
-        if (tmp) { delete tmp; tmp = NULL; }
-    }
-    return ret;
-}
-
-//
-// TBD
-//
-StringBuffer* Formatter::getCTCap(CTCap* ctCap) {
-    
-    if (!ctCap)
-        return NULL;
-    
-    StringBuffer* ret = NULL;    
-        
-    return ret;
-}
-
-/**
- * Returns a StringBuffer containing the string representation of the
- * given PropParam
- */
-StringBuffer* Formatter::getPropParam(PropParam* p) {
-    if (p == NULL) {
-        return NULL;
-    }
-
-    StringBuffer s;
-
-    StringBuffer* paramName   = getValue(PARAM_NAME,   p->getParamName()  );
-    StringBuffer* displayName = getValue(DISPLAY_NAME, p->getDisplayName());
-    StringBuffer* dataType    = getValue(DATA_TYPE,    p->getDataType()   );
-
-    //
-    // Val enums
-    //
-    StringBuffer valEnums;
-    ArrayList* enums = p->getValEnums();
-    if (enums) {
-        StringBuffer* t = NULL;
-        for(int i=0; i<enums->size(); ++i) {
-            t = getValue(VAL_ENUM, (BCHAR*)enums->get(i));
-            valEnums.append(t);
-            delete t; t = NULL;
-        }
-    }
-
-    if (NotZeroStringBufferLenght(3, paramName, displayName, dataType)) {
-        s.append(paramName  );
-        s.append(displayName);
-        s.append(dataType   );
-        s.append(valEnums   );
-    }
-    deleteAllStringBuffer(3, &paramName, &displayName, &dataType);
-
-    return getValue(PROP_PARAM, s);
-}
-
-/**
- * Returns a StringBuffer containing the string representation of the
- * given Property
- */
-StringBuffer* Formatter::getProperty(Property* p) {
-    if (p == NULL) {
-        return NULL;
-    }
-
-    StringBuffer s;
-
-    StringBuffer* displayName = getValue(DISPLAY_NAME, p->getDisplayName());
-    StringBuffer* propName    = getValue(PROP_NAME,    p->getPropName()   );
-    StringBuffer* dataType    = getValue(DATA_TYPE,    p->getDataType()   );
-    StringBuffer* maxOccur    = (p->getMaxOccur()>=0) 
-                              ? getValue(MAX_OCCUR, p->getMaxOccur())
-                              : NULL
-                              ;
-                              
-    StringBuffer* maxSize     = (p->getMaxSize() >= 0)
-                              ? getValue(MAX_SIZE, p->getMaxSize())
-                              : NULL
-                              ;
-
-    StringBuffer* truncate    = getValue(NO_TRUNCATE,  p->isNoTruncate()  );
-
-    //
-    // Property parameters
-    //
-    StringBuffer propParams;
-    ArrayList* parameters = p->getPropParams();
-    if (parameters) {
-        StringBuffer* t = NULL;
-        for(int i=0; i<parameters->size(); ++i) {
-            t = getPropParam((PropParam*)parameters->get(i));
-            propParams.append(t);
-            delete t; t = NULL;
-        }
-    }
-
-    //
-    // Val enums
-    //
-    StringBuffer valEnums;
-    ArrayList* enums = p->getValEnums();
-    if (enums) {
-        StringBuffer* t = NULL;
-        for(int i=0; i<enums->size(); ++i) {
-            t = getValue(VAL_ENUM, (BCHAR*)enums->get(i));
-            valEnums.append(t);
-            delete t; t = NULL;
-        }
-    }
-
-    if (NotZeroStringBufferLenght(6, displayName, 
-                                     propName, 
-                                     dataType, 
-                                     maxOccur, 
-                                     maxSize, 
-                                     truncate)) {
-        s.append(displayName);
-        s.append(propName   );
-        s.append(maxSize    );
-        s.append(dataType   );
-        s.append(propParams );
-        s.append(valEnums   );
-        s.append(maxOccur   );        
-        s.append(truncate   );
-    }
-
-    deleteAllStringBuffer(
-        6, 
-        &displayName, 
-        &propName, 
-        &dataType, 
-        &maxOccur, 
-        &maxSize, 
-        &truncate
-    );
-
-    return getValue(PROPERTY, s);
-}
-
-
-/**
- * Returns a StringBuffer containing the string representation of the
- * given Filter
- */
-StringBuffer* Formatter::getFilter(Filter* filter) {
-    if (filter == NULL) {
-        return NULL;
-    }
-
-    StringBuffer s;
-
-    StringBuffer* type   = (filter->getFilterType()) 
-                         ? getValue(FILTER_TYPE, filter->getFilterType())
-                         : new StringBuffer()
-                         ;
-    StringBuffer* meta   = getMeta(filter->getMeta());
-    StringBuffer* record = getItem(filter->getRecord());
-    StringBuffer* field  = getItem(filter->getField());
-
-    if (NotZeroStringBufferLenght(4, type, meta, record, field)) {
-        StringBuffer* ret = NULL;
-
-        s.append(type);
-        s.append(meta);
-        s.append(ret = getValue(RECORD, record)); delete ret; ret = NULL;
-        s.append(ret = getValue(FIELD, field)); delete ret; ret = NULL;
-    }
-
-    deleteAllStringBuffer(4, &type, &meta, &record, &field);
-
-    return getValue(FILTER, s);
-}
+/*
+ * Copyright (C) 2003-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+#include "syncml/formatter/Formatter.h"
+#include "base/Log.h"
+
+#define EMPTY_VALUE  T("__EMPTY__")
+
+/*
+* Returns a StringBuffer giving the tag and the value as long. To use for generic simple value
+*/
+StringBuffer* Formatter::getValue(BCHAR* tagName, long value) {    
+    if (!value)
+        return NULL;
+
+    BCHAR* t1 = new BCHAR[bstrlen(tagName) + 3]; // <  >  0
+    BCHAR* t2 = new BCHAR[bstrlen(tagName) + 5]; // </ > \n 0
+    bsprintf(t1, T("<%s>"), tagName);
+    bsprintf(t2, T("</%s>\n"), tagName);
+
+    StringBuffer* s = new StringBuffer();
+    s->append(t1);       
+    s->append(value);
+    s->append(t2);    
+    safeDel(&t1);
+    safeDel(&t2);
+
+    return s;    
+}
+
+/*
+* Returns a StringBuffer giving the tag and the value as BOOL. If true return only the tag, nothing otherwise
+*/
+StringBuffer* Formatter::getValue(BCHAR* tagName, BOOL value) {    
+    if (!value)
+        return NULL;
+
+    BCHAR* t1 = new BCHAR[bstrlen(tagName) + 3]; // <  >  0
+    BCHAR* t2 = new BCHAR[bstrlen(tagName) + 5]; // </ > \n 0
+    bsprintf(t1, T("<%s>"), tagName);
+    bsprintf(t2, T("</%s>\n"), tagName);
+
+    StringBuffer* s = new StringBuffer();
+    s->append(t1);        
+    s->append(t2);    
+    safeDel(&t1);
+    safeDel(&t2);
+
+    return s;    
+}
+
+
+/*
+* Returns a StringBuffer giving the tag and the value as wchar. To use for generic simple value
+*/
+StringBuffer* Formatter::getValue(BCHAR* tagName, const BCHAR* value) {    
+    return getValue(tagName, (BCHAR*) value);
+}
+
+
+/*
+* Returns a StringBuffer giving the tag and the value as wchar.
+* To use for generic simple value
+*/
+StringBuffer* Formatter::getValue(BCHAR* tagName, BCHAR* value, BCHAR *params) {    
+    if (!value)
+        return NULL;
+
+    BCHAR* t1 = new BCHAR[bstrlen(tagName) + 3 + (params ? 1 + bstrlen(params) : 0)]; // <  >  0
+    BCHAR* t2 = new BCHAR[bstrlen(tagName) + 5]; // </ > \n 0
+    if (params) {
+        bsprintf(t1, T("<%s %s>"), tagName, params);
+    } else {
+        bsprintf(t1, T("<%s>"), tagName);
+    }
+    bsprintf(t2, T("</%s>\n"), tagName);
+
+    StringBuffer* s = new StringBuffer(t1);
+
+    if (bstrcmp(value, EMPTY_VALUE) != 0)
+        s->append(value);
+
+    s->append(t2);
+    
+    safeDel(&t1);
+    safeDel(&t2);
+
+    return s;    
+}
+
+/*
+* Returns a StringBuffer giving the tag and the value as StringBuffer. To use to include other stuffs
+*/
+StringBuffer* Formatter::getValue(BCHAR* tagName, StringBuffer* value) {    
+    if (!value)
+        return NULL;
+
+    BCHAR* t1 = new BCHAR[bstrlen(tagName) + 3]; // <  >  0
+    BCHAR* t2 = new BCHAR[bstrlen(tagName) + 5]; // </ > \n 0
+    bsprintf(t1, T("<%s>"), tagName);
+    bsprintf(t2, T("</%s>\n"), tagName);
+
+    StringBuffer* s = new StringBuffer();
+    s->append(t1);
+    s->append(value);
+    s->append(t2);
+    
+    safeDel(&t1);
+    safeDel(&t2);
+
+    return s;    
+}
+
+
+StringBuffer* Formatter::getSyncML(SyncML* syncML) {
+        
+    StringBuffer*   sBody = NULL;
+    StringBuffer*   sHdr  = NULL;
+    StringBuffer*   sML   = NULL; 
+    
+    if (syncML == NULL) {
+        return NULL;
+    }
+
+    sHdr  = getSyncHdr (syncML->getSyncHdr ());
+    sBody = getSyncBody(syncML->getSyncBody());
+    
+    sML = new StringBuffer(T("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"));
+    sML->append(T("<SyncML>\n"));    
+    sML->append(sHdr);
+    sML->append(sBody);
+    sML->append(T("</SyncML>"));
+    
+    deleteAllStringBuffer(2,&sHdr, &sBody);
+
+    return sML;     
+}
+
+StringBuffer* Formatter::getSyncHdr(SyncHdr* syncHdr) {
+    
+    StringBuffer*   ret = NULL;    
+    StringBuffer*   s = NULL;    
+           
+    StringBuffer* sessionID = NULL;
+    StringBuffer* verDTD    = NULL;
+    StringBuffer* verProto  = NULL;
+    StringBuffer* source    = NULL;
+    StringBuffer* target    = NULL;    
+    StringBuffer* cred      = NULL;
+    StringBuffer* msgID     = NULL;
+    StringBuffer* respURI   = NULL;
+    StringBuffer* meta      = NULL;
+    
+    sessionID = getSessionID(syncHdr->getSessionID());
+    verDTD    = getVerDTD   (syncHdr->getVerDTD());
+    verProto  = getVerProto (syncHdr->getVerProto());
+    source    = getSource   (syncHdr->getSource());
+    target    = getTarget   (syncHdr->getTarget());    
+    cred      = getCred     (syncHdr->getCred());
+    msgID     = getValue    (MSG_ID,  syncHdr->getMsgID(NULL));
+    respURI   = getValue    (RESP_URI, syncHdr->getRespURI(NULL));
+    meta      = getMeta     (syncHdr->getMeta());
+    
+    if (NotZeroStringBufferLenght(9, sessionID, verDTD, verProto, source, target, cred, msgID, respURI, meta)) {
+        s = new StringBuffer();
+        s->append(verDTD);
+        s->append(verProto);
+        s->append(sessionID);
+        s->append(msgID);
+        s->append(target);
+        s->append(source);
+        s->append(respURI);
+        s->append(cred);
+        s->append(meta);        
+    }
+    
+    ret = getValue(SYNC_HDR, s);
+    
+    deleteAllStringBuffer(10, &s, &sessionID, &verDTD, &verProto, &msgID, &respURI, &target, &source, &cred, &meta);
+
+    return ret;
+}
+
+StringBuffer* Formatter::getCred(Cred* cred) {
+     if (!cred)
+        return NULL;
+    
+    StringBuffer* ret  = NULL;
+    StringBuffer* auth = NULL;
+    auth = getAuthentication(cred->getAuthentication());
+            
+    if (auth) { 
+        //ret = new StringBuffer();
+        ret = getValue(CRED, auth);
+    }        
+    deleteStringBuffer(&auth);
+
+    return ret;
+}
+
+StringBuffer* Formatter::getAuthentication(Authentication* auth) {
+    
+    if (!auth)
+        return NULL;
+
+    StringBuffer* ret          = NULL;
+    StringBuffer* data         = NULL;
+    StringBuffer* meta         = NULL;
+    
+    data = getValue(DATA, auth->getData(NULL));
+    meta = getMeta(auth->getMeta());
+    
+    if (NotZeroStringBufferLenght(2, data, meta)) {
+        ret = new StringBuffer();
+        ret->append(meta);
+        ret->append(data);
+    }
+    deleteAllStringBuffer(2, &meta, &data);
+    
+    return ret;
+}
+
+StringBuffer* Formatter::getMeta(Meta* meta) {
+    
+    if (!meta) 
+        return NULL;    
+
+    StringBuffer* ret        = NULL;
+    StringBuffer* metInf     = NULL;    
+    
+    metInf = getMetInf(meta->getMetInf());            
+
+    if (NotZeroStringBufferLenght(1, metInf)) {
+        ret = getValue(META, metInf);  
+    }    
+    deleteStringBuffer(&metInf);    
+
+    return ret;        
+}
+
+StringBuffer* Formatter::getMetInf(MetInf* metInf) {
+    if (!metInf)
+        return NULL;
+
+    StringBuffer* ret       = NULL;    
+    
+    StringBuffer*     format     = NULL;
+    StringBuffer*     type       = NULL;
+    StringBuffer*     mark       = NULL;
+    StringBuffer*     anchor     = NULL;
+    StringBuffer*     version    = NULL;
+    StringBuffer*     nextNonce  = NULL;
+    StringBuffer*     maxMsgSize = NULL;
+    StringBuffer*     maxObjSize = NULL;
+    StringBuffer*     size       = NULL;
+    //ArrayList*   emi        = NULL;
+    StringBuffer*     mem        = NULL; 
+
+    // get all the values
+
+    format       = getValue(FORMAT, metInf->getFormat(NULL), METINFO);
+    type         = getValue(TYPE,   metInf->getType(NULL), METINFO); 
+    mark         = getValue(MARK,   metInf->getMark(NULL));
+    
+    anchor       = getAnchor(metInf->getAnchor());
+    version      = getValue(VERSIONSTR, metInf->getVersion(NULL)); 
+
+    nextNonce    = getNextNonce(metInf->getNextNonce());
+    
+    maxMsgSize   = getValue(MAX_MESSAGE_SIZE, metInf->getMaxMsgSize());
+    maxObjSize   = getValue(MAX_OBJ_SIZE, metInf->getMaxObjSize());
+    size         = getValue(SIZE,         metInf->getSize());             
+        
+    //emi          = getEMI(xml);
+    mem          = getMem(metInf->getMem());    
+    
+    if (NotZeroStringBufferLenght(8, format, type, mark, size, anchor, version, maxMsgSize, maxObjSize)) {
+        ret = new StringBuffer();
+        ret ->append(format);
+        ret ->append(type);
+        ret ->append(mark);
+        ret ->append(size);
+        ret ->append(anchor);
+        ret ->append(version);
+        ret ->append(nextNonce);
+        ret ->append(maxMsgSize);
+        ret ->append(maxObjSize);               
+        ret ->append(mem);               
+    }             
+    deleteAllStringBuffer(10, &format, &type, &mark, &version, &maxMsgSize, &maxObjSize, &size, &nextNonce, &mem, &anchor);
+       
+    return ret;    
+}
+
+StringBuffer* Formatter::getMem(Mem* mem) {    
+    if (!mem)
+        return NULL;
+
+    StringBuffer* ret = new StringBuffer();                
+    StringBuffer* tmp = NULL;
+
+    tmp = getValue(SHARED_MEM, mem->getSharedMem());
+    ret->append(tmp);
+    if (tmp) { delete tmp; tmp = NULL; }
+    
+    tmp = getValue(FREE_MEM,   mem->getFreeMem());
+    ret->append(tmp);
+    if (tmp) { delete tmp; tmp = NULL; }
+
+    tmp = getValue(FREE_ID,    mem->getFreeID());
+    ret->append(tmp);
+    if (tmp) { delete tmp; tmp = NULL; }
+
+    return ret;    
+}
+
+StringBuffer* Formatter::getNextNonce(NextNonce* nextNonce) {    
+    if (!nextNonce)
+        return NULL;
+
+    StringBuffer* ret = new StringBuffer();             
+    ret = getValue(NEXT_NONCE, nextNonce->getValueAsBase64());
+    return ret;    
+}
+
+StringBuffer* Formatter::getAnchor(Anchor* anchor) {    
+    if (!anchor)
+        return NULL;
+
+    StringBuffer* ret = NULL;   
+    StringBuffer* buf = new StringBuffer();   
+    StringBuffer* tmp = NULL;
+
+    tmp = getValue(LAST,  anchor->getLast());
+    buf->append(tmp);
+    if (tmp) { delete tmp; tmp = NULL; }
+    
+    tmp = getValue(NEXT,  anchor->getNext());
+    buf->append(tmp);
+    if (tmp) { delete tmp; tmp = NULL; }
+        
+    ret = getValue(ANCHOR, (BCHAR *)buf->c_str(), METINFO);    
+    
+    if (buf) {delete buf; buf = NULL; }
+    return ret;    
+}
+
+/*
+* Returns a series of 
+*  <Source> ... </Source> 
+*  <Source> ... </Source> 
+*  <Source> ... </Source> 
+* 
+*  use a SourceArray class type
+*/
+StringBuffer* Formatter::getSources(ArrayList* sources) {
+    
+    if (!sources || !NotZeroArrayLenght(1, sources))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+    
+    for (int i = 0; i < sources->size(); i++) {
+        tmp = getSourceArray(((SourceArray*)sources->get(i)));
+        ret->append(tmp);   
+        if (tmp) { delete tmp; tmp = NULL; }
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getSourceArray(SourceArray* sourceArray) {    
+    if (!sourceArray)
+        return NULL;
+
+    StringBuffer* ret = new StringBuffer(); 
+    StringBuffer* s   = new StringBuffer(); 
+    StringBuffer* tmp = NULL;
+    
+    tmp = getValue(LOC_URI,  sourceArray->getSource()->getLocURI());
+    s->append(tmp);
+    if (tmp) { delete tmp; tmp = NULL; }
+
+    tmp = getValue(LOC_NAME, sourceArray->getSource()->getLocName());
+    s->append(tmp);
+    if (tmp) { delete tmp; tmp = NULL; }
+
+    if (NotZeroStringBufferLenght(1, s)) {     
+        ret = getValue(SOURCE, s);    
+    }    
+    
+    deleteAllStringBuffer(1, &s);
+
+    return ret;    
+}
+
+
+StringBuffer* Formatter::getSource(Source* source) {    
+    if (!source)
+        return NULL;
+
+    StringBuffer* ret = new StringBuffer(); 
+    StringBuffer* s   = new StringBuffer(); 
+    StringBuffer* tmp = NULL;
+
+    tmp = getValue(LOC_URI,  source->getLocURI());
+    s->append(tmp);
+    if (tmp) { delete tmp; tmp = NULL; }
+
+    tmp = getValue(LOC_NAME, source->getLocName());
+    s->append(tmp);
+    if (tmp) { delete tmp; tmp = NULL; }
+
+    if (NotZeroStringBufferLenght(1, s)) {     
+        delete ret; ret = NULL;
+        ret = getValue(SOURCE, s);    
+    }    
+    
+    deleteStringBuffer(&s);
+
+    return ret;    
+}
+
+StringBuffer* Formatter::getTarget(Target* target) {    
+    if (!target)
+        return NULL;    
+
+    StringBuffer* ret    = new StringBuffer();
+    StringBuffer* s      = new StringBuffer();
+    StringBuffer* filter = new StringBuffer();
+    StringBuffer* tmp    = NULL;
+    
+    tmp = getValue(LOC_URI,  target->getLocURI());
+    s->append(tmp);
+    if (tmp) { delete tmp; tmp = NULL; }
+    
+    tmp = getValue(LOC_NAME, target->getLocName());
+    s->append(tmp);
+    if (tmp) { delete tmp; tmp = NULL; }
+
+    //
+    // And now the filter (if any)
+    //
+    if (target->getFilter()) {
+        filter = getFilter(target->getFilter());
+        s->append(filter);
+    }
+    
+    if (NotZeroStringBufferLenght(1, s)) {    
+        delete ret; ret = NULL;
+        ret = getValue(TARGET, s);
+        
+    } 
+    
+    deleteAllStringBuffer(2, &s, &filter);
+
+    return ret;    
+}
+
+StringBuffer* Formatter::getSessionID(SessionID* sessionID) {    
+    if (!sessionID)
+        return NULL;
+
+    StringBuffer* s = NULL;
+    s = getValue(SESSION_ID, sessionID->getSessionID(NULL));    
+    return s;    
+}
+
+StringBuffer* Formatter::getVerDTD(VerDTD* verDTD) {    
+    if (!verDTD)
+        return NULL;
+
+    StringBuffer* s = NULL;
+    s = getValue(VER_DTD, verDTD->getValue(NULL));    
+    return s;    
+}
+
+StringBuffer* Formatter::getCmdID(CmdID* cmdID) {    
+    if (!cmdID)
+        return NULL;
+
+    StringBuffer* s = NULL;
+    s = getValue(CMD_ID, cmdID->getCmdID());    
+    return s;    
+}
+
+StringBuffer* Formatter::getVerProto(VerProto* verProto) {    
+    if (!verProto)
+        return NULL;
+
+    StringBuffer* s = NULL;
+    s = getValue(VER_PROTO, verProto->getVersion(NULL));
+    return s;    
+}
+
+/*
+* Used to retrieve the extra command list that are 
+* Exec
+* Alert
+* Get
+* Map
+*/
+StringBuffer* Formatter::getExtraCommandList(ArrayList* commands) {
+    
+    StringBuffer*   s               = NULL;    
+    
+    StringBuffer*   exec            = NULL;
+    StringBuffer*   map             = NULL;
+    StringBuffer*   alert           = NULL;
+    StringBuffer*   get             = NULL;
+    BCHAR*          name            = NULL;
+    StringBuffer*   tmp             = NULL;
+    /*
+    * Use the name of the command to get the proper action to invoke
+    */
+    for (int i = 0; i < commands->size(); i++) {
+        name = ((AbstractCommand*)(commands->get(i)))->getName();    
+        if (name && bstrcmp(name, EXEC) == 0) {
+            if (!exec) {
+                exec = new StringBuffer();
+            }
+            tmp = getExec((Exec*)commands->get(i));
+            exec->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, ALERT) == 0) {
+            if (!alert) {
+                alert = new StringBuffer();
+            }
+            tmp = getAlert((Alert*)commands->get(i));
+            alert->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, GET) == 0) {
+            if (!get) {
+                get = new StringBuffer();
+            }
+            tmp = getGet((Get*)commands->get(i));
+            get->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, MAP) == 0) {
+            if (!map) {
+                map = new StringBuffer();
+            }
+            tmp = getMap((Map*)commands->get(i));
+            map->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        }
+    }    
+
+    if (NotZeroStringBufferLenght(4, exec, map, alert, get)) {
+        s = new StringBuffer();
+        s->append(exec);
+        s->append(map);
+        s->append(alert);
+        s->append(get);        
+    }    
+    deleteAllStringBuffer(4, &exec, &map, &alert, &get);
+    return s;   
+}
+
+
+
+/*
+* Used to retrieve the common command list that are 
+* Add
+* Replace
+* Copy
+* Delete
+*/
+StringBuffer* Formatter::getCommonCommandList(ArrayList* commands) {
+    
+    StringBuffer*   s               = NULL;    
+    
+    StringBuffer*   adds            = NULL;
+    StringBuffer*   dels            = NULL;
+    StringBuffer*   replaces        = NULL;
+    StringBuffer*   copies          = NULL;
+    BCHAR*          name            = NULL;
+    StringBuffer*   tmp             = NULL;
+    /*
+    * Use the name of the command to get the proper action to invoke
+    */
+    for (int i = 0; i < commands->size(); i++) {
+        name = ((AbstractCommand*)(commands->get(i)))->getName();    
+        if (name && bstrcmp(name, COPY) == 0) {
+            if (!copies) {
+                copies = new StringBuffer();
+            }
+            tmp = getCopy((Copy*)commands->get(i));
+            copies->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, ADD) == 0) {
+            if (!adds) {
+                adds = new StringBuffer();
+            }
+            tmp = getAdd((Add*)commands->get(i));
+            adds->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+
+        } else if (name && bstrcmp(name, DEL) == 0) {
+            if (!dels) {
+                dels = new StringBuffer();
+            }
+            tmp = getDelete((Delete*)commands->get(i));
+            dels->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, REPLACE) == 0) {
+            if (!replaces) {
+                replaces = new StringBuffer();
+            }
+            tmp = getReplace((Replace*)commands->get(i));
+            replaces->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        }
+    }    
+
+    if (NotZeroStringBufferLenght(4, copies, adds, replaces, dels)) {
+        s = new StringBuffer();
+        s->append(copies);
+        s->append(adds);
+        s->append(replaces);
+        s->append(dels);        
+    }    
+    deleteAllStringBuffer(4, &copies, &adds, &replaces, &dels);
+    return s;   
+}
+
+/*
+* Used to retrieve a specific command like SYNC or ATOMIC or SEQUENCE
+*/
+StringBuffer* Formatter::getSpecificCommand(ArrayList* commands, BCHAR* commandName) {
+    
+    StringBuffer*   s               = NULL;        
+    StringBuffer*   ret             = NULL;   
+    BCHAR*          name            = NULL;
+    StringBuffer*   tmp             = NULL;
+    /*
+    * Use the name of the command to get the proper action to invoke
+    */
+    for (int i = 0; i < commands->size(); i++) {
+        name = ((AbstractCommand*)(commands->get(i)))->getName();    
+        if (name && bstrcmp(name, SYNC) == 0 && bstrcmp(SYNC, commandName) == 0) {
+            if (!ret) {
+                ret = new StringBuffer();
+            }
+            tmp = getSync((Sync*)commands->get(i));
+            ret->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, ATOMIC) == 0 && bstrcmp(ATOMIC, commandName) == 0) {
+            if (!ret) {
+                ret = new StringBuffer();
+            }
+            tmp = getAtomic((Atomic*)commands->get(i));
+            ret->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, SEQUENCE) == 0 && bstrcmp(SEQUENCE, commandName) == 0) {
+            if (!ret) {
+                ret = new StringBuffer();
+            }
+            tmp = getSequence((Sequence*)commands->get(i));
+            ret->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } 
+    }    
+
+    if (NotZeroStringBufferLenght(1, ret)) {
+        s = new StringBuffer();
+        s->append(ret);        
+    }    
+    deleteAllStringBuffer(1, &ret);
+    
+    return s;   
+}
+
+
+
+StringBuffer* Formatter::getSyncBody(SyncBody* syncBody) {
+       
+    StringBuffer*   ret             = NULL;
+    StringBuffer*   s               = NULL;    
+    ArrayList*      commands        = NULL;
+    BCHAR* name                     = NULL;
+
+    StringBuffer*   alerts          = NULL;
+    StringBuffer*   statusArray     = NULL;    
+    StringBuffer*   sync            = NULL;    
+    StringBuffer*   commonCommandList = NULL;    
+    StringBuffer*   map             = NULL;    
+    StringBuffer*   exec            = NULL;    
+    StringBuffer*   get             = NULL;    
+    StringBuffer*   put             = NULL;    
+    StringBuffer*   results         = NULL;    
+    StringBuffer*   search          = NULL;    
+    StringBuffer*   sequence        = NULL;    
+    StringBuffer*   atomic          = NULL;    
+
+    
+    StringBuffer*   finalMessage    = NULL;
+    
+    commands = syncBody->getCommands();
+    StringBuffer* tmp               = NULL;
+
+    /*
+    * Use the name of the command to get the proper action to invoke
+    */
+    for (int i = 0; i < commands->size(); i++) {
+        name = ((AbstractCommand*)(commands->get(i)))->getName();    
+        if (name && bstrcmp(name, STATUS) == 0) {
+            if (!statusArray) {
+                statusArray = new StringBuffer();
+            }
+            tmp = getStatus((Status*)commands->get(i));
+            statusArray->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, ALERT) == 0) {
+            if (!alerts) {
+                alerts = new StringBuffer();
+            }
+            tmp = getAlert((Alert*)commands->get(i));
+            alerts->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, SYNC) == 0) {
+            if (!sync) {
+                sync = new StringBuffer();
+            }
+            tmp = getSync((Sync*)commands->get(i));
+            sync->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, MAP) == 0) {
+            if (!map) {
+                map = new StringBuffer();
+            }
+            tmp = getMap((Map*)commands->get(i));
+            map->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, EXEC) == 0) {
+            if (!exec) {
+                exec = new StringBuffer();
+            }
+            tmp = getExec((Exec*)commands->get(i));
+            exec->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, GET) == 0) {
+            if (!get) {
+                get = new StringBuffer();
+            }
+            tmp = getGet((Get*)commands->get(i));
+            get->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, RESULTS) == 0) {
+            if (!results) {
+                results = new StringBuffer();
+            }
+            tmp = getResults((Results*)commands->get(i));
+            results->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, PUT) == 0) {
+            if (!put) {
+                put = new StringBuffer();
+            }
+            tmp = getPut((Put*)commands->get(i));
+            put->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, SEARCH) == 0) {
+            if (!search) {
+                search = new StringBuffer();
+            }
+            tmp = getSearch((Search*)commands->get(i));
+            search->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, SEQUENCE) == 0) {
+            if (!sequence) {
+                sequence = new StringBuffer();
+            }
+            tmp = getSequence((Sequence*)commands->get(i));
+            sequence->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        } else if (name && bstrcmp(name, ATOMIC) == 0) {
+            if (!atomic) {
+                atomic = new StringBuffer();
+            }
+            tmp = getAtomic((Atomic*)commands->get(i));
+            atomic->append(tmp);
+            if (tmp) { delete tmp; tmp = NULL; }
+        }  
+        
+    }    
+     //
+    // get the common command copy, add, delete, replace
+    //
+    commonCommandList = getCommonCommandList(commands);
+    
+    finalMessage = getValue(FINAL_MSG, syncBody->getFinalMsg());
+
+    if (finalMessage || NotZeroStringBufferLenght(11, alerts, commonCommandList, statusArray, sync, map, 
+                                                     exec, get, put, results, search, sequence)) {
+        s = new StringBuffer();
+        s->append(statusArray);
+        s->append(alerts);
+        s->append(atomic);
+        s->append(exec);
+        s->append(get);
+        s->append(map);
+        s->append(put);
+        s->append(results);
+        s->append(search);
+        s->append(sequence);
+        s->append(sync);
+        s->append(commonCommandList); 
+        s->append(finalMessage);        
+    }
+    ret = getValue(SYNC_BODY, s);
+    deleteAllStringBuffer(12, &s, &alerts, &finalMessage, &statusArray, &sync, &map, &exec, &get, &put, &results, &search, &sequence);
+
+    return ret;   
+}
+
+StringBuffer* Formatter::getSearch(Search* search) {
+    
+    if (!search)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+
+    StringBuffer* cmdID     = NULL;
+    StringBuffer* cred      = NULL;
+    StringBuffer* meta      = NULL;    
+    StringBuffer* noResp    = NULL;
+    StringBuffer* noResults = NULL;
+    StringBuffer* lang      = NULL;
+    StringBuffer* data      = NULL;
+    StringBuffer* target    = NULL;
+    StringBuffer* sources   = NULL;
+
+    cmdID     = getCmdID   (search->getCmdID());
+    cred      = getCred    (search->getCred());
+    meta      = getMeta    (search->getMeta());    
+    noResp    = getValue   (NO_RESP, search->getNoResp());
+    noResults = getValue   (NO_RESULTS, search->getNoResults());
+    lang      = getValue   (LANG, search->getLang());    
+    data      = getData    (search->getData());    
+    target    = getTarget  (search->getTarget());
+    sources   = getSources (search->getSources());
+
+    if (NotZeroStringBufferLenght(9, cmdID, cred, meta, noResults, noResp, lang, data, target, sources)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(noResp);
+        s->append(noResults);
+        s->append(cred);
+        s->append(target);
+        s->append(sources);
+        s->append(lang);
+        s->append(meta);
+        s->append(data);
+    }
+
+    ret = getValue(SEARCH, s);
+    deleteAllStringBuffer(10, &s, &cred, &cmdID, &meta, &noResults, &noResp, &lang, &data, &target, &sources);
+   
+    return ret;
+}
+
+
+StringBuffer* Formatter::getGet(Get* get) {
+    
+    if (!get)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+
+    StringBuffer* cmdID     = NULL;
+    StringBuffer* cred      = NULL;
+    StringBuffer* meta      = NULL;
+    StringBuffer* items     = NULL;
+    StringBuffer* noResp    = NULL;
+    StringBuffer* lang      = NULL;
+    
+    cmdID     = getCmdID   (get->getCmdID());
+    cred      = getCred    (get->getCred());
+    meta      = getMeta    (get->getMeta());
+    items     = getItems   (get->getItems());    
+    noResp    = getValue   (NO_RESP, get->getNoResp());
+    lang      = getValue   (LANG, get->getNoResp());    
+
+    if (NotZeroStringBufferLenght(6, cmdID, cred, meta, items, noResp, lang)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(noResp);
+        s->append(lang);
+        s->append(cred);
+        s->append(meta);
+        s->append(items);
+    }
+
+    ret = getValue(GET, s);
+    deleteAllStringBuffer(7, &s, &cred, &cmdID, &meta, &items, &noResp, &lang);
+   
+    return ret;
+}
+
+StringBuffer* Formatter::getExec(Exec* exec) {
+    
+    if (!exec)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+    
+    StringBuffer* cmdID     = NULL;
+    StringBuffer* cred      = NULL;
+    StringBuffer* items     = NULL;
+    StringBuffer* noResp    = NULL;
+    
+    cmdID     = getCmdID   (exec->getCmdID());
+    cred      = getCred    (exec->getCred());
+    items     = getItems   (exec->getItems());    
+    noResp    = getValue   (NO_RESP, exec->getNoResp());
+    
+    if (NotZeroStringBufferLenght(4, cmdID, cred, items, noResp)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(noResp);
+        s->append(cred);
+        s->append(items);
+    }
+
+    ret = getValue(EXEC, s);
+    deleteAllStringBuffer(5, &s, &cred, &cmdID, &items, &noResp);
+   
+    return ret;
+}
+
+StringBuffer* Formatter::getMap(Map* map) {
+    
+    if (!map)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+
+    StringBuffer* cmdID     = NULL;
+    StringBuffer* target    = NULL;
+    StringBuffer* source    = NULL;
+    StringBuffer* cred      = NULL;
+    StringBuffer* meta      = NULL;
+    
+    StringBuffer* mapItems  = NULL;
+           
+    cmdID     = getCmdID   (map->getCmdID());
+    cred      = getCred    (map->getCred());
+    meta      = getMeta    (map->getMeta());
+    source    = getSource  (map->getSource());
+    target    = getTarget  (map->getTarget());
+    mapItems  = getMapItems(map->getMapItems());
+
+    if (NotZeroStringBufferLenght(6, cmdID, cred, meta, source, target, mapItems)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(target);
+        s->append(source);
+        s->append(cred);
+        s->append(meta);
+        s->append(mapItems);
+    }
+
+    ret = getValue(MAP, s);
+    deleteAllStringBuffer(7, &s, &cred, &cmdID, &meta, &source, &target, &mapItems);
+   
+    return ret;
+}
+
+/*
+* Returns a series of 
+*  <MapItem> ... </MapItem> 
+*  <MapItem> ... </MapItem> 
+*  <MapItem> ... </MapItem> 
+* 
+*/
+StringBuffer* Formatter::getMapItems(ArrayList* mapItems) {
+    
+    if (!mapItems || !NotZeroArrayLenght(1, mapItems))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+        
+    for (int i = 0; i < mapItems->size(); i++) {
+        tmp = getMapItem(((MapItem*)mapItems->get(i)));
+        ret->append(tmp);   
+        if (tmp) { delete tmp; tmp = NULL; }
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getMapItem(MapItem* mapItem) {
+    
+    if (!mapItem)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+        
+    StringBuffer* target     = NULL;
+    StringBuffer* source      = NULL;
+    
+    target      = getTarget (mapItem->getTarget());
+    source      = getSource (mapItem->getSource());
+    
+    if (NotZeroStringBufferLenght(2, target, source)) {
+        s = new StringBuffer();
+        s->append(target);
+        s->append(source);        
+    }
+
+    ret = getValue(MAP_ITEM, s);
+    deleteAllStringBuffer(2, &s, &target, &source);
+   
+    return ret;
+}
+
+
+StringBuffer* Formatter::getSync(Sync* sync) {
+    
+    if (!sync)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+        
+    StringBuffer* cmdID     = NULL;
+    StringBuffer* cred      = NULL;
+    StringBuffer* meta      = NULL;
+    StringBuffer* noResp    = NULL;
+    StringBuffer* target    = NULL;
+    StringBuffer* source    = NULL;
+    StringBuffer* numberOfChanges    = NULL;
+    StringBuffer* commonCommandList = NULL;
+    
+    StringBuffer* sequence = NULL;
+    StringBuffer* atomic   = NULL;
+    
+
+    cmdID     = getCmdID   (sync->getCmdID());
+    cred      = getCred    (sync->getCred());
+    meta      = getMeta    (sync->getMeta());
+    noResp    = getValue   (NO_RESP, sync->getNoResp());
+    source    = getSource  (sync->getSource());
+    target    = getTarget  (sync->getTarget());
+    numberOfChanges = getValue(NUMBER_OF_CHANGES, sync->getNumberOfChanges());    
+    commonCommandList = getCommonCommandList(sync->getCommands());
+    
+    sequence = getSpecificCommand(sync->getCommands(), SEQUENCE);
+    atomic   = getSpecificCommand(sync->getCommands(), ATOMIC);
+
+    if (NotZeroStringBufferLenght(10, cmdID, cred, meta, source, target, noResp, numberOfChanges, commonCommandList, sequence, atomic)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(noResp);
+        s->append(cred);
+        s->append(target);
+        s->append(source);
+        s->append(meta);
+        s->append(numberOfChanges);
+        s->append(atomic);
+        s->append(commonCommandList);
+        s->append(sequence);
+    }
+
+    ret = getValue(SYNC, s);
+    deleteAllStringBuffer(11, &s, &cred, &cmdID, &meta, &source, &target, &noResp, &numberOfChanges, &commonCommandList, &atomic, &sequence);
+   
+    return ret;
+}
+
+StringBuffer* Formatter::getSequence(Sequence* sequence) {
+    
+    if (!sequence)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+
+    StringBuffer* cmdID     = NULL;
+    StringBuffer* meta      = NULL;
+    StringBuffer* noResp    = NULL;
+    StringBuffer* commonCommandList = NULL;
+    StringBuffer* extraCommandList  = NULL;
+    StringBuffer* sync      = NULL;
+    StringBuffer* atomic      = NULL;
+
+    cmdID     = getCmdID   (sequence->getCmdID());
+    meta      = getMeta    (sequence->getMeta());
+    noResp    = getValue   (NO_RESP, sequence->getNoResp());
+    commonCommandList = getCommonCommandList(sequence->getCommands());    
+    extraCommandList  = getExtraCommandList(sequence->getCommands());
+    sync = getSpecificCommand(sequence->getCommands(), SYNC);
+    atomic = getSpecificCommand(sequence->getCommands(), ATOMIC);
+
+    if (NotZeroStringBufferLenght(7, cmdID, meta, noResp, commonCommandList, extraCommandList, sync, atomic)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(noResp);
+        s->append(meta);
+        s->append(commonCommandList);
+        s->append(extraCommandList);
+        s->append(atomic);
+        s->append(sync);
+        
+    }
+
+    ret = getValue(SEQUENCE, s);
+    deleteAllStringBuffer(8, &s, &cmdID, &meta, &noResp, &commonCommandList, &extraCommandList, &sync, &atomic);
+   
+    return ret;
+}
+
+StringBuffer* Formatter::getAtomic(Atomic* atomic) {
+    
+    if (!atomic)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+    
+    StringBuffer* cmdID     = NULL;
+    StringBuffer* noResp    = NULL;
+    StringBuffer* meta      = NULL;
+    StringBuffer* commonCommandList = NULL;
+    StringBuffer* extraCommandList  = NULL;
+    StringBuffer* sync      = NULL;
+    StringBuffer* sequence  = NULL;
+
+    cmdID     = getCmdID   (atomic->getCmdID());
+    noResp    = getValue   (NO_RESP, atomic->getNoResp());
+    meta      = getMeta    (atomic->getMeta());
+    commonCommandList = getCommonCommandList(atomic->getCommands());    
+    extraCommandList  = getExtraCommandList(atomic->getCommands());
+    sync      = getSpecificCommand(atomic->getCommands(), SYNC);
+    sequence  = getSpecificCommand(atomic->getCommands(), SEQUENCE);
+
+    if (NotZeroStringBufferLenght(7, cmdID, meta, noResp, commonCommandList, extraCommandList, sync, sequence)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(noResp);
+        s->append(meta);
+        s->append(commonCommandList);
+        s->append(extraCommandList);
+        s->append(sync);
+        s->append(sequence);
+
+    }
+
+    ret = getValue(ATOMIC, s);
+    deleteAllStringBuffer(8, &s, &cmdID, &meta, &noResp, &commonCommandList, &extraCommandList, &sync,&sequence);
+   
+    return ret;
+}
+
+
+/*
+* Returns a series of 
+*  <Copy> ... </Copy> 
+*  <Copy> ... </Copy> 
+*  <Copy> ... </Copy> 
+* 
+*/
+StringBuffer* Formatter::getCopies(ArrayList* copies) {
+    
+    if (!copies || !NotZeroArrayLenght(1, copies))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+        
+    for (int i = 0; i < copies->size(); i++) {
+        ret->append(getCopy(((Copy*)copies->get(i))));   
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getCopy(Copy* copy) {
+    
+    if (!copy)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+        
+    StringBuffer* cmdID     = NULL;
+    StringBuffer* cred      = NULL;
+    StringBuffer* meta      = NULL;
+    StringBuffer* items     = NULL;
+    StringBuffer* noResp    = NULL;
+    
+    cmdID     = getCmdID   (copy->getCmdID());
+    cred      = getCred    (copy->getCred());
+    meta      = getMeta    (copy->getMeta());
+    items     = getItems   (copy->getItems());    
+    noResp    = getValue   (NO_RESP, copy->getNoResp());
+    
+    if (NotZeroStringBufferLenght(5, cmdID, cred, meta, items, noResp)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(noResp);
+        s->append(cred);
+        s->append(meta);
+        s->append(items);
+    }
+
+    ret = getValue(COPY, s);
+    deleteAllStringBuffer(6, &s, &cred, &cmdID, &meta, &items, &noResp);
+   
+    return ret;
+}
+
+
+
+/*
+* Returns a series of 
+*  <Replace> ... </Replace> 
+*  <Replace> ... </Replace> 
+*  <Replace> ... </Replace> 
+* 
+*/
+StringBuffer* Formatter::getReplaces(ArrayList* replaces) {
+    
+    if (!replaces || !NotZeroArrayLenght(1, replaces))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+        
+    for (int i = 0; i < replaces->size(); i++) {
+        ret->append(getReplace(((Replace*)replaces->get(i))));   
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getReplace(Replace* replace) {
+    
+    if (!replace)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+
+    StringBuffer* cmdID     = NULL;
+    StringBuffer* cred      = NULL;
+    StringBuffer* meta      = NULL;
+    StringBuffer* items     = NULL;
+    StringBuffer* noResp    = NULL;
+    
+    cmdID     = getCmdID   (replace->getCmdID());
+    cred      = getCred    (replace->getCred());
+    meta      = getMeta    (replace->getMeta());
+    items     = getItems   (replace->getItems());    
+    noResp    = getValue   (NO_RESP, replace->getNoResp());
+    
+    if (NotZeroStringBufferLenght(5, cmdID, cred, meta, items, noResp)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(noResp);
+        s->append(cred);
+        s->append(meta);
+        s->append(items);
+    }
+
+    ret = getValue(REPLACE, s);
+    deleteAllStringBuffer(6, &s, &cred, &cmdID, &meta, &items, &noResp);
+   
+    return ret;
+}
+
+
+/*
+* Returns a series of 
+*  <Delete> ... </Delete> 
+*  <Delete> ... </Delete> 
+*  <Delete> ... </Delete> 
+* 
+*  The root is <SyncBody>
+*/
+StringBuffer* Formatter::getDels(ArrayList* dels) {
+    
+    if (!dels || !NotZeroArrayLenght(1, dels))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+        
+    for (int i = 0; i < dels->size(); i++) {
+        ret->append(getDelete(((Delete*)dels->get(i))));   
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getDelete(Delete* del) {
+    
+    if (!del)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+            
+    StringBuffer* cmdID     = NULL;
+    StringBuffer* cred      = NULL;
+    StringBuffer* meta      = NULL;
+    StringBuffer* items     = NULL;
+    StringBuffer* noResp    = NULL;
+    StringBuffer* archive   = NULL;
+    StringBuffer* sftdel    = NULL;
+    
+    cmdID     = getCmdID   (del->getCmdID());
+    cred      = getCred    (del->getCred());
+    meta      = getMeta    (del->getMeta());
+    items     = getItems   (del->getItems());    
+    noResp    = getValue   (NO_RESP, del->getNoResp());
+    archive   = getValue   (ARCHIVE, del->getArchive());
+    sftdel    = getValue   (SFT_DEL, del->getSftDel());
+    
+    if (NotZeroStringBufferLenght(7, cmdID, cred, meta, items, noResp, sftdel, archive)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(noResp);
+        s->append(archive);
+        s->append(sftdel);
+        s->append(cred);
+        s->append(meta);
+        s->append(items);
+    }
+
+    ret = getValue(DEL, s);
+    deleteAllStringBuffer(8, &s, &cred, &cmdID, &meta, &items, &noResp, &sftdel, &archive);
+   
+    return ret;
+}
+
+
+/*
+* Returns a series of 
+*  <Add> ... </Add> 
+*  <Add> ... </Add> 
+*  <Add> ... </Add> 
+* 
+*  The root is <SyncBody>
+*/
+StringBuffer* Formatter::getAdds(ArrayList* adds) {
+    
+    if (!adds || !NotZeroArrayLenght(1, adds))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+        
+    for (int i = 0; i < adds->size(); i++) {
+        ret->append(getAdd(((Add*)adds->get(i))));   
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getAdd(Add* add) {
+    
+    if (!add)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+    
+    StringBuffer* cmdID     = NULL;
+    StringBuffer* cred      = NULL;
+    StringBuffer* meta      = NULL;
+    StringBuffer* items     = NULL;
+    StringBuffer* noResp    = NULL;
+    
+    cmdID     = getCmdID   (add->getCmdID());
+    cred      = getCred    (add->getCred());
+    meta      = getMeta    (add->getMeta());
+    items     = getItems   (add->getItems());    
+    noResp    = getValue   (NO_RESP, add->getNoResp());
+    
+    if (NotZeroStringBufferLenght(5, cmdID, cred, meta, items, noResp)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(noResp);
+        s->append(cred);
+        s->append(meta);
+        s->append(items);
+    }
+
+    ret = getValue(ADD, s);
+    deleteAllStringBuffer(6, &s, &cred, &cmdID, &meta, &items, &noResp);
+   
+    return ret;
+}
+
+StringBuffer* Formatter::getPut(Put* put) {
+    
+    if (!put)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+
+    StringBuffer*        cmdID  = NULL;
+    StringBuffer*        meta   = NULL;
+    StringBuffer*        items  = NULL;
+    StringBuffer*        cred   = NULL;
+    StringBuffer*        noResp = NULL;
+    StringBuffer*        lang   = NULL;
+
+    cmdID     = getCmdID   (put->getCmdID());
+    noResp    = getValue   (NO_RESP, put->getNoResp());
+    lang      = getValue   (LANG, put->getNoResp());    
+    cred      = getCred    (put->getCred());
+    meta      = getMeta    (put->getMeta());
+    items     = getItems   (put->getItems());        
+
+    if (NotZeroStringBufferLenght(6, cmdID, lang, meta, items, cred, noResp)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(noResp);                        
+        s->append(lang);
+        s->append(cred);
+        s->append(meta);
+        s->append(items);        
+    }
+
+    ret = getValue(PUT, s);
+    deleteAllStringBuffer(7, &s, &cmdID, &items, &cred, &lang, &meta, &noResp);
+   
+    return ret;
+}
+
+StringBuffer* Formatter::getResults(Results* results) {
+    
+    if (!results)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+
+    StringBuffer*        cmdID  = NULL;
+    StringBuffer*        msgRef = NULL;
+    StringBuffer*        cmdRef = NULL;
+    StringBuffer*        meta   = NULL;
+    StringBuffer*        items  = NULL;
+    StringBuffer*        targetRefs  = NULL;
+    StringBuffer*        sourceRefs  = NULL;
+    
+    cmdID     = getCmdID   (results->getCmdID());
+    msgRef    = getValue   (MSG_REF, results->getMsgRef(NULL));
+    cmdRef    = getValue   (CMD_REF, results->getCmdRef(NULL));
+    meta      = getMeta    (results->getMeta());
+    items     = getItems   (results->getItems());        
+    sourceRefs = getSourceRefs(results->getSourceRef());
+    targetRefs = getTargetRefs(results->getTargetRef());    
+    
+    if (NotZeroStringBufferLenght(7, cmdID, msgRef, cmdRef, meta, items, sourceRefs, targetRefs)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(msgRef);
+        s->append(cmdRef);
+        s->append(meta);
+        s->append(targetRefs);        
+        s->append(sourceRefs);
+        s->append(items);        
+    }
+
+    ret = getValue(RESULTS, s);
+    deleteAllStringBuffer(8, &s, &cmdID, &items, &msgRef, &cmdRef, &meta, &sourceRefs, &targetRefs);
+   
+    return ret;
+}
+
+/*
+* Returns a series of 
+*  <Status> ... </Status> 
+*  <Status> ... </Status> 
+*  <Status> ... </Status> 
+* 
+*/
+StringBuffer* Formatter::getStatusArray(ArrayList* statusArray) {
+    
+    if (!statusArray || !NotZeroArrayLenght(1, statusArray))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+    
+    for (int i = 0; i < statusArray->size(); i++) {
+        tmp = getStatus(((Status*)statusArray->get(i)));
+        ret->append(tmp);   
+        if (tmp) { delete tmp; tmp = NULL; }
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getStatus(Status* status) {
+    
+    if (!status)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+    
+    StringBuffer*        cmdID  = NULL;
+    StringBuffer*        msgRef = NULL;
+    StringBuffer*        cmdRef = NULL;
+    StringBuffer*        cmd    = NULL;
+    StringBuffer*        cred   = NULL;
+    StringBuffer*        items  = NULL;
+    StringBuffer*        targetRefs  = NULL;
+    StringBuffer*        sourceRefs  = NULL;
+    StringBuffer*        data        = NULL;
+    StringBuffer*        chal        = NULL;
+    
+    cmdID     = getCmdID   (status->getCmdID());
+    msgRef    = getValue   (MSG_REF, status->getMsgRef(NULL));
+    cmdRef    = getValue   (CMD_REF, status->getCmdRef(NULL));
+    cmd       = getValue   (CMD     , status->getCmd(NULL));
+    items     = getItems   (status->getItems());        
+    cred      = getCred    (status->getCred());
+    sourceRefs = getSourceRefs(status->getSourceRef());
+    targetRefs = getTargetRefs(status->getTargetRef());    
+    chal      = getChal(status->getChal());    
+    data      = getData   (status->getData());    
+        
+    if (NotZeroStringBufferLenght(10, cmdID, msgRef, cmdRef, cmd, cred, data, items, sourceRefs, targetRefs, chal)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(msgRef);
+        s->append(cmdRef);
+        s->append(cmd);
+        s->append(targetRefs);        
+        s->append(sourceRefs);
+        s->append(cred);        
+        s->append(chal);
+        s->append(data);
+        s->append(items);
+    }
+
+    ret = getValue(STATUS, s);
+    deleteAllStringBuffer(11, &s, &cred, &cmdID, &data, &items, &msgRef, &cmdRef, &cmd, &sourceRefs, &targetRefs, &chal);
+   
+    return ret;
+}
+
+StringBuffer* Formatter::getChal(Chal* chal) {
+    if (!chal)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+    
+    StringBuffer* meta     = getMeta   (chal->getMeta());
+    
+    if (NotZeroStringBufferLenght(1, meta)) {
+        s = new StringBuffer();
+        s->append(meta);        
+    }
+
+    ret = getValue(CHAL, s);
+    deleteAllStringBuffer(2, &s, &meta);
+   
+    return ret;
+
+}
+
+/*
+* Returns a series of 
+*  <Alert> ... </Alert> 
+*  <Alert> ... </Alert> 
+*  <Alert> ... </Alert> 
+* 
+*  The root is <SyncBody>
+*/
+StringBuffer* Formatter::getAlerts(ArrayList* alerts) {
+    
+    if (!alerts || !NotZeroArrayLenght(1, alerts))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+    
+    for (int i = 0; i < alerts->size(); i++) {
+        tmp = getAlert(((Alert*)alerts->get(i)));
+        ret->append(tmp);   
+        if (tmp) { delete tmp; tmp = NULL; }
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getAlert(Alert* alert) {
+    
+    if (!alert)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;    
+    
+    StringBuffer* cmdID     = getCmdID   (alert->getCmdID());
+    StringBuffer* cred      = getCred    (alert->getCred());
+    StringBuffer* data      = getValue   (DATA, (long)alert->getData());
+    StringBuffer* items     = getItems   (alert->getItems());    
+    StringBuffer* noResp    = getValue   (NO_RESP, alert->getNoResp());
+    
+    if (NotZeroStringBufferLenght(5, cmdID, cred, data, items, noResp)) {
+        s = new StringBuffer();
+        s->append(cmdID);
+        s->append(noResp);
+        s->append(cred);
+        s->append(data);
+        s->append(items);
+    }
+
+    ret = getValue(ALERT, s);
+    deleteAllStringBuffer(6, &s, &cred, &cmdID, &data, &items, &noResp);
+   
+    return ret;
+}
+
+/*
+* Returns a series of 
+*  <Item> ... </Item> 
+*  <Item> ... </Item> 
+*  <Item> ... </Item> 
+* 
+*/
+StringBuffer* Formatter::getItems(ArrayList* items) {
+    
+    if (!items || !NotZeroArrayLenght(1, items))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+        
+    for (int i = 0; i < items->size(); i++) {
+        tmp = getItem(((Item*)items->get(i)));
+        ret->append(tmp);   
+        if (tmp) { delete tmp; tmp = NULL; }
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getItem(Item* item) {
+    
+    if (!item)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;
+    
+    StringBuffer*      target   = NULL;
+    StringBuffer*      source   = NULL;
+    StringBuffer*      meta     = NULL;
+    StringBuffer*      data     = NULL;
+    StringBuffer*      moreData = NULL;  
+    StringBuffer*      targetParent = NULL;
+    StringBuffer*      sourceParent = NULL;
+
+
+    
+    target    = getTarget   (item->getTarget());
+    source    = getSource   (item->getSource());
+    meta      = getMeta     (item->getMeta());    
+    data      = getData     (item->getData());
+    moreData  = getValue    (MORE_DATA, item->getMoreData());
+    targetParent  = getValue    (TARGET_PARENT, item->getTargetParent());
+    sourceParent  = getValue    (SOURCE_PARENT, item->getSourceParent());
+
+    
+    if (NotZeroStringBufferLenght(7, target, source, targetParent, sourceParent, meta, data, moreData)) {
+        s = new StringBuffer();
+        s->append(target);
+        s->append(source);
+        s->append(targetParent);
+        s->append(sourceParent);
+        s->append(meta);
+        s->append(data);
+        s->append(moreData);
+    }
+
+    ret = getValue(ITEM, s);
+    deleteAllStringBuffer(8, &s, &target, &source, &targetParent, &sourceParent, &meta, &data, &moreData);
+
+    return ret;
+}
+
+StringBuffer* Formatter::getData(Data* data) {
+    
+    if (!data)
+        return NULL;
+    
+    StringBuffer* ret       = NULL;
+    StringBuffer* s         = NULL;
+    BCHAR* simpleData     = NULL;
+
+    if ((simpleData = data->getData(NULL)) != NULL) {        
+        s = new StringBuffer();
+        s->append(simpleData);
+        ret = getValue(DATA, s);     
+    }
+    deleteAllStringBuffer(1, &s);
+    return ret;
+}
+
+StringBuffer* Formatter::getData(ComplexData* data) {
+    
+    if (!data)
+        return NULL;
+    
+    StringBuffer s;
+    
+    StringBuffer* anchor = getAnchor(data->getAnchor());
+    StringBuffer* devInf = getDevInf(data->getDevInf());
+    
+    if ((anchor != NULL && anchor->length() > 0) ||
+        (devInf != NULL && devInf->length() > 0)) {
+        s.append(anchor);
+        s.append(devInf);
+    } else {
+        s.append("<![CDATA[");
+        s.append(data->getData());
+        s.append("]]>");
+    }
+
+    deleteAllStringBuffer(2, &anchor, &devInf);
+
+    //
+    // Now let's process the list of Property (if any)
+    //
+    int nProps = 0;
+    ArrayList* properties = data->getProperties();
+    if (properties) {
+        nProps = properties->size();
+    }
+
+    StringBuffer* t1 = NULL;
+    for (int i=0; i<nProps; ++i) {
+        t1 = getProperty((Property*)properties->get(i));
+        s.append(t1);
+        delete t1; t1 = NULL;
+    }
+    
+    return getValue(DATA, &s);
+}
+
+StringBuffer* Formatter::getDevInf(DevInf* devInf) {
+    
+    if (!devInf)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;
+    
+    StringBuffer* verDTD    = NULL;
+    StringBuffer* man       = NULL;
+    StringBuffer* mod       = NULL;
+    StringBuffer* oem       = NULL;
+    StringBuffer* fwV       = NULL;
+    StringBuffer* swV       = NULL;
+    StringBuffer* hwV       = NULL;
+    StringBuffer* devID     = NULL;
+    StringBuffer* devTyp    = NULL;
+
+    StringBuffer* dataStores= NULL;     //DataStore[]
+    StringBuffer* ctCaps    = NULL;     // CTCap[]
+    StringBuffer* exts      = NULL;         // Ext[]
+
+    StringBuffer* utc                    = NULL;
+    StringBuffer* supportLargeObjs       = NULL;
+    StringBuffer* supportNumberOfChanges = NULL;      
+
+    StringBuffer* syncCap   = NULL;
+
+    verDTD  = getVerDTD   (devInf->getVerDTD());        
+    man     = getValue    (MAN, devInf->getMan(NULL));
+    mod     = getValue    (MOD, devInf->getMod(NULL));
+    oem     = getValue    (OEM, devInf->getOEM(NULL));
+    fwV     = getValue    (FWV, devInf->getFwV(NULL));
+    swV     = getValue    (SWV, devInf->getSwV(NULL));
+    hwV     = getValue    (HWV, devInf->getHwV(NULL));
+    devID   = getValue    (DEV_ID, devInf->getDevID(NULL));
+    devTyp  = getValue    (DEV_TYP, devInf->getDevTyp(NULL));
+    dataStores = getDataStores(devInf->getDataStore());
+    syncCap    = getSyncCap(devInf->getSyncCap());
+    ctCaps     = getCTCaps(devInf->getCTCap());
+    exts       = getExts(devInf->getExt());
+
+    utc                     = getValue    (UTC, devInf->getUTC());
+    supportLargeObjs        = getValue    (SUPPORT_LARGE_OBJECT, devInf->getSupportLargeObjs());
+    supportNumberOfChanges  = getValue    (SUPPORT_NUMBER_OF_CHANGES, devInf->getSupportNumberOfChanges());
+
+    if (NotZeroStringBufferLenght(15, verDTD, man, mod, oem, fwV, swV, hwV, devID, devTyp, 
+                                      dataStores, syncCap, ctCaps, utc, supportLargeObjs, supportNumberOfChanges)) {
+        s = new StringBuffer();
+        s->append(verDTD);
+        s->append(man);        
+        s->append(mod);        
+        s->append(oem);        
+        s->append(fwV);        
+        s->append(swV);        
+        s->append(hwV);        
+        s->append(devID);        
+        s->append(devTyp);    
+        s->append(dataStores);
+        s->append(ctCaps);
+        s->append(exts);
+        s->append(syncCap);
+        s->append(utc);    
+        s->append(supportLargeObjs);    
+        s->append(supportNumberOfChanges);            
+    }
+
+    ret = getValue(DEV_INF, s);
+    
+    deleteAllStringBuffer(16, &s, &verDTD, &man, &mod, &oem, &fwV, &swV, &hwV, 
+                              &devID, &devTyp, &dataStores, &ctCaps, &exts, &utc, 
+                              &supportLargeObjs, &supportNumberOfChanges);
+
+    return ret;
+}
+
+/*
+* Returns a series of 
+*  <Ext> ... </Ext> 
+*  <Ext> ... </Ext> 
+*  <Ext> ... </Ext> 
+* 
+*/
+StringBuffer* Formatter::getExts(ArrayList* exts) {
+    
+    if (!exts || !NotZeroArrayLenght(1, exts))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+        
+    for (int i = 0; i < exts->size(); i++) {
+        tmp = getExt(((Ext*)exts->get(i)));
+        ret->append(tmp);   
+        if (tmp) { delete tmp; tmp = NULL; }
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getExt(Ext* ext) {
+    
+    if (!ext)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;
+       
+    StringBuffer*  xNam    = NULL;
+    StringBuffer*  xVals   = NULL;
+    
+    xNam  = getValue (XNAM, ext->getXNam(NULL));
+    xVals = getXVals (ext->getXVal());
+    
+    if (NotZeroStringBufferLenght(2, xNam, xVals)) {
+        s = new StringBuffer();
+        s->append(xNam);
+        s->append(xVals);
+    }
+
+    ret = getValue(EXT, s);
+    deleteAllStringBuffer(3, &s, &xNam, &xVals);
+
+    return ret;
+}
+
+
+/*
+* Returns a series of 
+*  <XVal> ... </XVal> 
+*  <XVal> ... </XVal> 
+*  <XVal> ... </XVal> 
+* 
+*/
+StringBuffer* Formatter::getXVals(ArrayList* xVals) {
+    
+    if (!xVals || !NotZeroArrayLenght(1, xVals))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+        
+    for (int i = 0; i < xVals->size(); i++) {
+        tmp = getXVal(((StringElement*)xVals->get(i)));
+        ret->append(tmp);   
+        if (tmp) { delete tmp; tmp = NULL; }
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getXVal(StringElement* xVal) {
+    
+    if (!xVal)
+        return NULL;
+    
+    StringBuffer* ret = NULL;               
+    ret  = getValue (XVAL, xVal->getValue(NULL));               
+    return ret;
+}
+
+
+/*
+* Returns a series of 
+*  <DataStore> ... </DataStore> 
+*  <DataStore> ... </DataStore> 
+*  <DataStore> ... </DataStore> 
+* 
+*/
+StringBuffer* Formatter::getDataStores(ArrayList* dataStores) {
+    
+    if (!dataStores || !NotZeroArrayLenght(1, dataStores))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+        
+    for (int i = 0; i < dataStores->size(); i++) {
+        tmp = getDataStore(((DataStore*)dataStores->get(i)));
+        ret->append(tmp);   
+        if (tmp) { delete tmp; tmp = NULL; }
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getDataStore(DataStore* dataStore) {
+    
+    if (!dataStore)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;
+    
+    StringBuffer*    sourceRef      = NULL;
+    StringBuffer*    displayName    = NULL;
+    StringBuffer*    maxGUIDSize    = NULL;
+    StringBuffer*    rxPref         = NULL;
+    StringBuffer*    rx             = NULL; // ContentTypeInfo[]
+    StringBuffer*    txPref         = NULL;
+    StringBuffer*    tx             = NULL; // ContentTypeInfo[]
+    StringBuffer*    dsMem          = NULL;
+    StringBuffer*    syncCap        = NULL;  
+    
+    sourceRef   = getSourceRef(dataStore->getSourceRef());
+    displayName = getValue(DISPLAY_NAME, dataStore->getDisplayName(NULL));
+    maxGUIDSize = getValue(MAX_GUID_SIZE, dataStore->getMaxGUIDSize());
+    rxPref      = getContentTypeInfo(dataStore->getRxPref(), RX_PREF);
+    rx          = getContentTypeInfos(dataStore->getRx(), RX);
+    txPref      = getContentTypeInfo(dataStore->getTxPref(), TX_PREF);
+    tx          = getContentTypeInfos(dataStore->getTx(), TX);
+    dsMem       = getDSMem(dataStore->getDSMem());
+    syncCap     = getSyncCap(dataStore->getSyncCap());
+
+    if (NotZeroStringBufferLenght(9, sourceRef, displayName, maxGUIDSize, rxPref, rx, txPref, tx, dsMem, syncCap)) {
+        s = new StringBuffer();
+        s->append(sourceRef);
+        s->append(displayName);
+        s->append(maxGUIDSize);
+        s->append(rxPref);
+        s->append(rx);
+        s->append(txPref);
+        s->append(tx);
+        s->append(dsMem);
+        s->append(syncCap);
+    }
+
+    ret = getValue(DATA_STORE, s);
+    deleteAllStringBuffer(10, &s, &sourceRef  ,&displayName, &maxGUIDSize, &rxPref, &rx, &txPref, &tx, &dsMem, &syncCap);
+
+    return ret;
+}
+
+StringBuffer* Formatter::getSyncCap(SyncCap* syncCap) {
+    
+    if (!syncCap)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;
+
+    StringBuffer* syncTypes   = NULL;
+    
+    syncTypes   = getSyncTypes(syncCap->getSyncType());
+    
+    if (NotZeroStringBufferLenght(1, syncTypes)) {
+        s = new StringBuffer();
+        s->append(syncTypes);        
+    }
+
+    ret = getValue(SYNC_CAP, s);
+    deleteAllStringBuffer(2, &s, &syncTypes);
+
+    return ret;
+}
+
+StringBuffer* Formatter::getSyncTypes(ArrayList* syncTypes) {
+    
+    if (!syncTypes || !NotZeroArrayLenght(1, syncTypes))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+        
+    for (int i = 0; i < syncTypes->size(); i++) {
+        tmp = getSyncType(((SyncType*)syncTypes->get(i)));
+        ret->append(tmp);   
+        if (tmp) { delete tmp; tmp = NULL; }
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getSyncType(SyncType* syncType) {
+    
+    if (!syncType)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;       
+    int  value  = -1;
+        
+    value   = syncType->getType();
+    
+    if (value > -1) {
+        s = new StringBuffer();
+        s->append(value);        
+    }
+
+    ret = getValue(SYNC_TYPE, s);
+    deleteAllStringBuffer(1, &s);
+
+    return ret;
+}
+
+
+StringBuffer* Formatter::getDSMem(DSMem* dsMem) {    
+    if (!dsMem)
+        return NULL;
+
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+    
+    tmp = getValue(SHARED_MEM, dsMem->getSharedMem());
+    ret->append(tmp);    
+    if (tmp) { delete tmp; tmp = NULL; }
+
+    tmp = getValue(MAX_MEM,    dsMem->getMaxMem());
+    ret->append(tmp);
+    if (tmp) { delete tmp; tmp = NULL; }
+
+    tmp = getValue(MAX_ID,     dsMem->getMaxID());
+    ret->append(tmp);
+    if (tmp) { delete tmp; tmp = NULL; }
+    
+    return ret;    
+}
+
+
+StringBuffer* Formatter::getContentTypeInfos(ArrayList* contentTypeInfos, BCHAR* TAG) {
+    
+    if (!contentTypeInfos || !NotZeroArrayLenght(1, contentTypeInfos))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+        
+    for (int i = 0; i < contentTypeInfos->size(); i++) {
+        tmp = getContentTypeInfo(((ContentTypeInfo*)contentTypeInfos->get(i)), TAG);
+        ret->append(tmp);   
+        if (tmp) { delete tmp; tmp = NULL; }
+    }
+    return ret;
+}
+
+
+StringBuffer* Formatter::getContentTypeInfo(ContentTypeInfo* contentTypeInfo, BCHAR* TAG) {
+    
+    if (!contentTypeInfo)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;
+       
+    StringBuffer*  ctType  = NULL;
+    StringBuffer*  verCT   = NULL;
+    
+    ctType  = getValue (CT_TYPE, contentTypeInfo->getCTType(NULL));
+    verCT   = getValue (VER_CT, contentTypeInfo->getVerCT(NULL));
+    
+    if (NotZeroStringBufferLenght(2, ctType, verCT)) {
+        s = new StringBuffer();
+        s->append(ctType);
+        s->append(verCT);
+    }
+
+    ret = getValue(TAG, s);
+    deleteAllStringBuffer(3, &s, &ctType, &verCT);
+
+    return ret;
+}
+
+StringBuffer* Formatter::getTargetRefs(ArrayList* targetRefs) {
+    
+    if (!targetRefs || !NotZeroArrayLenght(1, targetRefs))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+        
+    for (int i = 0; i < targetRefs->size(); i++) {
+        tmp = getTargetRef(((TargetRef*)targetRefs->get(i)));
+        ret->append(tmp);   
+        if (tmp) { delete tmp; tmp = NULL; }
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getTargetRef(TargetRef* targetRef) {
+    
+    if (!targetRef)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;
+    
+    BCHAR*       value  = NULL;
+    StringBuffer*  target = NULL;
+    
+    if ((value = (BCHAR*)targetRef->getValue()) != NULL) {
+        ;  // the value value is arleady set.
+    } else {
+        target = getTarget(targetRef->getTarget());
+    }
+
+    if (value || NotZeroStringBufferLenght(1, target)) {
+        s = new StringBuffer();
+        s->append(value);
+        s->append(target);
+    }
+
+    ret = getValue(TARGET_REF, s);
+    deleteAllStringBuffer(2, &s, &target);
+    
+
+    return ret;
+}
+
+
+StringBuffer* Formatter::getSourceRefs(ArrayList* sourceRefs) {
+    
+    if (!sourceRefs || !NotZeroArrayLenght(1, sourceRefs))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+        
+    for (int i = 0; i < sourceRefs->size(); i++) {
+        tmp = getSourceRef(((SourceRef*)sourceRefs->get(i)));
+        ret->append(tmp);   
+        if (tmp) { delete tmp; tmp = NULL; }
+    }
+    return ret;
+}
+
+StringBuffer* Formatter::getSourceRef(SourceRef* sourceRef) {
+    
+    if (!sourceRef)
+        return NULL;
+    
+    StringBuffer* ret = NULL;
+    StringBuffer* s   = NULL;
+    
+    BCHAR*       value  = NULL;
+    StringBuffer*  source = NULL;
+    
+    if ((value = (BCHAR*)sourceRef->getValue()) != NULL) {
+        ;  // the value value is arleady set.
+    } else {
+        source = getSource(sourceRef->getSource());
+    }
+
+    if (value || NotZeroStringBufferLenght(1, source)) {
+        s = new StringBuffer();
+        s->append(value);
+        s->append(source);
+    }
+
+    ret = getValue(SOURCE_REF, s);
+    deleteAllStringBuffer(2, &s, &source);
+    
+
+    return ret;
+}
+
+/*
+* Returns a series of 
+*  <CTCap> ... </CTCap> 
+*  <CTCap> ... </CTCap> 
+*  <CTCap> ... </CTCap> 
+* 
+*/
+StringBuffer* Formatter::getCTCaps(ArrayList* ctCaps) {
+    
+    if (!ctCaps || !NotZeroArrayLenght(1, ctCaps))
+        return NULL;
+    
+    StringBuffer* ret = new StringBuffer();
+    StringBuffer* tmp = NULL;
+        
+    for (int i = 0; i < ctCaps->size(); i++) {
+        tmp = getCTCap(((CTCap*)ctCaps->get(i)));
+        ret->append(tmp);   
+        if (tmp) { delete tmp; tmp = NULL; }
+    }
+    return ret;
+}
+
+//
+// TBD
+//
+StringBuffer* Formatter::getCTCap(CTCap* ctCap) {
+    
+    if (!ctCap)
+        return NULL;
+    
+    StringBuffer* ret = NULL;    
+        
+    return ret;
+}
+
+/**
+ * Returns a StringBuffer containing the string representation of the
+ * given PropParam
+ */
+StringBuffer* Formatter::getPropParam(PropParam* p) {
+    if (p == NULL) {
+        return NULL;
+    }
+
+    StringBuffer s;
+
+    StringBuffer* paramName   = getValue(PARAM_NAME,   p->getParamName()  );
+    StringBuffer* displayName = getValue(DISPLAY_NAME, p->getDisplayName());
+    StringBuffer* dataType    = getValue(DATA_TYPE,    p->getDataType()   );
+
+    //
+    // Val enums
+    //
+    StringBuffer valEnums;
+    ArrayList* enums = p->getValEnums();
+    if (enums) {
+        StringBuffer* t = NULL;
+        for(int i=0; i<enums->size(); ++i) {
+            t = getValue(VAL_ENUM, (BCHAR*)enums->get(i));
+            valEnums.append(t);
+            delete t; t = NULL;
+        }
+    }
+
+    if (NotZeroStringBufferLenght(3, paramName, displayName, dataType)) {
+        s.append(paramName  );
+        s.append(displayName);
+        s.append(dataType   );
+        s.append(valEnums   );
+    }
+    deleteAllStringBuffer(3, &paramName, &displayName, &dataType);
+
+    return getValue(PROP_PARAM, s);
+}
+
+/**
+ * Returns a StringBuffer containing the string representation of the
+ * given Property
+ */
+StringBuffer* Formatter::getProperty(Property* p) {
+    if (p == NULL) {
+        return NULL;
+    }
+
+    StringBuffer s;
+
+    StringBuffer* displayName = getValue(DISPLAY_NAME, p->getDisplayName());
+    StringBuffer* propName    = getValue(PROP_NAME,    p->getPropName()   );
+    StringBuffer* dataType    = getValue(DATA_TYPE,    p->getDataType()   );
+    StringBuffer* maxOccur    = (p->getMaxOccur()>=0) 
+                              ? getValue(MAX_OCCUR, p->getMaxOccur())
+                              : NULL
+                              ;
+                              
+    StringBuffer* maxSize     = (p->getMaxSize() >= 0)
+                              ? getValue(MAX_SIZE, p->getMaxSize())
+                              : NULL
+                              ;
+
+    StringBuffer* truncate    = getValue(NO_TRUNCATE,  p->isNoTruncate()  );
+
+    //
+    // Property parameters
+    //
+    StringBuffer propParams;
+    ArrayList* parameters = p->getPropParams();
+    if (parameters) {
+        StringBuffer* t = NULL;
+        for(int i=0; i<parameters->size(); ++i) {
+            t = getPropParam((PropParam*)parameters->get(i));
+            propParams.append(t);
+            delete t; t = NULL;
+        }
+    }
+
+    //
+    // Val enums
+    //
+    StringBuffer valEnums;
+    ArrayList* enums = p->getValEnums();
+    if (enums) {
+        StringBuffer* t = NULL;
+        for(int i=0; i<enums->size(); ++i) {
+            t = getValue(VAL_ENUM, (BCHAR*)enums->get(i));
+            valEnums.append(t);
+            delete t; t = NULL;
+        }
+    }
+
+    if (NotZeroStringBufferLenght(6, displayName, 
+                                     propName, 
+                                     dataType, 
+                                     maxOccur, 
+                                     maxSize, 
+                                     truncate)) {
+        s.append(displayName);
+        s.append(propName   );
+        s.append(maxSize    );
+        s.append(dataType   );
+        s.append(propParams );
+        s.append(valEnums   );
+        s.append(maxOccur   );        
+        s.append(truncate   );
+    }
+
+    deleteAllStringBuffer(
+        6, 
+        &displayName, 
+        &propName, 
+        &dataType, 
+        &maxOccur, 
+        &maxSize, 
+        &truncate
+    );
+
+    return getValue(PROPERTY, s);
+}
+
+
+/**
+ * Returns a StringBuffer containing the string representation of the
+ * given Filter
+ */
+StringBuffer* Formatter::getFilter(Filter* filter) {
+    if (filter == NULL) {
+        return NULL;
+    }
+
+    StringBuffer s;
+
+    StringBuffer* type   = (filter->getFilterType()) 
+                         ? getValue(FILTER_TYPE, filter->getFilterType())
+                         : new StringBuffer()
+                         ;
+    StringBuffer* meta   = getMeta(filter->getMeta());
+    StringBuffer* record = getItem(filter->getRecord());
+    StringBuffer* field  = getItem(filter->getField());
+
+    if (NotZeroStringBufferLenght(4, type, meta, record, field)) {
+        StringBuffer* ret = NULL;
+
+        s.append(type);
+        s.append(meta);
+        s.append(ret = getValue(RECORD, record)); delete ret; ret = NULL;
+        s.append(ret = getValue(FIELD, field)); delete ret; ret = NULL;
+    }
+
+    deleteAllStringBuffer(4, &type, &meta, &record, &field);
+
+    return getValue(FILTER, s);
+}
--- native/src/include/common/spds/CredentialHandler.h~synthesis
+++ native/src/include/common/spds/CredentialHandler.h
@@ -1,99 +1,101 @@
-/*
- * Copyright (C) 2005-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
- #ifndef INCL_CREDENTIAL_HANDLER
-    #define INCL_CREDENTIAL_HANDLER
-
-    #include "base/fscapi.h"
-    #include "base/constants.h"
-    #include "base/util/utils.h"
-    #include "spds/constants.h"
-    #include "syncml/core/TagNames.h"
-    #include "syncml/core/ObjectDel.h"
-
-    class CredentialHandler{
-
-    private:
-
-        BCHAR* username;
-        BCHAR* password;
-        BCHAR* clientAuthType;
-        BCHAR* clientNonce;
-        
-        BCHAR* serverID;
-        BCHAR* serverPWD;
-        BCHAR* serverAuthType;
-        BCHAR* serverNonce;
-        
-        BOOL isServerAuthRequired;
-
-        /**
-         * Initializes private members
-         */
-        void initialize() EXTRA_SECTION_01;
-        void  generateNonce(char nonce[16]) EXTRA_SECTION_01;
-
-    public:
-        /*
-         * Default constructor
-         */
-        CredentialHandler() EXTRA_SECTION_01;
-
-        ~CredentialHandler() EXTRA_SECTION_01;
-
-        /*
-         * Constructs a new SyncItem identified by the given key. The key must
-         * not be longer than DIM_KEY (see SPDS Constants).
-         *
-         * @param key - the key
-         */
-        CredentialHandler(const BCHAR* key) EXTRA_SECTION_01;
-
-        /*
-         * Returns the SyncItem's key. If key is NULL, the internal buffer is
-         * returned; if key is not NULL, the value is copied in the caller
-         * allocated buffer and the given buffer pointer is returned.
-         *
-         * @param key - buffer where the key will be stored
-         */        
-        
-        void setUsername(const BCHAR* t) EXTRA_SECTION_01;
-        void setPassword(const BCHAR* t) EXTRA_SECTION_01;
-        void setClientAuthType(const BCHAR* t) EXTRA_SECTION_01;
-        void setClientNonce(const BCHAR* t) EXTRA_SECTION_01;
-        const BCHAR* getClientAuthType(BCHAR* t=0 /* deprecated */) EXTRA_SECTION_01;
-        const BCHAR* getClientNonce(BCHAR* t=0 /* deprecated */) EXTRA_SECTION_01;
-
-        void setServerID(const BCHAR* t) EXTRA_SECTION_01;
-        void setServerPWD(const BCHAR* t) EXTRA_SECTION_01;
-        void setServerAuthType(const BCHAR* t) EXTRA_SECTION_01;
-        void setServerNonce(const BCHAR* t) EXTRA_SECTION_01;
-        const BCHAR* getServerAuthType(BCHAR* t=0 /* deprecated */) EXTRA_SECTION_01;
-        const BCHAR* getServerNonce(BCHAR* t=0 /* deprecated */) EXTRA_SECTION_01;
-        
-        void setServerAuthRequired(BOOL t) EXTRA_SECTION_01;
-        BOOL getServerAuthRequired() EXTRA_SECTION_01;
-        
-        Cred* getClientCredential() EXTRA_SECTION_01;
-        Cred* getServerCredential() EXTRA_SECTION_01;
-        Chal* getServerChal(BOOL isServerAuthenticated) EXTRA_SECTION_01;
-        BOOL  performServerAuth(Cred* cred) EXTRA_SECTION_01;
-
-    };
-
-#endif
+/*
+ * Copyright (C) 2005-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+ #ifndef INCL_CREDENTIAL_HANDLER
+    #define INCL_CREDENTIAL_HANDLER
+
+    #include "base/fscapi.h"
+    #include "base/constants.h"
+    #include "base/util/utils.h"
+    #include "spds/constants.h"
+    #include "syncml/core/TagNames.h"
+    #include "syncml/core/ObjectDel.h"
+
+    class CredentialHandler{
+
+    private:
+
+        BCHAR* username;
+        BCHAR* password;
+        BCHAR* clientAuthType;
+        BCHAR* clientNonce;
+        
+        BCHAR* serverID;
+        BCHAR* serverPWD;
+        BCHAR* serverAuthType;
+        BCHAR* serverNonce;
+        
+        BOOL isServerAuthRequired;
+
+        /**
+         * Initializes private members
+         */
+        void initialize() EXTRA_SECTION_01;
+        void  generateNonce(char nonce[16]) EXTRA_SECTION_01;
+
+    public:
+        /*
+         * Default constructor
+         */
+        CredentialHandler() EXTRA_SECTION_01;
+
+        ~CredentialHandler() EXTRA_SECTION_01;
+
+        /*
+         * Constructs a new SyncItem identified by the given key. The key must
+         * not be longer than DIM_KEY (see SPDS Constants).
+         *
+         * @param key - the key
+         */
+        CredentialHandler(const BCHAR* key) EXTRA_SECTION_01;
+
+        /*
+         * Returns the SyncItem's key. If key is NULL, the internal buffer is
+         * returned; if key is not NULL, the value is copied in the caller
+         * allocated buffer and the given buffer pointer is returned.
+         *
+         * @param key - buffer where the key will be stored
+         */        
+        
+        void setUsername(const BCHAR* t) EXTRA_SECTION_01;
+        const BCHAR* getUsername() EXTRA_SECTION_01;
+        void setPassword(const BCHAR* t) EXTRA_SECTION_01;
+        const BCHAR* getPassword() EXTRA_SECTION_01;
+        void setClientAuthType(const BCHAR* t) EXTRA_SECTION_01;
+        void setClientNonce(const BCHAR* t) EXTRA_SECTION_01;
+        const BCHAR* getClientAuthType(BCHAR* t=0 /* deprecated */) EXTRA_SECTION_01;
+        const BCHAR* getClientNonce(BCHAR* t=0 /* deprecated */) EXTRA_SECTION_01;
+
+        void setServerID(const BCHAR* t) EXTRA_SECTION_01;
+        void setServerPWD(const BCHAR* t) EXTRA_SECTION_01;
+        void setServerAuthType(const BCHAR* t) EXTRA_SECTION_01;
+        void setServerNonce(const BCHAR* t) EXTRA_SECTION_01;
+        const BCHAR* getServerAuthType(BCHAR* t=0 /* deprecated */) EXTRA_SECTION_01;
+        const BCHAR* getServerNonce(BCHAR* t=0 /* deprecated */) EXTRA_SECTION_01;
+        
+        void setServerAuthRequired(BOOL t) EXTRA_SECTION_01;
+        BOOL getServerAuthRequired() EXTRA_SECTION_01;
+        
+        Cred* getClientCredential() EXTRA_SECTION_01;
+        Cred* getServerCredential() EXTRA_SECTION_01;
+        Chal* getServerChal(BOOL isServerAuthenticated) EXTRA_SECTION_01;
+        BOOL  performServerAuth(Cred* cred) EXTRA_SECTION_01;
+
+    };
+
+#endif
--- native/src/include/common/spds/SyncManager.h~synthesis
+++ native/src/include/common/spds/SyncManager.h
@@ -1,104 +1,105 @@
-/*
- * Copyright (C) 2003-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef INCL_SYNC_MANAGER
-#define INCL_SYNC_MANAGER
-
-#include "base/util/ArrayList.h"
-#include "http/TransportAgent.h"
-#include "spds/constants.h"
-#include "spds/SyncManagerConfig.h"
-#include "spds/SyncSource.h"
-#include "spds/SyncMLBuilder.h"
-#include "spds/SyncMLProcessor.h"
-#include "spds/CredentialHandler.h"
-#include "spds/CredentialHandler.h"
-
-
-
-typedef enum {
-                STATE_START        = 0,
-                STATE_PKG1_SENDING = 1,
-                STATE_PKG1_SENT    = 2,
-                STATE_PKG3_SENDING = 3,
-                STATE_PKG3_SENT    = 4,
-                STATE_PKG5_SENDING = 5,
-                STATE_PKG5_SENT    = 6
-             } SyncManagerState ;
-
-
-class SyncManager {
-
-    public:
-        SyncManager(SyncManagerConfig* config) EXTRA_SECTION_01;
-        SyncManager(SyncManagerConfig& config) EXTRA_SECTION_01;
-        ~SyncManager() EXTRA_SECTION_01;
-        
-        int prepareSync(SyncSource** sources) EXTRA_SECTION_01;
-        
-        int sync() EXTRA_SECTION_01;
-        
-        int endSync() EXTRA_SECTION_01;
-
-    private:
-
-        // Struct used to pass command info to the method processSyncItem
-        struct CommandInfo {
-            BCHAR* commandName;
-            BCHAR *cmdRef;
-            BCHAR* format;
-            BCHAR* dataType;
-        };
-
-        SyncManagerConfig& config;
-        CredentialHandler credentialHandler;
-        SyncMLBuilder syncMLBuilder;
-        SyncMLProcessor syncMLProcessor;
-        TransportAgent* transportAgent;
-
-        SyncManagerState currentState;
-        SyncSource** sources;
-        ArrayList* commands;
-        ArrayList** mappings;
-
-        int* check;
-        int  sourcesNumber;
-        int  count;
-        
-		ArrayList** allItemsList;
-        
-        BCHAR syncURL [512];
-        BCHAR deviceId[32];  
-        BCHAR userAgent[128];        
-        unsigned int maxMsgSize;    // the max message size. If 0 it is not set
-        unsigned int maxModPerMsg;  // the max modification per message
-        unsigned int readBufferSize; // the size of the buffer to store chunk of incoming stream.
-        BCHAR  credentialInfo[256]; // used to store info for the des;b64 encription
-    
-        void initialize() EXTRA_SECTION_01;
-        BOOL readSyncSourceDefinition(SyncSource& source) EXTRA_SECTION_01;
-        BOOL commitChanges(SyncSource& source) EXTRA_SECTION_01;
-        int assignSources(SyncSource** sources) EXTRA_SECTION_01;
-        
-        Status *processSyncItem(Item* item, const CommandInfo &cmdInfo) EXTRA_SECTION_01;
-        char* processItemContent(const BCHAR* data, const BCHAR* encodings, long* size) EXTRA_SECTION_01;
-        void decodeSyncItemContent(char** c, TransformationInfo& info, const BCHAR* encoding) EXTRA_SECTION_01;
-};
-
-#endif
-
+/*
+ * Copyright (C) 2003-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef INCL_SYNC_MANAGER
+#define INCL_SYNC_MANAGER
+
+#include "base/util/ArrayList.h"
+#include "http/TransportAgent.h"
+#include "spds/constants.h"
+#include "spds/SyncManagerConfig.h"
+#include "spds/SyncSource.h"
+#include "spds/SyncMLBuilder.h"
+#include "spds/SyncMLProcessor.h"
+#include "spds/CredentialHandler.h"
+#include "spds/CredentialHandler.h"
+
+
+
+typedef enum {
+                STATE_START        = 0,
+                STATE_PKG1_SENDING = 1,
+                STATE_PKG1_SENT    = 2,
+                STATE_PKG3_SENDING = 3,
+                STATE_PKG3_SENT    = 4,
+                STATE_PKG5_SENDING = 5,
+                STATE_PKG5_SENT    = 6
+             } SyncManagerState ;
+
+
+class SyncManager {
+
+    public:
+        SyncManager(SyncManagerConfig* config) EXTRA_SECTION_01;
+        SyncManager(SyncManagerConfig& config) EXTRA_SECTION_01;
+        ~SyncManager() EXTRA_SECTION_01;
+        
+        int prepareSync(SyncSource** sources) EXTRA_SECTION_01;
+        
+        int sync() EXTRA_SECTION_01;
+        
+        int endSync() EXTRA_SECTION_01;
+
+    private:
+
+        // Struct used to pass command info to the method processSyncItem
+        struct CommandInfo {
+            BCHAR* commandName;
+            BCHAR *cmdRef;
+            BCHAR* format;
+            BCHAR* dataType;
+        };
+
+        SyncManagerConfig& config;
+        CredentialHandler credentialHandler;
+        SyncMLBuilder syncMLBuilder;
+        SyncMLProcessor syncMLProcessor;
+        TransportAgent* transportAgent;
+
+        SyncManagerState currentState;
+        SyncSource** sources;
+        ArrayList* commands;
+        ArrayList** mappings;
+
+        int* check;
+        int  sourcesNumber;
+        int  count;
+        
+		ArrayList** allItemsList;
+        
+        BCHAR syncURL [512];
+        BCHAR deviceId[32];  
+        BCHAR userAgent[128];        
+        unsigned int maxMsgSize;    // the max message size. If 0 it is not set
+        unsigned int maxModPerMsg;  // the max modification per message
+        unsigned int readBufferSize; // the size of the buffer to store chunk of incoming stream.
+        BCHAR  credentialInfo[256]; // used to store info for the des;b64 encription
+    
+        void initialize() EXTRA_SECTION_01;
+        BOOL readSyncSourceDefinition(SyncSource& source) EXTRA_SECTION_01;
+        BOOL commitChanges(SyncSource& source) EXTRA_SECTION_01;
+        int assignSources(SyncSource** sources) EXTRA_SECTION_01;
+        
+        Status *processSyncItem(Item* item, const CommandInfo &cmdInfo) EXTRA_SECTION_01;
+        char* processItemContent(const BCHAR* data, const BCHAR* encodings, long* size) EXTRA_SECTION_01;
+        void decodeSyncItemContent(char** c, TransformationInfo& info, const BCHAR* encoding) EXTRA_SECTION_01;
+        BOOL checkForServerChanges(SyncML* syncml, ArrayList &statusList) EXTRA_SECTION_01;
+};
+
+#endif
+
--- native/src/include/common/spds/SyncMLBuilder.h~synthesis
+++ native/src/include/common/spds/SyncMLBuilder.h
@@ -58,12 +58,12 @@
         /*
         * Prepare the init SyncML* message with credential and db alert to sync
         */
-        SyncML*  prepareInitObject(Cred* cred, ArrayList* alerts, ArrayList* commands) EXTRA_SECTION_01;
+        SyncML*  prepareInitObject(const BCHAR *username, Cred* cred, ArrayList* alerts, ArrayList* commands) EXTRA_SECTION_01;
         
         /*
         * Prepare the SyncHdr message with credential if not null
         */        
-        SyncHdr* prepareSyncHdr(Cred* cred) EXTRA_SECTION_01;
+        SyncHdr* prepareSyncHdr(Cred* cred, const BCHAR *username = NULL) EXTRA_SECTION_01;
         
         /*
         * Prepare the init alert
--- native/src/include/common/syncml/core/Cred.h~synthesis
+++ native/src/include/common/syncml/core/Cred.h
@@ -1,101 +1,101 @@
-/*
- * Copyright (C) 2005-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#ifndef INCL_CRED
-#define INCL_CRED
-
-#include "base/fscapi.h"
-#include "syncml/core/Authentication.h"
-#include "syncml/core/Constants.h"
-
-class Cred {
-    
-
-     // ------------------------------------------------------------ Private data
-    private:
-
-        Authentication* authentication;        
-    
-    // ---------------------------------------------------------- Protected data    
-    public:
-        
-        Cred();
-        ~Cred();
-        
-        Cred(Authentication* authentication);
-
-        /**
-         * Gets type property
-         *
-         * @return type property
-         */
-        BCHAR* getType(BCHAR* retType);
-
-        /**
-         * Gets format property
-         *
-         * @return format property
-         */
-        BCHAR* getFormat(BCHAR* retFormat);
-
-        /**
-         * Gets data property
-         *
-         * @return data property
-         */
-        BCHAR* getData(BCHAR* retData);
-
-        /**
-         * Gets the username stored in this credential
-         *
-         * @return the username stored in this credential
-         */
-        BCHAR* getUsername(BCHAR* retUsername);
-
-
-        /**
-         * Create and return the Authentication object corresponding to the given
-         * type and data.
-         *
-         * @param type the type of the required Authentication object
-         * @param data the data to be interpreted based on the type
-         *
-         * @return the corresponding Authentication object.
-         */
-        Authentication* createAuthentication(BCHAR* data, BCHAR* type);
-
-        /**
-         * Gets the Authentication object.
-         *
-         * @return authentication the authentication objects
-         */
-        Authentication* getAuthentication();
-
-        /**
-         * Sets the Authentication object.
-         *
-         * @param auth the new Authentication object
-         *
-         */
-        void setAuthentication(Authentication* auth);
-
-        Cred* clone();
-};
-
-#endif
+/*
+ * Copyright (C) 2005-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#ifndef INCL_CRED
+#define INCL_CRED
+
+#include "base/fscapi.h"
+#include "syncml/core/Authentication.h"
+#include "syncml/core/Constants.h"
+
+class Cred {
+    
+
+     // ------------------------------------------------------------ Private data
+    private:
+
+        Authentication* authentication;        
+    
+    // ---------------------------------------------------------- Protected data    
+    public:
+        
+        Cred();
+        ~Cred();
+        
+        Cred(Authentication* authentication);
+
+        /**
+         * Gets type property
+         *
+         * @return type property
+         */
+        BCHAR* getType(BCHAR* retType);
+
+        /**
+         * Gets format property
+         *
+         * @return format property
+         */
+        BCHAR* getFormat(BCHAR* retFormat);
+
+        /**
+         * Gets data property
+         *
+         * @return data property
+         */
+        BCHAR* getData(BCHAR* retData);
+
+        /**
+         * Gets the username stored in this credential
+         *
+         * @return the username stored in this credential
+         */
+        BCHAR* getUsername(BCHAR* retUsername = NULL);
+
+
+        /**
+         * Create and return the Authentication object corresponding to the given
+         * type and data.
+         *
+         * @param type the type of the required Authentication object
+         * @param data the data to be interpreted based on the type
+         *
+         * @return the corresponding Authentication object.
+         */
+        Authentication* createAuthentication(BCHAR* data, BCHAR* type);
+
+        /**
+         * Gets the Authentication object.
+         *
+         * @return authentication the authentication objects
+         */
+        Authentication* getAuthentication();
+
+        /**
+         * Sets the Authentication object.
+         *
+         * @param auth the new Authentication object
+         *
+         */
+        void setAuthentication(Authentication* auth);
+
+        Cred* clone();
+};
+
+#endif
--- native/src/include/common/syncml/core/TagNames.h~synthesis
+++ native/src/include/common/syncml/core/TagNames.h
@@ -1,150 +1,152 @@
-/*
- * Copyright (C) 2003-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#ifndef INCL_TAG_NAMES
-#define INCL_TAG_NAMES
-
-// The class includes the name of the tag that are used into the parser
-
-#include "base/fscapi.h"
-#include "syncml/core/core.h"
-
-#define SYNC_ML             T("SyncML"           )
-#define SYNC_BODY           T("SyncBody"         )
-#define SYNC_HDR            T("SyncHdr"          )
-#define SESSION_ID          T("SessionID"        )
-#define VER_PROTO           T("VerProto"         )
-#define VER_DTD             T("VerDTD"           )
-#define MSG_ID              T("MsgID"            )
-#define RESP_URI            T("RespURI"          )
-#define NO_RESP             T("NoResp"           )
-#define NO_RESULTS          T("NoResults"        )
-#define ARCHIVE             T("Archive"          )
-#define SFT_DEL             T("SftDel"           )
-#define SOURCE              T("Source"           )
-#define TARGET              T("Target"           )
-#define LOC_URI             T("LocURI"           )
-#define LOC_NAME            T("LocName"          )
-#define ANCHOR              T("Anchor"           )
-#define CRED                T("Cred"             )
-#define LAST                T("Last"             )
-#define NEXT                T("Next"             )
-#define NEXT_NONCE          T("NextNonce"        )
-#define FREE_MEM            T("FreeMem"          )
-#define SHARED_MEM          T("SharedMem"        )
-#define FREE_ID             T("FreeID"           )
-#define MAX_MEM             T("MaxMem"           )
-#define MAX_ID              T("MaxID"            )
-#define FORMAT              T("Format"           )
-#define TYPE                T("Type"             )
-#define MARK                T("Mark"             )
-#define VERSIONSTR          T("Version"          )
-#define MAX_MESSAGE_SIZE    T("MaxMsgSize"       )
-#define MAX_OBJ_SIZE        T("MaxObjSize"       )
-#define SIZE                T("Size"             )
-#define VERSIONSTR          T("Version"          )
-#define DATA                T("Data"             )
-#define FINAL_MSG           T("Final"            )
-#define NO_RESP             T("NoResp"           )
-#define CMD_ID              T("CmdID"            )
-#define COMPLEX_DATA        T("Data"             ) 
-#define MORE_DATA           T("MoreData"         )
-#define META                T("Meta"             )
-#define STATUS              T("Status"           )
-#define MSG_REF             T("MsgRef"           )
-#define CMD_REF             T("CmdRef"           )
-#define TARGET_REF          T("TargetRef"        )
-#define SOURCE_REF          T("SourceRef"        )
-#define CHAL                T("Chal"             )
-#define CMD                 T("Cmd"              )
-#define ADD                 T("Add"              )
-#define SYNC                T("Sync"             )
-#define REPLACE             T("Replace"          )
-#define DEL                 T("Delete"           )
-#define MAP                 T("Map"              )
-#define MAP_ITEM            T("MapItem"          )
-#define COPY                T("Copy"             )
-#define ATOMIC              T("Atomic"           )
-#define SEQUENCE            T("Sequence"         )
-#define LANG                T("Lang"             )
-#define GET                 T("Get"              )
-#define PUT                 T("Put"              )
-#define SUPPORT_NUMBER_OF_CHANGES T("SupportNumberOfChanges")
-#define NUMBER_OF_CHANGES   T("NumberOfChanges")
-#define SUPPORT_LARGE_OBJECT T("LargeObject"              )
-#define UTC                 T("Utc"              )
-#define DATA_STORE          T("DataStore"        )
-#define MAN                 T("Man"              )
-#define MOD                 T("Mod"              )
-#define OEM                 T("OEM"              )
-#define FWV                 T("FwV"              )
-#define SWV                 T("SwV"              )
-#define HWV                 T("HwV"              )
-#define DEV_ID              T("DevId"            )
-#define DEV_TYP             T("DevTyp"           )
-#define DEV_INF             T("DevInf"           )
-#define DISPLAY_NAME        T("DisplayName"      )
-#define MAX_GUID_SIZE       T("MaxGUIDSize"      )
-#define RX_PREF             T("Rx-Pref"          )
-#define TX_PREF             T("Tx-Pref"          )
-#define CT_TYPE             T("CTType"           )
-#define VER_CT              T("VerCT"            )
-#define DS_MEM              T("DSMem"            )
-#define SYNC_CAP            T("SyncCap"          )
-#define SYNC_TYPE           T("SyncType"         )
-#define RX                  T("Rx"               )
-#define TX                  T("Tx"               )
-#define CT_CAP              T("CTCap"            )
-#define EXT                 T("Ext"              )
-#define XNAM                T("XNam"             )
-#define XVAL                T("XVal"             )
-#define RESULTS             T("Results"          )
-#define EXEC                T("Exec"             )
-#define SEARCH              T("Search"           )
-#define TARGET_PARENT       T("TargetParent"     )
-#define SOURCE_PARENT       T("SourceParent"     )
-
-
-
-// Commands
-#define ALERT               T("Alert"            )
-#define ITEM                T("Item"             )
-#define FILTER              T("Filter"           )
-#define RECORD              T("Record"           )
-#define FIELD               T("Field"            )
-#define PROPERTY            T("Property"         )
-#define DISPLAY_NAME        T("DisplayName"      )
-#define PROP_NAME           T("PropName"         )
-#define DATA_TYPE           T("DataType"         )
-#define MAX_OCCUR           T("MaxOccur"         )
-#define MAX_SIZE            T("MaxSize"          )
-#define NO_TRUNCATE         T("NoTruncate"       )
-#define PROP_PARAM          T("PropParam"        )
-#define PARAM_NAME          T("ParamName"        )
-#define VAL_ENUM            T("ValEnum"          )
-#define VAL_ENUM            T("ValEnum"          )
-#define FILTER_TYPE         T("FilterType"       )
-
-#endif
-
-
-
-
-
-
+/*
+ * Copyright (C) 2003-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#ifndef INCL_TAG_NAMES
+#define INCL_TAG_NAMES
+
+// The class includes the name of the tag that are used into the parser
+
+#include "base/fscapi.h"
+#include "syncml/core/core.h"
+
+#define SYNC_ML             T("SyncML"           )
+#define SYNC_BODY           T("SyncBody"         )
+#define SYNC_HDR            T("SyncHdr"          )
+#define SESSION_ID          T("SessionID"        )
+#define VER_PROTO           T("VerProto"         )
+#define VER_DTD             T("VerDTD"           )
+#define MSG_ID              T("MsgID"            )
+#define RESP_URI            T("RespURI"          )
+#define NO_RESP             T("NoResp"           )
+#define NO_RESULTS          T("NoResults"        )
+#define ARCHIVE             T("Archive"          )
+#define SFT_DEL             T("SftDel"           )
+#define SOURCE              T("Source"           )
+#define TARGET              T("Target"           )
+#define LOC_URI             T("LocURI"           )
+#define LOC_NAME            T("LocName"          )
+#define ANCHOR              T("Anchor"           )
+#define CRED                T("Cred"             )
+#define LAST                T("Last"             )
+#define NEXT                T("Next"             )
+#define NEXT_NONCE          T("NextNonce"        )
+#define FREE_MEM            T("FreeMem"          )
+#define SHARED_MEM          T("SharedMem"        )
+#define FREE_ID             T("FreeID"           )
+#define MAX_MEM             T("MaxMem"           )
+#define MAX_ID              T("MaxID"            )
+#define FORMAT              T("Format"           )
+#define TYPE                T("Type"             )
+#define MARK                T("Mark"             )
+#define VERSIONSTR          T("Version"          )
+#define MAX_MESSAGE_SIZE    T("MaxMsgSize"       )
+#define MAX_OBJ_SIZE        T("MaxObjSize"       )
+#define SIZE                T("Size"             )
+#define VERSIONSTR          T("Version"          )
+#define DATA                T("Data"             )
+#define FINAL_MSG           T("Final"            )
+#define NO_RESP             T("NoResp"           )
+#define CMD_ID              T("CmdID"            )
+#define COMPLEX_DATA        T("Data"             ) 
+#define MORE_DATA           T("MoreData"         )
+#define META                T("Meta"             )
+#define STATUS              T("Status"           )
+#define MSG_REF             T("MsgRef"           )
+#define CMD_REF             T("CmdRef"           )
+#define TARGET_REF          T("TargetRef"        )
+#define SOURCE_REF          T("SourceRef"        )
+#define CHAL                T("Chal"             )
+#define CMD                 T("Cmd"              )
+#define ADD                 T("Add"              )
+#define SYNC                T("Sync"             )
+#define REPLACE             T("Replace"          )
+#define DEL                 T("Delete"           )
+#define MAP                 T("Map"              )
+#define MAP_ITEM            T("MapItem"          )
+#define COPY                T("Copy"             )
+#define ATOMIC              T("Atomic"           )
+#define SEQUENCE            T("Sequence"         )
+#define LANG                T("Lang"             )
+#define GET                 T("Get"              )
+#define PUT                 T("Put"              )
+#define SUPPORT_NUMBER_OF_CHANGES T("SupportNumberOfChanges")
+#define NUMBER_OF_CHANGES   T("NumberOfChanges")
+#define SUPPORT_LARGE_OBJECT T("LargeObject"              )
+#define UTC                 T("Utc"              )
+#define DATA_STORE          T("DataStore"        )
+#define MAN                 T("Man"              )
+#define MOD                 T("Mod"              )
+#define OEM                 T("OEM"              )
+#define FWV                 T("FwV"              )
+#define SWV                 T("SwV"              )
+#define HWV                 T("HwV"              )
+#define DEV_ID              T("DevId"            )
+#define DEV_TYP             T("DevTyp"           )
+#define DEV_INF             T("DevInf"           )
+#define DISPLAY_NAME        T("DisplayName"      )
+#define MAX_GUID_SIZE       T("MaxGUIDSize"      )
+#define RX_PREF             T("Rx-Pref"          )
+#define TX_PREF             T("Tx-Pref"          )
+#define CT_TYPE             T("CTType"           )
+#define VER_CT              T("VerCT"            )
+#define DS_MEM              T("DSMem"            )
+#define SYNC_CAP            T("SyncCap"          )
+#define SYNC_TYPE           T("SyncType"         )
+#define RX                  T("Rx"               )
+#define TX                  T("Tx"               )
+#define CT_CAP              T("CTCap"            )
+#define EXT                 T("Ext"              )
+#define XNAM                T("XNam"             )
+#define XVAL                T("XVal"             )
+#define RESULTS             T("Results"          )
+#define EXEC                T("Exec"             )
+#define SEARCH              T("Search"           )
+#define TARGET_PARENT       T("TargetParent"     )
+#define SOURCE_PARENT       T("SourceParent"     )
+
+// parameters 
+#define METINFO             T("xmlns='syncml:metinf'")
+
+
+// Commands
+#define ALERT               T("Alert"            )
+#define ITEM                T("Item"             )
+#define FILTER              T("Filter"           )
+#define RECORD              T("Record"           )
+#define FIELD               T("Field"            )
+#define PROPERTY            T("Property"         )
+#define DISPLAY_NAME        T("DisplayName"      )
+#define PROP_NAME           T("PropName"         )
+#define DATA_TYPE           T("DataType"         )
+#define MAX_OCCUR           T("MaxOccur"         )
+#define MAX_SIZE            T("MaxSize"          )
+#define NO_TRUNCATE         T("NoTruncate"       )
+#define PROP_PARAM          T("PropParam"        )
+#define PARAM_NAME          T("ParamName"        )
+#define VAL_ENUM            T("ValEnum"          )
+#define VAL_ENUM            T("ValEnum"          )
+#define FILTER_TYPE         T("FilterType"       )
+
+#endif
+
+
+
+
+
+
--- native/src/include/common/syncml/formatter/Formatter.h~synthesis
+++ native/src/include/common/syncml/formatter/Formatter.h
@@ -1,129 +1,129 @@
-/*
- * Copyright (C) 2005-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#ifndef INCL_FORMATTER
-#define INCL_FORMATTER
-
-#include "base/fscapi.h"
-#include "base/util/utils.h"
-#include "base/util/StringBuffer.h"
-#include "base/util/XMLProcessor.h"
-#include "base/util/ArrayList.h"
-
-#include "syncml/core/TagNames.h"
-#include "syncml/core/ObjectDel.h"
-
-
-
-class Formatter {
-     
-    // ---------------------------------------------------------- Public data    
-    public:
-        
-        static StringBuffer*    getValue            (BCHAR* tagName, BCHAR* value);
-        static StringBuffer*    getValue            (BCHAR* tagName, const BCHAR* value);
-        static StringBuffer*    getValue            (BCHAR* tagName, StringBuffer* value);
-        static StringBuffer*    getValue            (BCHAR* tagName, long value);
-        static StringBuffer*    getValue            (BCHAR* tagName, BOOL value);
-        
-        static StringBuffer*    getSyncML           (SyncML*        syncML);
-        static StringBuffer*    getSyncHdr          (SyncHdr*       syncHdr);
-        static StringBuffer*    getSyncBody         (SyncBody*      syncBody);        
-        static StringBuffer*    getSessionID        (SessionID*     sessionID);
-        static StringBuffer*    getVerDTD           (VerDTD*        verDTD);
-        static StringBuffer*    getVerProto         (VerProto*      verProto);
-        static StringBuffer*    getTarget           (Target*        target);
-        static StringBuffer*    getSource           (Source*        source);
-        static StringBuffer*    getCred             (Cred*          cred);
-        static StringBuffer*    getMeta             (Meta*          meta);
-        static StringBuffer*    getMsgID            (BCHAR*       value);
-        static StringBuffer*    getRespURI          (BCHAR*       value);
-        static StringBuffer*    getAuthentication   (Authentication* auth);
-        static StringBuffer*    getAnchor           (Anchor*        anchor);
-        static StringBuffer*    getMetInf           (MetInf*        metInf);
-        static StringBuffer*    getNextNonce        (NextNonce*     nextNonce);        
-        static StringBuffer*    getMem              (Mem*           mem);        
-        static StringBuffer*    getCmdID            (CmdID*         cmdID);
-        
-        static StringBuffer*    getAlerts           (ArrayList*     alerts);
-        static StringBuffer*    getAlert            (Alert*         alert);
-        static StringBuffer*    getItems            (ArrayList*     items);
-        static StringBuffer*    getItem             (Item*          item);
-
-        static StringBuffer*    getDevInf           (DevInf* devInf);
-        static StringBuffer*    getData             (ComplexData* data);
-        static StringBuffer*    getData             (Data* data);
-        static StringBuffer*    getDataStores       (ArrayList* dataStores);
-        static StringBuffer*    getDataStore        (DataStore* dataStore);
-        static StringBuffer*    getSourceRef        (SourceRef* sourceRef);
-        static StringBuffer*    getTargetRef        (TargetRef* targetRef);
-        static StringBuffer*    getSourceRefs       (ArrayList* sourceRefs);
-        static StringBuffer*    getTargetRefs       (ArrayList* targetRefs);
-        static StringBuffer*    getDSMem            (DSMem* dsMem);
-        static StringBuffer*    getContentTypeInfos (ArrayList* contentTypeInfos, BCHAR* TAG);
-        static StringBuffer*    getContentTypeInfo  (ContentTypeInfo* contentTypeInfo, BCHAR* TAG);
-        static StringBuffer*    getSyncCap          (SyncCap* syncCap);
-        static StringBuffer*    getSyncTypes        (ArrayList* syncTypes);
-        static StringBuffer*    getSyncType         (SyncType* syncType);
-        static StringBuffer*    getCTCaps           (ArrayList* ctCaps);
-        static StringBuffer*    getCTCap            (CTCap* ctCap);
-
-        static StringBuffer*    getExts             (ArrayList* exts);
-        static StringBuffer*    getExt              (Ext* ext);
-        static StringBuffer*    getXVals            (ArrayList* xvals);
-        static StringBuffer*    getXVal             (StringElement* xval);
-        static StringBuffer*    getStatusArray      (ArrayList* statusArray);
-        static StringBuffer*    getStatus           (Status* status);
-        static StringBuffer*    getChal             (Chal* chal);
-        static StringBuffer*    getAdds             (ArrayList* adds);
-        static StringBuffer*    getAdd              (Add* add);
-        static StringBuffer*    getDels             (ArrayList* adds);
-        static StringBuffer*    getDelete           (Delete* add);
-        static StringBuffer*    getReplaces         (ArrayList* replaces);
-        static StringBuffer*    getReplace          (Replace* replace);
-        static StringBuffer*    getCopies           (ArrayList* copies);
-        static StringBuffer*    getCopy             (Copy* copy);
-        static StringBuffer*    getCommonCommandList(ArrayList* commands);        
-        static StringBuffer*    getSync             (Sync* sync);
-        static StringBuffer*    getMapItem          (MapItem* mapItem);
-        static StringBuffer*    getMapItems         (ArrayList* mapItems);
-        static StringBuffer*    getMap              (Map* map);
-        static StringBuffer*    getExec             (Exec* exec);
-        static StringBuffer*    getGet              (Get* get);
-        static StringBuffer*    getPut              (Put* put);
-        static StringBuffer*    getResults          (Results* results);
-        static StringBuffer*    getSearch           (Search* search);
-        static StringBuffer*    getSources          (ArrayList* sources);        
-        static StringBuffer*    getSourceArray      (SourceArray* sourceArray);
-        static StringBuffer*    getExtraCommandList (ArrayList* commands);
-        static StringBuffer*    getSequence         (Sequence* sequence);
-        static StringBuffer*    getSpecificCommand  (ArrayList* commands, BCHAR* commandName);
-        static StringBuffer*    getAtomic           (Atomic* atomic);
-        static StringBuffer*    getFilter           (Filter* filter);
-        static StringBuffer*    getProperty         (Property* property);
-        static StringBuffer*    getPropParam        (PropParam* param);
-
-};
-
-#endif
-
-
-
-
-
+/*
+ * Copyright (C) 2005-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#ifndef INCL_FORMATTER
+#define INCL_FORMATTER
+
+#include "base/fscapi.h"
+#include "base/util/utils.h"
+#include "base/util/StringBuffer.h"
+#include "base/util/XMLProcessor.h"
+#include "base/util/ArrayList.h"
+
+#include "syncml/core/TagNames.h"
+#include "syncml/core/ObjectDel.h"
+
+
+
+class Formatter {
+     
+    // ---------------------------------------------------------- Public data    
+    public:
+        
+        static StringBuffer*    getValue            (BCHAR* tagName, BCHAR* value, BCHAR *params = NULL);
+        static StringBuffer*    getValue            (BCHAR* tagName, const BCHAR* value);
+        static StringBuffer*    getValue            (BCHAR* tagName, StringBuffer* value);
+        static StringBuffer*    getValue            (BCHAR* tagName, long value);
+        static StringBuffer*    getValue            (BCHAR* tagName, BOOL value);
+        
+        static StringBuffer*    getSyncML           (SyncML*        syncML);
+        static StringBuffer*    getSyncHdr          (SyncHdr*       syncHdr);
+        static StringBuffer*    getSyncBody         (SyncBody*      syncBody);        
+        static StringBuffer*    getSessionID        (SessionID*     sessionID);
+        static StringBuffer*    getVerDTD           (VerDTD*        verDTD);
+        static StringBuffer*    getVerProto         (VerProto*      verProto);
+        static StringBuffer*    getTarget           (Target*        target);
+        static StringBuffer*    getSource           (Source*        source);
+        static StringBuffer*    getCred             (Cred*          cred);
+        static StringBuffer*    getMeta             (Meta*          meta);
+        static StringBuffer*    getMsgID            (BCHAR*       value);
+        static StringBuffer*    getRespURI          (BCHAR*       value);
+        static StringBuffer*    getAuthentication   (Authentication* auth);
+        static StringBuffer*    getAnchor           (Anchor*        anchor);
+        static StringBuffer*    getMetInf           (MetInf*        metInf);
+        static StringBuffer*    getNextNonce        (NextNonce*     nextNonce);        
+        static StringBuffer*    getMem              (Mem*           mem);        
+        static StringBuffer*    getCmdID            (CmdID*         cmdID);
+        
+        static StringBuffer*    getAlerts           (ArrayList*     alerts);
+        static StringBuffer*    getAlert            (Alert*         alert);
+        static StringBuffer*    getItems            (ArrayList*     items);
+        static StringBuffer*    getItem             (Item*          item);
+
+        static StringBuffer*    getDevInf           (DevInf* devInf);
+        static StringBuffer*    getData             (ComplexData* data);
+        static StringBuffer*    getData             (Data* data);
+        static StringBuffer*    getDataStores       (ArrayList* dataStores);
+        static StringBuffer*    getDataStore        (DataStore* dataStore);
+        static StringBuffer*    getSourceRef        (SourceRef* sourceRef);
+        static StringBuffer*    getTargetRef        (TargetRef* targetRef);
+        static StringBuffer*    getSourceRefs       (ArrayList* sourceRefs);
+        static StringBuffer*    getTargetRefs       (ArrayList* targetRefs);
+        static StringBuffer*    getDSMem            (DSMem* dsMem);
+        static StringBuffer*    getContentTypeInfos (ArrayList* contentTypeInfos, BCHAR* TAG);
+        static StringBuffer*    getContentTypeInfo  (ContentTypeInfo* contentTypeInfo, BCHAR* TAG);
+        static StringBuffer*    getSyncCap          (SyncCap* syncCap);
+        static StringBuffer*    getSyncTypes        (ArrayList* syncTypes);
+        static StringBuffer*    getSyncType         (SyncType* syncType);
+        static StringBuffer*    getCTCaps           (ArrayList* ctCaps);
+        static StringBuffer*    getCTCap            (CTCap* ctCap);
+
+        static StringBuffer*    getExts             (ArrayList* exts);
+        static StringBuffer*    getExt              (Ext* ext);
+        static StringBuffer*    getXVals            (ArrayList* xvals);
+        static StringBuffer*    getXVal             (StringElement* xval);
+        static StringBuffer*    getStatusArray      (ArrayList* statusArray);
+        static StringBuffer*    getStatus           (Status* status);
+        static StringBuffer*    getChal             (Chal* chal);
+        static StringBuffer*    getAdds             (ArrayList* adds);
+        static StringBuffer*    getAdd              (Add* add);
+        static StringBuffer*    getDels             (ArrayList* adds);
+        static StringBuffer*    getDelete           (Delete* add);
+        static StringBuffer*    getReplaces         (ArrayList* replaces);
+        static StringBuffer*    getReplace          (Replace* replace);
+        static StringBuffer*    getCopies           (ArrayList* copies);
+        static StringBuffer*    getCopy             (Copy* copy);
+        static StringBuffer*    getCommonCommandList(ArrayList* commands);        
+        static StringBuffer*    getSync             (Sync* sync);
+        static StringBuffer*    getMapItem          (MapItem* mapItem);
+        static StringBuffer*    getMapItems         (ArrayList* mapItems);
+        static StringBuffer*    getMap              (Map* map);
+        static StringBuffer*    getExec             (Exec* exec);
+        static StringBuffer*    getGet              (Get* get);
+        static StringBuffer*    getPut              (Put* put);
+        static StringBuffer*    getResults          (Results* results);
+        static StringBuffer*    getSearch           (Search* search);
+        static StringBuffer*    getSources          (ArrayList* sources);        
+        static StringBuffer*    getSourceArray      (SourceArray* sourceArray);
+        static StringBuffer*    getExtraCommandList (ArrayList* commands);
+        static StringBuffer*    getSequence         (Sequence* sequence);
+        static StringBuffer*    getSpecificCommand  (ArrayList* commands, BCHAR* commandName);
+        static StringBuffer*    getAtomic           (Atomic* atomic);
+        static StringBuffer*    getFilter           (Filter* filter);
+        static StringBuffer*    getProperty         (Property* property);
+        static StringBuffer*    getPropParam        (PropParam* param);
+
+};
+
+#endif
+
+
+
+
+
--- native/src/c++/common/syncml/parser/Parser.cpp~synthesis
+++ native/src/c++/common/syncml/parser/Parser.cpp
@@ -1,2535 +1,2532 @@
-/*
- * Copyright (C) 2003-2006 Funambol
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
- 
- 
-#include "syncml/parser/Parser.h"
- 
-SyncML* Parser::getSyncML(BCHAR* xml) {
-    SyncBody* syncBody = NULL;
-    SyncHdr*  syncHdr  = NULL;
-    SyncML*   syncML   = NULL; 
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent(xml, SYNC_HDR, &pos);
-    syncHdr  = getSyncHdr (t);
-    if (t) { delete [] t; t = NULL; }
-    t = XMLProcessor::getElementContent(xml, SYNC_BODY, &pos);
-    syncBody = getSyncBody(t);
-    if (t) { delete [] t; t = NULL; }
-    syncML = new SyncML(syncHdr, syncBody);
-    
-    deleteSyncHdr (&syncHdr);
-    deleteSyncBody(&syncBody);
-    
-    return syncML;
-     
-}
-
-SyncHdr* Parser::getSyncHdr(BCHAR* xml) {
-         
-    SessionID*   sessionID = NULL;
-    VerDTD*      verDTD    = NULL;
-    VerProto*    verProto  = NULL;
-    Source*      source    = NULL;
-    Target*      target    = NULL;
-    Cred*        cred      = NULL;
-    BCHAR*     respURI   = NULL;
-    BCHAR*     msgID     = NULL;
-    BOOL         noResp    = NULL;             
-    BCHAR*     tmp       = NULL;
-    Meta*        meta      = NULL;
-
-    SyncHdr*     ret       = NULL;
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    
-    t = XMLProcessor::getElementContent(xml, SESSION_ID, NULL);
-    sessionID = getSessionID(t);
-    if (t) { delete [] t; t = NULL; }
-    t = XMLProcessor::getElementContent (xml, VER_DTD, NULL);
-    verDTD = getVerDTD(t);
-    if (t) { delete [] t; t = NULL; }
-    t = XMLProcessor::getElementContent (xml, VER_PROTO, NULL);
-    verProto = getVerProto(t);
-    if (t) { delete [] t; t = NULL; }
-    t = XMLProcessor::getElementContent (xml, SOURCE, NULL);
-    source = getSource(t);
-    if (t) { delete [] t; t = NULL; }
-    t = XMLProcessor::getElementContent (xml, TARGET, NULL);
-    target = getTarget(t);    
-    if (t) { delete [] t; t = NULL; }
-    t = XMLProcessor::getElementContent (xml, CRED, NULL);
-    cred = getCred(t);
-    if (t) { delete [] t; t = NULL; }
-    msgID = XMLProcessor::getElementContent(xml, MSG_ID, NULL);
-    respURI = XMLProcessor::getElementContent(xml, RESP_URI, NULL);
-    t = XMLProcessor::getElementContentLevel(xml, META, NULL);
-    meta = getMeta(t);
-    if (t) { delete [] t; t = NULL; }
-    tmp = XMLProcessor::getElementContent(xml, NO_RESP, NULL);
-
-    if (tmp) {
-        wcscmpIgnoreCase(tmp, T("TRUE")) ? noResp = TRUE : noResp = FALSE;            
-    } 
-    ret = new SyncHdr(verDTD, verProto, sessionID, msgID, target, source, respURI, noResp, cred, meta);                
-        
-    deleteVerDTD(&verDTD);
-    deleteVerProto(&verProto);
-    deleteSessionID(&sessionID);
-    deleteSource(&source   );
-    deleteTarget(&target);
-    deleteCred(&cred);
-    deleteMeta(&meta);
-    safeDel(&respURI);
-    safeDel(&msgID);
-    safeDel(&tmp);
-      
-    return ret;    
-}
-
-Cred* Parser::getCred(BCHAR* xml) {
-    Cred* ret              = NULL;
-    Authentication* auth   = NULL;    
-    
-    auth = getAuthentication(xml);
-    if (auth) { 
-        ret = new Cred(auth); 
-    }
-    
-    deleteAuthentication(&auth);
-
-    return ret;
-}
-
-Authentication* Parser::getAuthentication(BCHAR* xml) {
-    Authentication* ret        = NULL;
-    
-    BCHAR* data       = NULL;    
-    Meta*  meta       = NULL;
-    
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-
-    data = XMLProcessor::getElementContent (xml, DATA , NULL);
-    t = XMLProcessor::getElementContentLevel (xml, META , NULL);
-    meta = getMeta(t);
-    if (t) {delete [] t; t = NULL;}
-    if (data || meta) {    
-        ret = new Authentication(meta, data);
-    }
-    safeDel(&data);
-    deleteMeta(&meta);
-    
-    return ret;
-}
-
-Meta* Parser::getMeta(BCHAR* xml) {
-    Meta* ret        = NULL;
-    MetInf* metInf   = NULL;    
-    
-    metInf = getMetInf(xml);            
-    if (metInf) {
-        ret = new Meta();
-        ret->setMetInf(metInf);  
-    }
-    
-    deleteMetInf(&metInf);    
-
-    return ret;
-}
-
-MetInf* Parser::getMetInf(BCHAR* xml) {
-    MetInf* ret             = NULL;
-    
-    BCHAR*     format     = NULL;
-    BCHAR*     type       = NULL;
-    BCHAR*     mark       = NULL;
-    Anchor*      anchor     = NULL;
-    BCHAR*     version    = NULL;
-    NextNonce*   nextNonce  = NULL;
-    long         maxMsgSize = 0;
-    long         maxObjSize = 0;
-    long         size       = 0;
-    ArrayList*   emi        = NULL;
-    Mem*         mem        = NULL; 
-    
-    BCHAR*         maxMsgSizeW   = NULL;
-    BCHAR*         maxObjSizeW   = NULL;
-    BCHAR*         sizeW         = NULL;    
-    
-    // get all the values
-
-    format       = XMLProcessor::getElementContent (xml, FORMAT   , NULL);
-    type         = XMLProcessor::getElementContent (xml, TYPE     , NULL);
-    mark         = XMLProcessor::getElementContent (xml, MARK     , NULL);
-    
-    anchor       = getAnchor(xml);
-    version      = XMLProcessor::getElementContent (xml, VERSIONSTR       , NULL);
-    nextNonce    = getNextNonce(xml);
-    
-    maxMsgSizeW  = XMLProcessor::getElementContent (xml, MAX_MESSAGE_SIZE     , NULL);
-    maxObjSizeW  = XMLProcessor::getElementContent (xml, MAX_OBJ_SIZE     , NULL);
-    sizeW        = XMLProcessor::getElementContent (xml, SIZE             , NULL);
-        
-    if (maxMsgSizeW) {
-        maxMsgSize = bstrtol(maxMsgSizeW, NULL, 10);
-    }
-    if (maxObjSizeW) {
-        maxObjSize = bstrtol(maxObjSizeW, NULL, 10);
-    }
-    if (sizeW) {
-        size = bstrtol(sizeW, NULL, 10);
-    }
-        
-    emi          = getEMI(xml);
-    mem          = getMem(xml);    
-    
-    // check if someting is null, 0 or zero lenght
-    BOOL isToCreate = FALSE;
-    isToCreate = NotNullCheck(7, format, type, mark, version, maxMsgSizeW, maxObjSizeW, sizeW)
-                 || NotZeroArrayLenght(1, emi)
-                 || (mem)
-                 || (anchor) 
-                 || (nextNonce);
-                
-    if (isToCreate) {
-        ret = new MetInf(format, type, mark, size, anchor, version, nextNonce, maxMsgSize,
-                         maxObjSize, emi, mem);
-    }
-    deleteAll(7, &format, &type, &mark, &version, &maxMsgSizeW, &maxObjSizeW, &sizeW);
-       
-    deleteAnchor(&anchor);
-    deleteNextNonce(&nextNonce);
-    deleteArrayList(&emi);    
-    deleteMem(&mem);
-    
-    return ret;    
-}
-
-
-ArrayList* Parser::getSources(BCHAR* xml) {
-    
-    Source* source = NULL; 
-    SourceArray* sourceArray = NULL;
-    unsigned int pos = 0, previous = 0;
-    ArrayList* list = new ArrayList();
-
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent(&xml[pos], SOURCE, &pos);
-    while ((source = getSource(t)) != NULL) {
-        if (source) {
-            sourceArray = new SourceArray(source);
-            list->add(*sourceArray); // in the ArrayList NULL element cannot be inserted
-            deleteSource(&source);            
-            deleteSourceArray(&sourceArray);            
-        }
-        pos += previous;
-        previous = pos;
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContent(&xml[pos], SOURCE, &pos);
-    }
-    if (t) { delete [] t; t = NULL;}
-    return list;    
-}
-
-
-Source* Parser::getSource(BCHAR* xml) {
-    Source* ret      = NULL;
-    BCHAR* locURI  = NULL;
-    BCHAR* locName = NULL;
-    locURI  = XMLProcessor::getElementContent (xml, LOC_URI, NULL);
-    locName = XMLProcessor::getElementContent (xml, LOC_NAME, NULL);
-    
-    if (NotNullCheck(2, locURI, locName)) {
-        ret = new Source(locURI, locName);
-    }
-    
-    safeDel(&locURI);
-    safeDel(&locName);
-    
-    return ret;
-}
-
-Target* Parser::getTarget(BCHAR* xml) {
-    Target*  ret      = NULL;
-    BCHAR* locURI   = NULL;
-    BCHAR* locName  = NULL;
-    
-    locURI  = XMLProcessor::getElementContent (xml, LOC_URI, NULL);
-    locName = XMLProcessor::getElementContent (xml, LOC_NAME, NULL);
-    
-    if (NotNullCheck(2, locURI, locName)) {
-        ret = new Target(locURI, locName);
-    }
-    
-    safeDel(&locURI);
-    safeDel(&locName);
-
-    return ret;
-}
-
-Anchor* Parser::getAnchor(BCHAR* xml) {
-    Anchor*  ret    = NULL;
-    BCHAR* last   = NULL;
-    BCHAR* next   = NULL;
-    
-    last  = XMLProcessor::getElementContent (xml, LAST, NULL);
-    next  = XMLProcessor::getElementContent (xml, NEXT, NULL);
-    
-    if (NotNullCheck(2, last, next)) {
-        ret = new Anchor(last, next);
-    }
-    
-    safeDel(&next);
-    safeDel(&last);
-
-    return ret;   
-}
-
-NextNonce* Parser::getNextNonce(BCHAR* xml) {
-    NextNonce* ret   = NULL;
-    BCHAR* value   = NULL;   
-    
-    value  = XMLProcessor::getElementContent (xml, NEXT_NONCE, NULL);
-
-    if (NotNullCheck(1, value)) {
-
-        ret = new NextNonce(value);        
-    }
-    
-    safeDel(&value);
-    return ret;   
-}
-
-Mem* Parser::getMem(BCHAR* xml) {
-    Mem* ret            = NULL;
-    BCHAR* freeMemW   = NULL;   
-    BCHAR* sharedMemW = NULL;
-    BCHAR* freeIDW    = NULL;
-        
-    BOOL    sharedMem   = NULL;
-    long    freeMem     = 0;
-    long    freeID      = 0;
-    
-    BOOL isToCreate = FALSE;
-
-    freeMemW    = XMLProcessor::getElementContent (xml, FREE_MEM,   NULL);
-    sharedMemW  = XMLProcessor::getElementContent (xml, SHARED_MEM, NULL);
-    freeIDW     = XMLProcessor::getElementContent (xml, FREE_ID,    NULL);
-    
-    isToCreate = NotNullCheck(3, freeMemW, sharedMemW, freeIDW);
-
-    if (freeMemW != NULL) {
-        freeMem = bstrtol(freeMemW, NULL, 10);
-    }
-    if (freeIDW != NULL) {
-        freeID = bstrtol(freeIDW, NULL, 10);
-    } 
-    if (sharedMemW != NULL) {
-        sharedMem = bstrtol(sharedMemW, NULL, 10);
-    }
-    
-    if (isToCreate) {
-        ret = new Mem(sharedMem, freeMem, freeID);
-    }
-
-    safeDel(&freeMemW);
-    safeDel(&freeIDW);
-    safeDel(&sharedMemW);
-
-    return ret;   
-}
-
-
-SessionID* Parser::getSessionID(BCHAR* content) {
-    SessionID* ret = NULL;
-    if (content) {
-        ret = new SessionID(content);
-    }
-    return ret;
-}
-
-VerDTD* Parser::getVerDTD(BCHAR* content) {
-    VerDTD* ret = NULL;
-    if (content) {
-        ret = new VerDTD(content);
-    }
-    return ret;
-}
-
-VerProto* Parser::getVerProto(BCHAR* content) {
-    VerProto* ret = NULL;
-    if (content) {
-        ret = new VerProto(content);
-    }
-    return ret;
-}
-
-SyncBody* Parser::getSyncBody(BCHAR* xml) {
-    
-    SyncBody* syncBody   = NULL;
-    BOOL finalMsg        = FALSE;
-    ArrayList* commands;
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    commands = getCommands(xml);
-    t = XMLProcessor::getElementContent(xml, FINAL_MSG, NULL);
-    finalMsg = getFinalMsg(t);
-    if (t) {delete [] t; t = NULL;}
-    syncBody = new SyncBody(commands, finalMsg);
-    
-    deleteArrayList(&commands);    
-
-    return syncBody;
-}
-
-/*
-* The sequence tag can contains the common commands (Add, Replace, Delete, Copy) and
-* Alert
-* Exec
-* Get
-* Map
-*
-* Atomic
-* Sync
-*/
-Sequence* Parser::getSequence(BCHAR* xml) {    
-
-    Sequence* ret           = NULL;
-        
-    Meta*   meta            = NULL;
-    BOOL    noResp          = NULL;
-    CmdID*  cmdID           = NULL;
-    ArrayList* commands     = new ArrayList(); 
-    Sync* sync              = NULL;
-    Atomic* atomic          = NULL;
-    
-    Alert* alert            = NULL;
-    Map*   map              = NULL;
-    Get*   get              = NULL;
-    Exec* exec              = NULL;
-
-    ArrayList* list     = new ArrayList(); 
-    unsigned int pos = 0, previous = 0;
-
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent(xml, CMD_ID, NULL);
-    cmdID = getCmdID(t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContentLevel (xml,  META  , NULL);
-    meta = getMeta(t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
-    noResp   = getNoResp(t);
-    if (t) {delete [] t; t = NULL;}
-    // list of commands that must not be leaf of Sync and Atomic
-    commands = getCommonCommandList(xml, T("Atomic&Sync"));    
-
-    // Alert
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContentLevel(&xml[pos], ALERT, &pos);
-    while ((alert = getAlert(t)) != NULL) {
-        if (alert) {
-            list->add(*alert); // in the ArrayList NULL element cannot be inserted
-            deleteAlert(&alert);            
-        }
-        pos += previous;
-        previous = pos; 
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentLevel(&xml[pos], ALERT, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            commands->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);
-
-    // Map
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContentLevel(&xml[pos], MAP, &pos);
-    while ((map = getMap(t)) != NULL) {
-        if (map) {
-            list->add(*map); // in the ArrayList NULL element cannot be inserted
-            deleteMap(&map);            
-        }
-        pos += previous;
-        previous = pos;
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentLevel(&xml[pos], MAP, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            commands->add(*list->get(i));
-        }
-    }        
-
-    deleteArrayList(&list);
-    
-    // Get
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContentLevel(&xml[pos], GET, &pos);
-    while ((get = getGet(t)) != NULL) {
-        if (get) {
-            list->add(*get); // in the ArrayList NULL element cannot be inserted
-            deleteGet(&get);            
-        }
-        pos += previous;
-        previous = pos;
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentLevel(&xml[pos], GET, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            commands->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);   
-   
-    // Exec
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContentLevel(&xml[pos], EXEC, &pos);
-    while ((exec = getExec(t)) != NULL) {
-        if (exec) {
-            list->add(*exec); // in the ArrayList NULL element cannot be inserted
-            deleteExec(&exec);            
-        }
-        pos += previous;
-        previous = pos;
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentLevel(&xml[pos], EXEC, &pos);
-    }
-    if(t) {delete [] t; t = NULL;}
-    
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            commands->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);
-
-    BCHAR* element = XMLProcessor::getElementContentLevel (xml,  SYNC, NULL);
-
-    if (element) {       
-        sync = getSync(element);
-        if (sync) {
-            commands->add(*sync);
-            deleteSync(&sync);
-        }
-        safeDel(&element);
-    } 
-
-    element = XMLProcessor::getElementContentLevel (xml,  ATOMIC, NULL);
-
-    if (element) {    
-        atomic = getAtomic(element);
-        if (atomic) {
-            commands->add(*atomic);
-            deleteAtomic(&atomic);
-        }
-        safeDel(&element);
-    } 
-
-
-    if ((cmdID)   || 
-        (meta)    ||
-        NotZeroArrayLenght(1, commands)) {
-        
-        ret = new Sequence(cmdID, noResp, meta, commands);
-    }
-
-    deleteMeta(&meta);    
-    deleteCmdID(&cmdID);
-    deleteArrayList(&commands);
-
-    return ret;
-}
-
-/*
-* The Atomic tag can contains the common commands (Add, Replace, Delete, Copy) and
-* Alert
-* Exec
-* Get
-* Map
-*
-* Atomic
-* Sync
-* Sequence
-*/
-Atomic* Parser::getAtomic(BCHAR* xml) {    
-
-    Atomic* ret             = NULL;
-
-    Meta*   meta            = NULL;
-    BOOL    noResp          = NULL;
-    CmdID*  cmdID           = NULL;
-    ArrayList* commands     = new ArrayList(); 
-    Sync* sync              = NULL;
-    Sequence* sequence      = NULL;
-    BCHAR* element = NULL;
-    
-    Alert* alert            = NULL;
-    Map*   map              = NULL;
-    Get*   get              = NULL;
-    Exec* exec              = NULL;
-
-    ArrayList* list     = new ArrayList(); 
-    unsigned int pos = 0, previous = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent(xml, CMD_ID, NULL);
-    cmdID    = getCmdID(t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContentLevel(xml,  META  , NULL);
-    meta     = getMeta       (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent(xml, NO_RESP, NULL);
-    noResp   = getNoResp(t);
-    if (t) {delete [] t; t = NULL;}
-    // list of commands that must not be leaf of Sync and Atomic
-    commands = getCommonCommandList(xml, T("Sync&Sequence"));
-    
-    // Alert
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContentLevel(&xml[pos], ALERT, &pos);
-    while ((alert = getAlert(t)) != NULL) {
-        if (alert) {
-            list->add(*alert); // in the ArrayList NULL element cannot be inserted
-            deleteAlert(&alert);            
-        }
-        pos += previous;
-        previous = pos;
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentLevel(&xml[pos], ALERT, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            commands->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);
-
-    // Map
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContentLevel(&xml[pos], MAP, &pos);
-    while ((map = getMap(t)) != NULL) {
-        if (map) {
-            list->add(*map); // in the ArrayList NULL element cannot be inserted
-            deleteMap(&map);            
-        }
-        pos += previous;
-        previous = pos; 
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentLevel(&xml[pos], MAP, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            commands->add(*list->get(i));
-        }
-    }        
-
-    deleteArrayList(&list);
-    
-    // Get
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContentLevel(&xml[pos], GET, &pos);
-    while ((get = getGet(t)) != NULL) {
-        if (get) {
-            list->add(*get); // in the ArrayList NULL element cannot be inserted
-            deleteGet(&get);            
-        }
-        pos += previous;
-        previous = pos; 
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentLevel(&xml[pos], GET, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            commands->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);   
-   
-    // Exec
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContentLevel(&xml[pos], EXEC, &pos);
-    while ((exec = getExec(t)) != NULL) {
-        if (exec) {
-            list->add(*exec); // in the ArrayList NULL element cannot be inserted
-            deleteExec(&exec);            
-        }
-        pos += previous;
-        previous = pos;
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentLevel(&xml[pos], EXEC, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            commands->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);
-
-    element = XMLProcessor::getElementContentLevel (xml,  SYNC , NULL);
-    
-    if (element) {
-        sync = getSync(element);
-        if (sync) {
-            commands->add(*sync);
-            deleteSync(&sync);
-        }
-        safeDel(&element);
-    }
-    
-    element = XMLProcessor::getElementContentLevel (xml,  SEQUENCE, NULL);    
-    
-    if (element) {
-        sequence = getSequence(element);
-        if (sequence) {
-            commands->add(*sequence);
-            deleteSequence(&sequence);
-        }
-        safeDel(&element);
-    }    
-
-    //
-    // TBD: Atomic
-    //
-
-
-    if ((cmdID)   || 
-        (meta)    ||
-        NotZeroArrayLenght(1, commands)) {
-        
-        ret = new Atomic(cmdID, noResp, meta, commands);
-    }
-
-    deleteMeta(&meta);    
-    deleteCmdID(&cmdID);
-    deleteArrayList(&commands);
-
-    return ret;
-}
-
-/*
-* Contains the commands that the <sync> tag can have.
-*    Add    
-*    Replace
-*    Delete 
-*    Copy   
-*    Atomic 
-*    Map    
-*    Sync   
-*/
-
-Sync* Parser::getSync(BCHAR* xml) {    
-
-    Sync* ret               = NULL;
-    Sequence* sequence      = NULL;
-    Atomic* atomic          = NULL;
-    Cred*   cred            = NULL;
-    Meta*   meta            = NULL;
-    BOOL    noResp          = NULL;
-    CmdID*  cmdID           = NULL;
-    Target* target          = NULL;
-    Source* source          = NULL;
-    ArrayList* commands     = new ArrayList();   
-    long numberOfChanges    = 0;
-    BCHAR* numberOfChangesW = NULL;
-
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent(xml, CMD_ID,  NULL);
-    cmdID    = getCmdID      (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent(xml, TARGET,  NULL);
-    target   = getTarget     (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent(xml, SOURCE,  NULL);
-    source   = getSource     (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContentLevel (xml,  META  ,NULL);
-    meta     = getMeta       (t);
-    if (t) {delete [] t; t = NULL;}
-    numberOfChangesW = XMLProcessor::getElementContent (xml,  NUMBER_OF_CHANGES ,NULL);
-    if (numberOfChangesW) {
-        numberOfChanges = bstrtol(numberOfChangesW, NULL, 10);
-    }
-
-    t = XMLProcessor::getElementContent (xml, CRED   ,NULL);
-    cred     = getCred       (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
-    noResp   = getNoResp    (t);
-    if (t) {delete [] t; t = NULL;}
-    commands = getCommonCommandList(xml, T("Atomic&Sequence"));
-    
-    BCHAR* element = XMLProcessor::getElementContentExcept(xml,  SEQUENCE, T("Atomic"), NULL);
-    
-    if (element) {
-        sequence = getSequence(element);
-        if (sequence) {
-            commands->add(*sequence);
-            deleteSequence(&sequence);
-        }
-        safeDel(&element);
-    }
-
-    element = XMLProcessor::getElementContentExcept(xml,  ATOMIC, T("Atomic&Sequence"), NULL);
-    
-    if (element) {
-        atomic = getAtomic(element);
-        if (atomic) {
-            commands->add(*atomic);
-            deleteAtomic(&atomic);
-        }
-        safeDel(&element);
-    }
-    
-    if ((cmdID)   || 
-        (cred)    || 
-        (target)  ||
-        (source)  ||
-        (meta)    ||
-        NotZeroArrayLenght(1, commands)) {
-        
-        ret = new Sync(cmdID, noResp, cred, target, source, meta, numberOfChanges, commands);
-    }
-
-    deleteCred(&cred);
-    deleteMeta(&meta);    
-    deleteCmdID(&cmdID);
-    deleteTarget(&target);
-    deleteSource(&source);
-    deleteArrayList(&commands);
-
-    return ret;
-}
-
-ArrayList* Parser::getCommonCommandList(BCHAR* xml, BCHAR* except) {
-
-    ArrayList* commands = new ArrayList();
-    ArrayList* list = new ArrayList();
-
-    //
-    //Delete
-    //    
-    list = getDels(xml, except);   
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            commands->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);  
-
-    //
-    //Add
-    //    
-    list = getAdds(xml, except);
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            commands->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);    
-    
-    //
-    //Replace
-    //    
-    list = getReplaces(xml, except);
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            commands->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);  
-        
-
-    //
-    //Copy
-    //    
-    list = getCopies(xml, except);   
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            commands->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);  
-
-    return commands;
-}
-
-Copy* Parser::getCopy(BCHAR* xml) {
-    Copy* ret = NULL;
-        
-    CmdID*      cmdID   = NULL;
-    BOOL        noResp  = NULL;
-    Cred*       cred    = NULL;
-    Meta*       meta    = NULL;
-    ArrayList*  items   = NULL;
-
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
-    cmdID   = getCmdID     (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContentLevel (xml, META,    NULL);
-    meta    = getMeta      (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
-    cred    = getCred      (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
-    noResp  = getNoResp    (t);
-    if (t) {delete [] t; t = NULL;}
-    items = getItems(xml);
-    
-    if ((cmdID) || 
-        (cred)  || 
-        NotZeroArrayLenght(1, items)                                        
-        )  {
-
-        ret = new Copy(cmdID, noResp, cred, meta, items);
-    }
-    
-    deleteCmdID(&cmdID);
-    deleteMeta(&meta);
-    deleteCred(&cred);
-    deleteArrayList(&items);    
-
-    return ret;
-}
-
-
-Add* Parser::getAdd(BCHAR* xml) {
-    Add* ret = NULL;
-
-    CmdID*      cmdID   = NULL;
-    BOOL        noResp  = NULL;
-    Cred*       cred    = NULL;
-    Meta*       meta    = NULL;
-    ArrayList*  items   = NULL;
-    
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
-    cmdID   = getCmdID     (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContentLevel (xml, META,    NULL);
-    meta    = getMeta      (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
-    cred    = getCred      (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
-    noResp  = getNoResp    (t);
-    if (t) {delete [] t; t = NULL;}
-    items = getItems(xml);
-    
-    if ((cmdID) || 
-        (cred)  || 
-        NotZeroArrayLenght(1, items)                                        
-        )  {
-
-        ret = new Add(cmdID, noResp, cred, meta, items);
-    }
-    
-    deleteCmdID(&cmdID);
-    deleteMeta(&meta);
-    deleteCred(&cred);
-    deleteArrayList(&items);    
-
-    return ret;
-}
-
-Delete* Parser::getDelete(BCHAR* xml) {
-    Delete* ret = NULL;
-       
-    CmdID*      cmdID   = NULL;
-    BOOL        noResp  = NULL;
-    BOOL        archive = NULL;
-    BOOL        sftDel  = NULL;
-    Cred*       cred    = NULL;
-    Meta*       meta    = NULL;
-    ArrayList*  items   = NULL;
-
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
-    cmdID   = getCmdID     (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContentLevel (xml, META,    NULL);
-    meta    = getMeta      (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
-    cred    = getCred      (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
-    noResp  = getNoResp    (t);
-    if (t) {delete [] t; t = NULL;}
-    items = getItems(xml);
-    
-    if ((cmdID) || 
-        (cred)  || 
-        NotZeroArrayLenght(1, items)                                        
-        )  {
-
-        ret = new Delete(cmdID, noResp, archive, sftDel, cred, meta, items);
-    }
-        
-    deleteCmdID(&cmdID);
-    deleteMeta(&meta);
-    deleteCred(&cred);
-    deleteArrayList(&items);    
-
-    return ret;
-}
-
-Replace* Parser::getReplace(BCHAR* xml) {
-    Replace* ret = NULL;
-
-    CmdID*      cmdID   = NULL;
-    BOOL        noResp  = NULL;
-    Cred*       cred    = NULL;
-    Meta*       meta    = NULL;
-    ArrayList*  items   = NULL;
-
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
-    cmdID   = getCmdID     (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContentLevel (xml, META,    NULL);
-    meta    = getMeta      (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
-    cred    = getCred      (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
-    noResp  = getNoResp    (t);
-    if (t) {delete [] t; t = NULL;}
-    items = getItems(xml);
-    
-    if ((cmdID) || 
-        (cred)  || 
-        NotZeroArrayLenght(1, items)                                        
-        )  {
-
-        ret = new Replace(cmdID, noResp, cred, meta, items);
-    }
-        
-    deleteCmdID(&cmdID);
-    deleteMeta(&meta);
-    deleteCred(&cred);
-    deleteArrayList(&items);    
-
-    return ret;
-}
-
-MapItem* Parser::getMapItem(BCHAR* xml) {
-    MapItem* ret = NULL;
-    
-    Target*    target = NULL;
-    Source*    source = NULL;
-    
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent(xml, TARGET,NULL);
-    target   = getTarget(t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent(xml, SOURCE,NULL);
-    source   = getSource(t);
-    
-    if ((target)|| 
-        (source)) {
-
-        ret = new MapItem(target, source);
-    }
-    
-    deleteTarget(&target);
-    deleteSource(&source);
-    
-    return ret;
-}
-
-/*
-* Returns an ArrayList of mapItem command
-*/
-ArrayList* Parser::getMapItems(BCHAR* xml) {
-    
-    MapItem* mapItem = NULL;    
-    unsigned int pos = 0, previous = 0;
-    ArrayList* list = new ArrayList();
-
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent(&xml[pos], MAP_ITEM, &pos);
-    while ((mapItem = getMapItem(t)) != NULL) {
-        if (mapItem) {
-            list->add(*mapItem); // in the ArrayList NULL element cannot be inserted
-            deleteMapItem(&mapItem);            
-        }
-        pos += previous;
-        previous = pos;  
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContent(&xml[pos], MAP_ITEM, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-    return list;   
-}
-
-Map* Parser::getMap(BCHAR* xml) {
-    Map* ret = NULL;
-
-    CmdID*     cmdID  = NULL;
-    Cred*      cred   = NULL;
-    Meta*      meta   = NULL;
-    
-    Target*    target = NULL;
-    Source*    source = NULL;
-    ArrayList* mapItems; //MapItem[]
-    
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
-    cmdID   = getCmdID(t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContentLevel (xml, META,    NULL);
-    meta    = getMeta(t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
-    cred    = getCred(t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent(xml, TARGET,NULL);
-    target   = getTarget(t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent(xml, SOURCE,  NULL);
-    source   = getSource(t);
-    if (t) {delete [] t; t = NULL;}
-    mapItems = getMapItems(xml);
-    
-    if ((cmdID) ||
-        (meta)  ||
-        (cred)  ||
-        (target)|| 
-        (source)|| 
-        NotZeroArrayLenght(1, mapItems)                                        
-        )  {
-
-        ret = new Map(cmdID, target, source, cred, meta, mapItems);
-    }
-    
-    deleteCmdID(&cmdID);
-    deleteMeta(&meta);
-    deleteCred(&cred);
-    deleteTarget(&target);
-    deleteSource(&source);
-    deleteArrayList(&mapItems);    
-
-    return ret;
-}
-
-
-/*
-* Returns an ArrayList of copy command
-*/
-ArrayList* Parser::getCopies(BCHAR* xml, BCHAR* except) {
-    
-    Copy* copy = NULL;    
-    unsigned int pos = 0, previous = 0;
-    ArrayList* list = NULL;
-    
-   /*
-    * except is set to SYNC if we are looking for Copy commands external from <sync> tag
-    */
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContentExcept(&xml[pos], COPY, except, &pos);
-    while ((copy = getCopy(t)) != NULL) {
-        if (copy) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*copy); // in the ArrayList NULL element cannot be inserted
-            deleteCopy(&copy);            
-        }
-        pos += previous;
-        previous = pos; 
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentExcept(&xml[pos], COPY, except, &pos);
-    }  
-    if (t) {delete [] t; t = NULL;}
-    return list;   
-}
-
-/*
-* Returns an ArrayList of add command
-*/
-ArrayList* Parser::getAdds(BCHAR* xml, BCHAR* except) {
-    
-    Add* add         = NULL;    
-    unsigned int pos = 0, previous = 0;
-    ArrayList* list  = NULL;
-    BCHAR* t         = NULL;
-   /*
-    * except is set to SYNC if we are looking for Add commands external from <sync> tag
-    */
-    t = XMLProcessor::getElementContentExcept(&xml[pos], ADD, except, &pos);
-    while ((add = getAdd(t)) != NULL) {
-        if (add) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*add); // in the ArrayList NULL element cannot be inserted
-            deleteAdd(&add);            
-        }
-        pos += previous;
-        previous = pos;                
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentExcept(&xml[pos], ADD, except, &pos);
-    }   
-    if (t) { delete [] t; t = NULL; }
-    return list;   
-}
-
-/*
-* Returns an ArrayList of Replace commands
-*/
-ArrayList* Parser::getReplaces(BCHAR* xml, BCHAR* except) {
-    
-    Replace* replace = NULL;    
-    unsigned int pos = 0, previous = 0;
-    ArrayList* list = NULL;
-    BCHAR* t        = NULL;
-
-    t = XMLProcessor::getElementContentExcept(&xml[pos], REPLACE, except, &pos);
-    while ((replace = getReplace(t)) != NULL) {
-        if (replace) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*replace); // in the ArrayList NULL element cannot be inserted
-            deleteReplace(&replace);            
-        }
-        pos += previous;
-        previous = pos;                
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentExcept(&xml[pos], REPLACE, except, &pos);
-    }
-    if (t) { delete [] t; t = NULL; }
-    return list;   
-}
-
-/*
-* Returns an ArrayList of Dels command
-*/
-ArrayList* Parser::getDels(BCHAR* xml, BCHAR* except) {
-    
-    Delete* del        = NULL;    
-    unsigned int pos   = 0, previous = 0;
-    ArrayList* list    = NULL;
-    BCHAR* t           = NULL;
-
-    t = XMLProcessor::getElementContentExcept(&xml[pos], DEL, except, &pos);
-    while ((del = getDelete(t)) != NULL) {
-        if (del) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*del); // in the ArrayList NULL element cannot be inserted
-            deleteDelete(&del);            
-        }
-        pos += previous;
-        previous = pos;                
-        if (t) { delete [] t; t = NULL;}
-        t = XMLProcessor::getElementContentExcept(&xml[pos], DEL, except, &pos);
-    }
-    if (t) { delete [] t; t = NULL; }
-    return list;   
-}
-
-/*
-Commands of SyncBody tag
-    Alert
-    Add     
-    Atomic
-    Copy    
-    Delete
-    Exec    
-    Get
-    Map     
-    Put     
-    Replace
-    Results 
-    Search  
-    Sequence
-    Status  
-    Sync
-*/
-ArrayList* Parser::getCommands(BCHAR* xml) {    
-    ArrayList* ret    = new ArrayList();
-    
-    ArrayList* list     = NULL;
-    Alert* alert        = NULL;
-    Map*   map          = NULL;
-    Get*   get          = NULL;
-    Put*   put          = NULL;
-    Status* status      = NULL;
-    Results* result     = NULL;
-    Exec* exec          = NULL;
-    Search* search      = NULL;
-
-    Sequence* sequence  = NULL;
-    Atomic* atomic      = NULL;
-    Sync* sync          = NULL;
-    unsigned int pos = 0, previous = 0;
-    BCHAR* t            = NULL;
-
-
-    // Status
-    t = XMLProcessor::getElementContent(&xml[pos], STATUS, &pos);
-    while ((status = getStatus(t)) != NULL) {
-        if (status) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*status); // in the ArrayList NULL element cannot be inserted
-            deleteStatus(&status);            
-        }
-        pos += previous;
-        previous = pos;                
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContent(&xml[pos], STATUS, &pos);
-    }
-    if (t) { delete [] t; t = NULL; }
-   
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            ret->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);    
-        
-    // Alert: use the getElementContentLevel because Alert could be also in Atomic and Sequence commands
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContentLevel(&xml[pos], ALERT, &pos);
-    while ((alert = getAlert(t)) != NULL) {
-        if (alert) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*alert); // in the ArrayList NULL element cannot be inserted
-            deleteAlert(&alert);            
-        }
-        pos += previous;
-        previous = pos;       
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentLevel(&xml[pos], ALERT, &pos);
-    }
-    if (t) { delete [] t; t = NULL; }
-
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            ret->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);
-
-    // Map: use the getElementContentLevel because Map could be also in Atomic and Sequence commands
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContentLevel(&xml[pos], MAP, &pos);
-    while ((map = getMap(t)) != NULL) {
-        if (map) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*map); // in the ArrayList NULL element cannot be inserted
-            deleteMap(&map);            
-        }
-        pos += previous;
-        previous = pos;   
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentLevel(&xml[pos], MAP, &pos);
-    }
-    if (t) { delete [] t; t = NULL; }
-    
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            ret->add(*list->get(i));
-        }
-    }        
-
-    deleteArrayList(&list);
-    
-    // Get: use the getElementContentLevel because Get could be also in Atomic and Sequence commands
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContent(&xml[pos], GET, &pos);
-    while ((get = getGet(t)) != NULL) {
-        if (get) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*get); // in the ArrayList NULL element cannot be inserted
-            deleteGet(&get);            
-        }
-        pos += previous;
-        previous = pos;   
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContent(&xml[pos], GET, &pos);
-    }
-    if (t) { delete [] t; t = NULL; }
-
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            ret->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);
-
-    // Put
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContent(&xml[pos], PUT, &pos);
-    while ((put = getPut(t)) != NULL) {
-        if (put) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*put); // in the ArrayList NULL element cannot be inserted
-            deletePut(&put);            
-        }
-        pos += previous;
-        previous = pos;   
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContent(&xml[pos], PUT, &pos);
-    }
-    if (t) { delete [] t; t = NULL; }
-    
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            ret->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);
-
-    // Results
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContent(&xml[pos], RESULTS, &pos);
-    while ((result = getResult(t)) != NULL) {
-        if (result) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*result); // in the ArrayList NULL element cannot be inserted
-            deleteResults(&result);            
-        }
-        pos += previous;
-        previous = pos;         
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContent(&xml[pos], RESULTS, &pos);
-    }
-    if (t) { delete [] t; t = NULL; }
-
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            ret->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);
-
-    // Exec: use the getElementContentLevel because Exec could be also in Atomic and Sequence commands
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContentLevel(&xml[pos], EXEC, &pos);
-    while ((exec = getExec(t)) != NULL) {
-        if (exec) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*exec); // in the ArrayList NULL element cannot be inserted
-            deleteExec(&exec);            
-        }
-        pos += previous;
-        previous = pos;     
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentLevel(&xml[pos], EXEC, &pos);
-    }
-    if (t) { delete [] t; t = NULL; }
-    
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            ret->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);
-
-    // Search
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContent(&xml[pos], SEARCH, &pos);
-    while ((search = getSearch(t)) != NULL) {
-        if (search) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*search); // in the ArrayList NULL element cannot be inserted
-            deleteSearch(&search);            
-        }
-        pos += previous;
-        previous = pos;              
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContent(&xml[pos], SEARCH, &pos);
-    }
-    if (t) { delete [] t; t = NULL; }
-
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            ret->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);
-
-    // get the Sync commands. not belonging to Atomic and Sequence
-    //sync = getSync(XMLProcessor::getElementContentExcept (xml, SYNC, T("Atomic&Sequence"), NULL));
-    
-    //if (sync) {
-    //    ret->add(*sync);
-    //    deleteSync(&sync);
-    //}
-    
-    // Sync
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContentExcept(&xml[pos], SYNC, T("Atomic&Sequence"), &pos);
-    while ((sync = getSync(t)) != NULL) {
-        if (sync) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*sync); // in the ArrayList NULL element cannot be inserted
-            deleteSync(&sync);
-        }
-        pos += previous;
-        previous = pos;     
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContentExcept(&xml[pos], SYNC, T("Atomic&Sequence"), &pos);
-    }
-    if (t) { delete [] t; t = NULL; }
-    
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            ret->add(*list->get(i));
-        }
-    }        
-    deleteArrayList(&list);
-
-
-
-    // get the Sequence commands. Not belonging to Atomic and Sync
-    t = XMLProcessor::getElementContentExcept(xml, SEQUENCE, T("Atomic&Sync"), &pos);
-    sequence = getSequence(t);
-    if (t) {delete [] t; t = NULL;}
-    
-    if (sequence) {
-        ret->add(*sequence);
-        deleteSequence(&sequence);
-    }
-    
-    // get the Sequence commands. Not belonging to Sequence and Sync and Atomic
-    t = XMLProcessor::getElementContentExcept(xml, ATOMIC, T("Atomic&Sync&Sequence"), &pos);
-    atomic = getAtomic(t);   
-    if (t) {delete [] t; t = NULL;}
-    
-    if (atomic) {
-        ret->add(*atomic);
-        deleteAtomic(&atomic);
-    }
-    
-    
-    list = getCommonCommandList(xml, T("Atomic&Sync&Sequence"));
-
-    if (list && list->size() > 0) {
-        for (int i = 0; i < list->size(); i++) {
-            ret->add(*list->get(i));
-        }
-    }
-    deleteArrayList(&list);
-    
-    return ret;
-}
-
-Status* Parser::getStatus(BCHAR* xml) {
-    
-    if (!xml)
-        return NULL;
-    
-    Status*     ret         = NULL;
-    
-    CmdID*      cmdID       = NULL;
-    BCHAR*    msgRef      = NULL;
-    BCHAR*    cmdRef      = NULL;
-    BCHAR*    cmd         = NULL;
-    ArrayList*  targetRefs  = new ArrayList();
-    ArrayList*  sourceRefs  = new ArrayList();
-    Cred*       cred        = NULL;
-    Chal*       chal        = NULL;
-    Data*       data        = NULL;
-    ArrayList*  items       = new ArrayList();
-
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
-    cmdID = getCmdID(t);
-    if (t) {delete [] t; t = NULL;}
-    
-    msgRef          = XMLProcessor::getElementContent (xml, MSG_REF, NULL);
-    cmdRef          = XMLProcessor::getElementContent (xml, CMD_REF, NULL);
-    cmd             = XMLProcessor::getElementContent (xml, CMD,     NULL);
-    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
-    cred            = getCred      (t);
-    if (t) {delete [] t; t = NULL;}
-    // get Data <Data>200</Data>
-    t = XMLProcessor::getElementContent (xml, DATA   , NULL);
-    data            = getData      (t);
-    if (t) {delete [] t; t = NULL;}
-    items           = getItems     (xml);
-    targetRefs      = getTargetRefs(xml);
-    sourceRefs      = getSourceRefs(xml);
-    t = XMLProcessor::getElementContent (xml, CHAL   , NULL);
-    chal            = getChal      (t);    
-    if (t) {delete [] t; t = NULL;}
-    
-    if (NotNullCheck(2, msgRef, cmdRef) || (cred) 
-                                        || (data)
-                                        || (cmdID) 
-                                        || (chal) 
-                                        || NotZeroArrayLenght(3, items, targetRefs, sourceRefs)                                        
-                                        )  {
-
-        ret = new Status(cmdID, msgRef, cmdRef, cmd, targetRefs, sourceRefs, cred, chal, data, items);
-    }
-    deleteArrayList(&sourceRefs);
-    deleteArrayList(&targetRefs);
-    deleteArrayList(&items);
-    deleteAll(3, &msgRef, &cmdRef, &cmd);
-    deleteCmdID(&cmdID);
-    deleteCred(&cred);
-    deleteData(&data);
-    deleteChal(&chal);
-
-    return ret;   
-}
-
-Chal* Parser::getChal(BCHAR* xml) {
-    
-    Chal* ret  = NULL;
-    Meta* meta = NULL;
-
-    meta     = getMeta (xml);    
-
-    if (meta) {
-        ret = new Chal(meta);
-        deleteMeta(&meta); 
-    }
-
-    return ret;
-}
-
-ArrayList* Parser::getTargetRefs(BCHAR* xml) {
-    ArrayList* list = new ArrayList();
-    TargetRef* targetRef = NULL;
-    unsigned int pos = 0, previous = 0;
-
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent(&xml[pos], TARGET_REF, &pos);
-    while ((targetRef = getTargetRef(t)) != NULL) {
-        if (targetRef) {
-            list->add(*targetRef); // in the ArrayList NULL element cannot be inserted
-            deleteTargetRef(&targetRef);            
-        }
-        pos += previous;
-        previous = pos;               
-        if (t) {delete [] t; t = NULL;}
-        t = XMLProcessor::getElementContent(&xml[pos], TARGET_REF, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-    
-    return list;
-}
-
-ArrayList* Parser::getSourceRefs(BCHAR* xml) {
-    ArrayList* list = new ArrayList();
-    SourceRef* sourceRef = NULL;
-    unsigned int pos = 0, previous = 0;
-
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent(&xml[pos], SOURCE_REF, &pos);
-    while ((sourceRef = getSourceRef(t)) != NULL) {
-        if (sourceRef) {
-            list->add(*sourceRef); // in the ArrayList NULL element cannot be inserted
-            deleteSourceRef(&sourceRef);            
-        }
-        pos += previous;
-        previous = pos;               
-        if (t) {delete [] t; t = NULL;}
-        t = XMLProcessor::getElementContent(&xml[pos], SOURCE_REF, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-    return list;
-}
-
-SourceRef* Parser::getSourceRef(BCHAR* xml) {    
-    SourceRef* ret = NULL;        
-    Source* source;   
-    
-    source = getSource(xml);    
-    if (source) {
-        ret = new SourceRef(source);
-    } else if (xml) {
-        ret = new SourceRef(xml);
-    }
-    
-    return ret;
-}
-
-TargetRef* Parser::getTargetRef(BCHAR* xml) {    
-    TargetRef* ret = NULL;        
-    Target* target;   
-    
-    target = getTarget(xml);    
-    if (target) {
-        ret = new TargetRef(target);
-    } else if (xml) {
-        ret = new TargetRef(xml);
-    }
-    
-    return ret;
-}
-
-Alert* Parser::getAlert(BCHAR* xml) {
-    
-    Alert* ret = NULL;
-    ArrayList* items = new ArrayList();    
-    
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
-    CmdID* cmdID     = getCmdID   (t);
-    if(t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
-    Cred*  cred      = getCred    (t);
-    if(t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, DATA   , NULL);
-    int    data      = getDataCode(t);
-    if(t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
-    BOOL   noResp    = getNoResp  (t);
-    if(t) {delete [] t; t = NULL;}
-    
-    items = getItems(xml);
-    if (items && items->size() > 0) {
-        ret = new Alert(cmdID, noResp, cred, data, items); //Item[]
-    }
-    
-    deleteCmdID(&cmdID);
-    deleteCred(&cred);
-    deleteArrayList(&items);
-    
-    return ret;
-}
-
-Exec* Parser::getExec(BCHAR* xml) {
-    
-    Exec* ret = NULL;
-    
-    CmdID* cmdID        = NULL;
-    BOOL   noResp       = FALSE;
-    Cred*  cred         = NULL;
-    ArrayList*  items   = new ArrayList();
-
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
-    cmdID     = getCmdID   (t);
-    if(t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
-    cred      = getCred    (t);
-    if(t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
-    noResp    = getNoResp  (t);    
-    if(t) {delete [] t; t = NULL;}
-    items = getItems(xml);
-
-    if (cmdID || NotZeroArrayLenght(1, items) || (cred)) {
-        ret = new Exec(cmdID, noResp, cred, items); 
-    }
-    
-    deleteCmdID(&cmdID);
-    deleteCred(&cred);
-    deleteArrayList(&items);
-    
-    return ret;
-}
-
-Get* Parser::getGet(BCHAR* xml) {
-       
-    Get* ret = NULL;    
-    ArrayList* items = NULL;    
-    
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
-    CmdID* cmdID     = getCmdID   (t);
-    if(t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
-    Cred*  cred      = getCred    (t);
-    if(t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
-    BOOL   noResp    = getNoResp  (t);
-    if(t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContentLevel (xml, META ,   NULL);
-    Meta*  meta      = getMeta    (t);
-    if(t) {delete [] t; t = NULL;}    
-    BCHAR* lang    = XMLProcessor::getElementContent        (xml, LANG, NULL);
-    items = getItems(xml);
-
-    if (NotNullCheck(1, lang)  || (cred) 
-                               || (cmdID) 
-                               || (meta) 
-                               || NotZeroArrayLenght(1, items))  {
-    
-        ret = new Get(cmdID, noResp, lang, cred, meta, items); //Item[]
-    }
-       
-    deleteCmdID(&cmdID);
-    deleteCred(&cred);
-    deleteMeta(&meta);
-    safeDel(&lang);
-    deleteArrayList(&items);
-    
-    return ret;
-}
-
-Put* Parser::getPut(BCHAR* xml) {
-    
-    Put* ret = NULL;    
-    ArrayList* items = NULL;    
-    
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
-    CmdID* cmdID     = getCmdID   (t);
-    if(t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
-    Cred*  cred      = getCred    (t);
-    if(t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
-    BOOL   noResp    = getNoResp  (t);
-    if(t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContentLevel (xml, META ,   NULL);
-    Meta*  meta      = getMeta    (t);
-    if(t) {delete [] t; t = NULL;}
-    BCHAR* lang    = XMLProcessor::getElementContent        (xml, LANG, NULL);        
-    items = getItems(xml);
-
-    if (NotNullCheck(1, lang)  || (cred) 
-                               || (cmdID) 
-                               || (meta) 
-                               || NotZeroArrayLenght(1, items))  {
-    
-        ret = new Put(cmdID, noResp, lang, cred, meta, items); //Item[]
-    }
-       
-    deleteCmdID(&cmdID);
-    deleteCred(&cred);
-    deleteMeta(&meta);
-    safeDel(&lang);
-    deleteArrayList(&items);
-    
-    return ret;
-}
-
-Search* Parser::getSearch(BCHAR* xml) {    
-    
-    Search*     ret      = NULL;
-    CmdID*      cmdID    = NULL;
-    BOOL        noResp   = NULL;
-    BOOL        noResults= NULL;
-    Cred*       cred     = NULL;
-    Target*     target   = NULL;
-    ArrayList*  sources  = new ArrayList();  // an Array of SourceArray object
-    BCHAR*    lang     = NULL;
-    Meta*       meta     = NULL;
-    Data*       data     = NULL;
-    
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
-    cmdID     = getCmdID   (t);
-    if (t) { delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
-    cred      = getCred    (t);
-    if (t) { delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
-    noResp    = getNoResp  (t);
-    if (t) { delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent(xml, NO_RESULTS, NULL);
-    noResults = getNoResults(t);
-    if (t) { delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent (xml, TARGET,NULL);
-    target    = getTarget  (t);
-    if (t) { delete [] t; t = NULL;}    
-    lang      = XMLProcessor::getElementContent             (xml, LANG, NULL);            
-    t = XMLProcessor::getElementContentLevel (xml, META , NULL);
-    meta      = getMeta    (t);
-    if (t) { delete [] t; t = NULL;}    
-    t = XMLProcessor::getElementContent (xml, DATA ,   NULL);
-    data      = getData    (t);    
-    if (t) { delete [] t; t = NULL;}    
-    sources   = getSources (xml);
-
-    if (NotNullCheck(1, lang) || (cmdID) || (cred) 
-                              || (meta)  || (target) 
-                              || (data)  || NotZeroArrayLenght(1, sources))  {
-                
-        ret = new Search(cmdID, noResp, noResults, cred, target, sources, lang, meta, data);
-    }
-
-    deleteCmdID(&cmdID);
-    deleteCred(&cred);
-    deleteTarget(&target);
-    safeDel(&lang);
-    deleteData(&data);
-    deleteMeta(&meta);
-    deleteArrayList(&sources);
-    
-  return ret;
-}
-
-Results* Parser::getResult(BCHAR* xml) {
-    
-    if (!xml)
-        return NULL;
-    
-    Results*    ret         = NULL;        
-    CmdID*      cmdID       = NULL;
-    BCHAR*    msgRef      = NULL;
-    BCHAR*    cmdRef      = NULL;
-    Meta*       meta        = NULL;   
-    ArrayList*  targetRefs  = new ArrayList(); // it could be an array with only a value
-    ArrayList*  sourceRefs  = new ArrayList();
-    ArrayList*  items       = new ArrayList();
-
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
-    cmdID           = getCmdID     (t);
-    if (t) {delete [] t; t = NULL;}    
-    msgRef          = XMLProcessor::getElementContent (xml, MSG_REF, NULL);
-    cmdRef          = XMLProcessor::getElementContent (xml, CMD_REF, NULL);
-    t = XMLProcessor::getElementContentLevel(xml, META, NULL);
-    meta            = getMeta      (t);
-    if (t) {delete [] t; t = NULL;}
-    targetRefs      = getTargetRefs(xml);
-    sourceRefs      = getSourceRefs(xml);    
-    items           = getItems     (xml);
-    
-    if (NotNullCheck(2, msgRef, cmdRef) || (cmdID) || (meta) 
-                                        || NotZeroArrayLenght(3, items, targetRefs, sourceRefs)                                        
-                                        )  {
-
-        ret = new Results(cmdID, msgRef, cmdRef, meta, targetRefs, sourceRefs, items);
-    }
-    deleteArrayList(&sourceRefs);
-    deleteArrayList(&targetRefs);
-    deleteArrayList(&items);
-    deleteAll(2, &msgRef, &cmdRef);
-    deleteCmdID(&cmdID);
-    deleteMeta(&meta);
-    
-    return ret;   
-}
-
-
-//
-// return and array list of items
-//
-ArrayList* Parser::getItems(BCHAR* xml) {
-
-    Item* item = NULL;
-    ArrayList* items = NULL;
-    unsigned int pos = 0, previous = 0;
-    BCHAR*      t       = NULL;
-    
-    t = XMLProcessor::getElementContent(&xml[pos], ITEM, &pos);    
-    while ((item = getItem(t)) != NULL) {
-        if (item) {
-            if (!items)
-                items = new ArrayList();
-            items->add(*item);    // in the ArrayList NULL element cannot be inserted
-            deleteItem(&item);    
-        }
-        pos += previous;
-        previous = pos;                
-        if (t) { delete [] t; t = NULL; }
-        t = XMLProcessor::getElementContent(&xml[pos], ITEM, &pos);
-    }
-    if (t) { delete [] t; t = NULL; }
-
-    return items;    
-}
-
-Item* Parser::getItem(BCHAR* xml) {    
-    Item*   ret       = NULL;
-    Target* target    = NULL;
-    Source* source    = NULL;
-    Meta*   meta      = NULL;
-    ComplexData* data = NULL;
-    BOOL moreData     = FALSE;  
-    BCHAR* targetParent = NULL;
-    BCHAR* sourceParent = NULL;
-    BCHAR*      t       = NULL;   
-    unsigned int pos = 0;
-    t = XMLProcessor::getElementContent(xml, TARGET,NULL);
-    target   = getTarget     (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContent(xml, SOURCE,NULL);
-    source   = getSource     (t);
-    if (t) {delete [] t; t = NULL;}
-    t = XMLProcessor::getElementContentLevel(xml, META,NULL);
-    meta     = getMeta       (t);
-    if (t) {delete [] t; t = NULL;}
-    
-    t = XMLProcessor::getElementContent(xml, COMPLEX_DATA,NULL);
-    data     = getComplexData(t);
-    if (t) { delete [] t; t = NULL; } 
-    
-    t = XMLProcessor::getElementContent(xml, MORE_DATA,NULL);
-    moreData = getMoreData   (t);
-    if (t) {delete [] t; t = NULL;}
-    targetParent = XMLProcessor::getElementContent(xml, TARGET_PARENT,      NULL);
-    sourceParent = XMLProcessor::getElementContent(xml, SOURCE_PARENT,      NULL);
-
-    if ((target)     || 
-            (source) || 
-            (meta)   ||
-            (data))  {
-        // ret = new Item(target, source, meta, data, moreData);
-        ret = new Item(target, source, targetParent, sourceParent, meta, data, moreData);
-
-    }
-    
-    deleteTarget     (&target);
-    deleteSource     (&source);
-    deleteMeta       (&meta);
-    deleteComplexData(&data);
-    deleteAll(2, &targetParent, &sourceParent);
-    
-    return ret;
-}
-
-int Parser::getDataCode(BCHAR* content) {    
-   int ret = 0;
-   if (content) {
-        ret = bstrtol(content, NULL, 10);
-   }
-   return ret;
-}
-
-Data* Parser::getData(BCHAR* content) {    
-   Data* ret = 0;
-   if (content) {
-        ret = new Data(content);
-   }
-   return ret;
-}
-
-BOOL Parser::getFinalMsg(BCHAR* content) {    
-    BOOL ret = FALSE;
-    if (content) {
-        ret = TRUE;
-    }
-    return ret;
-}
-
-CmdID* Parser::getCmdID(BCHAR* content) {
-    CmdID* ret = NULL;
-    if (content) {
-        ret = new CmdID(content);
-    }
-    return ret;
-}
-
-ComplexData* Parser::getComplexData(BCHAR* xml) {
-    
-    ComplexData* ret = NULL;
-    Anchor* anchor   = NULL;
-    DevInf* devInf   = NULL;
-    
-    anchor = getAnchor(xml);
-    devInf = getDevInf(xml);    
-    
-    if (anchor || devInf) {
-        ret = new ComplexData(NULL); 
-    
-        if (anchor) 
-            ret->setAnchor(anchor);
-        if (devInf)
-            ret->setDevInf(devInf);
-    }
-    else if (xml) {        
-        StringBuffer tmp(xml);
-        tmp.replaceAll("&amp;", "&");
-        tmp.replaceAll("&lt;", "<");        
-        ret = new ComplexData(tmp);
-    }    
-
-    return ret;
-}
-
-DevInf* Parser::getDevInf(BCHAR* xml) {
-    DevInf* ret             = NULL;
-    DataStore* dataStore    = NULL;
-    CTCap* ctCap            = NULL;
-    Ext* ext                = NULL;
-
-    VerDTD* verDTD          = NULL;
-    BCHAR* man            = NULL;
-    BCHAR* mod            = NULL;
-    BCHAR* oem            = NULL;
-    BCHAR* fwV            = NULL;
-    BCHAR* swV            = NULL;
-    BCHAR* hwV            = NULL;
-    BCHAR* devId          = NULL;
-    BCHAR* devTyp         = NULL;
-    ArrayList* dataStores   = NULL;       // DataStore[]
-    ArrayList* ctCaps       = NULL;       // CTCap[]
-    ArrayList* exts         = NULL;       // Ext[]
-    BOOL utc                = NULL;         // if present they Support UTC
-    BOOL supportLargeObjs   = NULL;         // if present they Support largeObject
-    BOOL supportNumberOfChanges = NULL;     // if present they Support NumberOfChanges
-    SyncCap* syncCap        = NULL;
-    
-    BCHAR* value          = NULL;
-    
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent(xml, VER_DTD,NULL);
-    verDTD = getVerDTD(t);
-    if (t) {delete [] t; t = NULL;}
-    man     = XMLProcessor::getElementContent(xml, MAN,           NULL);
-    mod     = XMLProcessor::getElementContent(xml, MOD,           NULL);
-    oem     = XMLProcessor::getElementContent(xml, OEM,           NULL);
-    fwV     = XMLProcessor::getElementContent(xml, FWV,           NULL);
-    swV     = XMLProcessor::getElementContent(xml, SWV,           NULL);
-    hwV     = XMLProcessor::getElementContent(xml, HWV,           NULL);
-    devId   = XMLProcessor::getElementContent(xml, DEV_ID,        NULL);
-    devTyp  = XMLProcessor::getElementContent(xml, DEV_TYP,       NULL);
-
-    t = XMLProcessor::getElementContent(xml, SYNC_CAP,NULL);
-    syncCap = getSyncCap(t);
-    if (t) {delete [] t; t = NULL;}
-    
-    unsigned int previous = 0;
-    pos = 0; 
-        
-    // DataStore
-    t = XMLProcessor::getElementContent(&xml[pos], DATA_STORE, &pos);
-    while ((dataStore = getDataStore(t)) != NULL) {
-        if (dataStore) {
-            if (!dataStores) {
-                dataStores = new ArrayList();                
-            }
-            dataStores->add(*dataStore); // in the ArrayList NULL element cannot be inserted
-            deleteDataStore(&dataStore);            
-        }
-        pos += previous;
-        previous = pos;            
-        if (t) {delete [] t; t = NULL;}
-        t = XMLProcessor::getElementContent(&xml[pos], DATA_STORE, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-        
-    // ctCap
-    pos = 0; previous = 0;
-    t = XMLProcessor::getElementContent(&xml[pos], CT_CAP, &pos);
-    while ((ctCap = getCTCap(t)) != NULL) {
-        if (ctCap) {
-            if (!ctCaps) {
-                ctCaps = new ArrayList();                
-            }
-            ctCaps->add(*ctCap); // in the ArrayList NULL element cannot be inserted
-            deleteCTCap(&ctCap);            
-        }
-        pos += previous;
-        previous = pos;       
-        if (t) {delete [] t; t = NULL;}
-        t = XMLProcessor::getElementContent(&xml[pos], CT_CAP, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-
-    // ext
-    pos = 0; previous = 0;
-    t = XMLProcessor::getElementContent(&xml[pos], EXT, &pos);
-    while ((ext = getExt(t)) != NULL) {
-        if (ext) {
-            if (!exts) {
-                exts = new ArrayList();                
-            }
-            exts->add(*ext); // in the ArrayList NULL element cannot be inserted
-            deleteExt(&ext);            
-        }
-        pos += previous;
-        previous = pos;   
-        if (t) {delete [] t; t = NULL;}
-        t = XMLProcessor::getElementContent(&xml[pos], EXT, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-
-    //
-    // The large object value depends on SUPPORT_LARGE_OBJECT tag.
-    //
-    if ((value = XMLProcessor::getElementContent(xml, SUPPORT_LARGE_OBJECT, NULL)) != NULL) {
-        if (wcscmpIgnoreCase(value, T("TRUE"))) {
-            supportLargeObjs = TRUE;
-        }
-        safeDel(&value);
-    }
-
-    //
-    // The large object value depends on SUPPORT_NUMBER_OF_CHANGES tag. 
-    //    
-    if ((value = XMLProcessor::getElementContent(xml, SUPPORT_NUMBER_OF_CHANGES, NULL)) != NULL) {
-        if (wcscmpIgnoreCase(value, T("TRUE"))) {
-            supportNumberOfChanges = TRUE;
-        }
-        safeDel(&value);
-    }
-
-    //
-    // The large object value depends on UTC tag.
-    //
-    if ((value = XMLProcessor::getElementContent(xml, UTC, NULL)) != NULL) {
-        if (wcscmpIgnoreCase(value, T("TRUE"))) {
-            utc = TRUE;
-        }
-        safeDel(&value);
-    }    
-    
-    if (NotNullCheck(8, man, mod, oem, fwV, swV, hwV, devId, devTyp) ||
-                                     (verDTD)      ||
-                                     (syncCap)     ||
-                                      NotZeroArrayLenght(3, dataStores, ctCaps, exts) ) {
-
-        ret = new DevInf(verDTD, man, mod, oem,  fwV, swV, hwV, devId, devTyp,
-                                dataStores, ctCaps, exts,
-                                utc, supportLargeObjs, supportNumberOfChanges,
-                                syncCap);
-
-    }
-    deleteAll(8, &man, &mod, &oem, &fwV, &swV, &hwV, &devId, &devTyp);
-    deleteArrayList(&dataStores);
-    deleteArrayList(&ctCaps);
-    deleteArrayList(&exts);
-    deleteVerDTD(&verDTD);
-    deleteSyncCap(&syncCap);
-    return ret;
-}
-
-
-/*
-* TBD. There is to use the getNextTag method in xmlProcessor.
-* This CTCap is no nested as a usual XML. See syncml_devinf_v11_20020215.pdf
-*
-*/
-Ext* Parser::getExt(BCHAR* xml) {
-    Ext* ret = NULL;
-    BCHAR* XNam         = NULL;
-    BCHAR* value        = NULL;
-    ArrayList* list     = NULL;
-    StringElement* s    = NULL;
-    unsigned int pos = 0, previous = 0;
-
-    XNam = XMLProcessor::getElementContent(xml, XNAM, NULL);
-
-    // XVal
-    while ((value = XMLProcessor::getElementContent(&xml[pos], XVAL, &pos)) != NULL) {
-        if (value) {
-            if (!list)
-                list = new ArrayList();
-            s = new StringElement(value);
-            list->add(*s); 
-            deleteStringElement(&s);            
-            safeDel(&value);
-        }
-        pos += previous;
-        previous = pos;                
-    }
-       
-    if ( XNam || NotZeroArrayLenght(1, list) ) {
-        ret = new Ext(XNam, list);
-    }
-    
-    safeDel(&XNam);
-    deleteArrayList(&list);
-
-    return ret;
-}
-
-DataStore* Parser::getDataStore(BCHAR* xml) {
-    DataStore* ret = NULL;
-    
-    SourceRef*       sourceRef      = NULL;
-    BCHAR*           displayName    = NULL;
-    long             maxGUIDSize    = 0;
-    BCHAR*           maxGUIDSizeW   = NULL;
-    ContentTypeInfo* rxPref         = NULL;
-    ArrayList*       rx             = NULL; // ContentTypeInfo[]
-    ContentTypeInfo* txPref         = NULL;;
-    ArrayList*       tx             = NULL; // ContentTypeInfo[]
-    DSMem*           dsMem          = NULL;
-    SyncCap*         syncCap        = NULL;  
-
-    ContentTypeInfo* x              = NULL;
-    
-    unsigned int pos = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent(xml, SOURCE_REF,  NULL);
-    sourceRef   = getSourceRef(t);
-    if (t) {delete [] t; t = NULL;}    
-    displayName = XMLProcessor::getElementContent(xml, DISPLAY_NAME,             NULL);
-    maxGUIDSizeW = XMLProcessor::getElementContent(xml, MAX_GUID_SIZE,           NULL);
-    if (maxGUIDSizeW) {
-        maxGUIDSize = bstrtol(maxGUIDSizeW, NULL, 10);
-    }
-    t = XMLProcessor::getElementContent(xml, RX_PREF,  NULL);
-    rxPref = getContentTypeInfo(t);
-    if (t) {delete [] t; t = NULL;}    
-    t = XMLProcessor::getElementContent(xml, TX_PREF,  NULL);
-    txPref = getContentTypeInfo(t);
-    if (t) {delete [] t; t = NULL;}    
-
-    unsigned int previous = 0;
-    pos = 0;
-        
-    // Rx 
-    t = XMLProcessor::getElementContent(&xml[pos], RX, &pos);
-    while ((x = getContentTypeInfo(t)) != NULL) {
-        if (x) {
-            if (!rx)
-                rx = new ArrayList();
-            rx->add(*x); // in the ArrayList NULL element cannot be inserted
-            deleteContentTypeInfo(&x);            
-        }
-        pos += previous;
-        previous = pos;             
-        if (t) {delete [] t; t = NULL;}    
-        t = XMLProcessor::getElementContent(&xml[pos], RX, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}    
-
-    // Tx 
-    pos = 0, previous = 0;
-    t = XMLProcessor::getElementContent(&xml[pos], TX, &pos);
-    while ((x = getContentTypeInfo(t)) != NULL) {
-        if (x) {
-            if (!tx)
-                tx = new ArrayList();
-            tx->add(*x); // in the ArrayList NULL element cannot be inserted
-            deleteContentTypeInfo(&x);            
-        }
-        pos += previous;
-        previous = pos;             
-        if (t) {delete [] t; t = NULL;}    
-        t = XMLProcessor::getElementContent(&xml[pos], TX, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}    
-    
-    t = XMLProcessor::getElementContent(xml, DS_MEM,  NULL);
-    dsMem = getDSMem(t);    
-    if (t) {delete [] t; t = NULL;}    
-    t = XMLProcessor::getElementContent(xml, SYNC_CAP,  NULL);
-    syncCap = getSyncCap(t);  
-    if (t) {delete [] t; t = NULL;}    
-        
-    if (NotNullCheck(2, displayName, maxGUIDSizeW) ||
-                                     (sourceRef)   ||
-                                     (rxPref)      ||
-                                     (txPref)      ||
-                                     (dsMem)       ||
-                                     (syncCap)     ||
-                                     NotZeroArrayLenght(2, rx, tx) ) {
-        ret = new DataStore(sourceRef, displayName, maxGUIDSize, rxPref, rx, txPref, tx, dsMem, syncCap);
-    }
-    
-    safeDel(&displayName);
-    safeDel(&maxGUIDSizeW);
-    deleteContentTypeInfo(&rxPref);
-    deleteContentTypeInfo(&txPref);
-    deleteArrayList(&tx);
-    deleteArrayList(&rx);
-    deleteSyncCap(&syncCap);
-    deleteDSMem(&dsMem);
-
-
-    return ret;
-}
-
-
-SyncCap* Parser::getSyncCap(BCHAR* xml) {
-    
-    SyncCap* ret            = NULL;
-    SyncType* syncType      = NULL;
-    ArrayList* list         = NULL;
-
-    unsigned int pos = 0, previous = 0;
-    BCHAR* t = NULL;
-    t = XMLProcessor::getElementContent(&xml[pos], SYNC_TYPE, &pos);
-    while ((syncType = getSyncType(t)) != NULL) {
-        if (syncType) {
-            if (!list)
-                list = new ArrayList();
-            list->add(*syncType); // in the ArrayList NULL element cannot be inserted
-            deleteSyncType(&syncType);            
-        }
-        pos += previous;
-        previous = pos;             
-        if (t) {delete [] t; t = NULL;}
-        t = XMLProcessor::getElementContent(&xml[pos], SYNC_TYPE, &pos);
-    }
-    if (t) {delete [] t; t = NULL;}
-        
-    if (NotZeroArrayLenght(1, list)) {
-        ret = new SyncCap(list);
-    }
-
-    deleteArrayList(&list);
-
-    return ret;
-}
-
-SyncType* Parser::getSyncType(BCHAR* content) {
-    
-    SyncType* ret            = NULL;    
-    int value                = 0;
-  
-    if (content) {
-         value = bstrtol(content, NULL, 10);
-         if (value >= 1 && value <= 7) {
-             ret = new SyncType(value);
-         }
-    }    
-    
-    return ret;
-}
-
-
-ContentTypeInfo* Parser::getContentTypeInfo(BCHAR* xml) {
-    
-    ContentTypeInfo* ret = NULL;
-    BCHAR* ctType      = NULL;
-    BCHAR* verCT       = NULL;     
-
-    ctType = XMLProcessor::getElementContent(xml, CT_TYPE,             NULL);
-    verCT  = XMLProcessor::getElementContent(xml, VER_CT,             NULL);
-    
-    if (NotNullCheck(2, ctType, verCT)) {
-        ret = new ContentTypeInfo(ctType, verCT);
-    }
-    
-    safeDel(&ctType);
-    safeDel(&verCT);
-    return ret;
-}
-
-DSMem* Parser::getDSMem(BCHAR* xml) {    
-    
-    DSMem* ret          = NULL;
-    BCHAR* maxMemW   = NULL;   
-    BCHAR* sharedMemW = NULL;
-    BCHAR* maxIDW    = NULL;
-        
-    BOOL    sharedMem   = NULL;
-    long    maxMem     = 0;
-    long    maxID      = 0;
-    
-    BOOL isToCreate = FALSE;
-
-    maxMemW     = XMLProcessor::getElementContent (xml, MAX_MEM,   NULL);
-    sharedMemW  = XMLProcessor::getElementContent (xml, SHARED_MEM, NULL);
-    maxIDW      = XMLProcessor::getElementContent (xml, MAX_ID,    NULL);
-    
-    isToCreate = NotNullCheck(3, maxMemW, sharedMemW, maxIDW);
-
-    if (maxMemW != NULL) {
-        maxMem = bstrtol(maxMemW, NULL, 10);
-    }
-    if (maxIDW != NULL) {
-        maxID = bstrtol(maxIDW, NULL, 10);
-    } 
-    if (sharedMemW != NULL) {
-        sharedMem = bstrtol(sharedMemW, NULL, 10);
-    }
-    
-    if (isToCreate) {
-        ret = new DSMem(sharedMem, maxMem, maxID);
-    }
-
-    safeDel(&maxMemW);
-    safeDel(&maxIDW);
-    safeDel(&sharedMemW);
-
-    return ret;   
-
-}
-
-BOOL Parser::getNoResp(BCHAR* content) {    
-  if (content)
-      return TRUE;
-  else
-      return FALSE;
-}
-
-BOOL Parser::getNoResults(BCHAR* content) {    
-    
-    if (content)
-        return TRUE;
-    else    
-        return FALSE;
-}
-
-BOOL Parser::getMoreData(BCHAR* content) {
-     if (content)
-        return TRUE;
-    else    
-        return FALSE;
-}
-
-/*
-* TBD. There is to use the getNextTag method in xmlProcessor.
-* This CTCap is no nested as a usual XML. See syncml_devinf_v11_20020215.pdf
-* TBD
-*
-*/
-CTCap* Parser::getCTCap(BCHAR* xml) {
-    CTCap* ret = NULL;
-    CTTypeSupported* ctTypeSupported = NULL;
-
-    // ArrayList* ctTypes = new ArrayList();       
-       
-    return ret;
-}
-
-//
-// TBD 
-//
-ArrayList* Parser::getEMI(BCHAR* content) {
-    ArrayList* ret = NULL;    
-    return ret;
-}
+/*
+ * Copyright (C) 2003-2006 Funambol
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+ 
+#include "syncml/parser/Parser.h"
+ 
+SyncML* Parser::getSyncML(BCHAR* xml) {
+    SyncBody* syncBody = NULL;
+    SyncHdr*  syncHdr  = NULL;
+    SyncML*   syncML   = NULL; 
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent(xml, SYNC_HDR, &pos);
+    syncHdr  = getSyncHdr (t);
+    if (t) { delete [] t; t = NULL; }
+    t = XMLProcessor::getElementContent(xml, SYNC_BODY, &pos);
+    syncBody = getSyncBody(t);
+    if (t) { delete [] t; t = NULL; }
+    syncML = new SyncML(syncHdr, syncBody);
+    
+    deleteSyncHdr (&syncHdr);
+    deleteSyncBody(&syncBody);
+    
+    return syncML;
+     
+}
+
+SyncHdr* Parser::getSyncHdr(BCHAR* xml) {
+         
+    SessionID*   sessionID = NULL;
+    VerDTD*      verDTD    = NULL;
+    VerProto*    verProto  = NULL;
+    Source*      source    = NULL;
+    Target*      target    = NULL;
+    Cred*        cred      = NULL;
+    BCHAR*     respURI   = NULL;
+    BCHAR*     msgID     = NULL;
+    BOOL         noResp    = NULL;             
+    BCHAR*     tmp       = NULL;
+    Meta*        meta      = NULL;
+
+    SyncHdr*     ret       = NULL;
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    
+    t = XMLProcessor::getElementContent(xml, SESSION_ID, NULL);
+    sessionID = getSessionID(t);
+    if (t) { delete [] t; t = NULL; }
+    t = XMLProcessor::getElementContent (xml, VER_DTD, NULL);
+    verDTD = getVerDTD(t);
+    if (t) { delete [] t; t = NULL; }
+    t = XMLProcessor::getElementContent (xml, VER_PROTO, NULL);
+    verProto = getVerProto(t);
+    if (t) { delete [] t; t = NULL; }
+    t = XMLProcessor::getElementContent (xml, SOURCE, NULL);
+    source = getSource(t);
+    if (t) { delete [] t; t = NULL; }
+    t = XMLProcessor::getElementContent (xml, TARGET, NULL);
+    target = getTarget(t);    
+    if (t) { delete [] t; t = NULL; }
+    t = XMLProcessor::getElementContent (xml, CRED, NULL);
+    cred = getCred(t);
+    if (t) { delete [] t; t = NULL; }
+    msgID = XMLProcessor::getElementContent(xml, MSG_ID, NULL);
+    respURI = XMLProcessor::getElementContent(xml, RESP_URI, NULL);
+    t = XMLProcessor::getElementContentLevel(xml, META, NULL);
+    meta = getMeta(t);
+    if (t) { delete [] t; t = NULL; }
+    tmp = XMLProcessor::getElementContent(xml, NO_RESP, NULL);
+
+    if (tmp) {
+        wcscmpIgnoreCase(tmp, T("TRUE")) ? noResp = TRUE : noResp = FALSE;            
+    } 
+    ret = new SyncHdr(verDTD, verProto, sessionID, msgID, target, source, respURI, noResp, cred, meta);                
+        
+    deleteVerDTD(&verDTD);
+    deleteVerProto(&verProto);
+    deleteSessionID(&sessionID);
+    deleteSource(&source   );
+    deleteTarget(&target);
+    deleteCred(&cred);
+    deleteMeta(&meta);
+    safeDel(&respURI);
+    safeDel(&msgID);
+    safeDel(&tmp);
+      
+    return ret;    
+}
+
+Cred* Parser::getCred(BCHAR* xml) {
+    Cred* ret              = NULL;
+    Authentication* auth   = NULL;    
+    
+    auth = getAuthentication(xml);
+    if (auth) { 
+        ret = new Cred(auth); 
+    }
+    
+    deleteAuthentication(&auth);
+
+    return ret;
+}
+
+Authentication* Parser::getAuthentication(BCHAR* xml) {
+    Authentication* ret        = NULL;
+    
+    BCHAR* data       = NULL;    
+    Meta*  meta       = NULL;
+    
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+
+    data = XMLProcessor::getElementContent (xml, DATA , NULL);
+    t = XMLProcessor::getElementContentLevel (xml, META , NULL);
+    meta = getMeta(t);
+    if (t) {delete [] t; t = NULL;}
+    if (data || meta) {    
+        ret = new Authentication(meta, data);
+    }
+    safeDel(&data);
+    deleteMeta(&meta);
+    
+    return ret;
+}
+
+Meta* Parser::getMeta(BCHAR* xml) {
+    Meta* ret        = NULL;
+    MetInf* metInf   = NULL;    
+    
+    metInf = getMetInf(xml);            
+    if (metInf) {
+        ret = new Meta();
+        ret->setMetInf(metInf);  
+    }
+    
+    deleteMetInf(&metInf);    
+
+    return ret;
+}
+
+MetInf* Parser::getMetInf(BCHAR* xml) {
+    MetInf* ret             = NULL;
+    
+    BCHAR*     format     = NULL;
+    BCHAR*     type       = NULL;
+    BCHAR*     mark       = NULL;
+    Anchor*      anchor     = NULL;
+    BCHAR*     version    = NULL;
+    NextNonce*   nextNonce  = NULL;
+    long         maxMsgSize = 0;
+    long         maxObjSize = 0;
+    long         size       = 0;
+    ArrayList*   emi        = NULL;
+    Mem*         mem        = NULL; 
+    
+    BCHAR*         maxMsgSizeW   = NULL;
+    BCHAR*         maxObjSizeW   = NULL;
+    BCHAR*         sizeW         = NULL;    
+    
+    // get all the values
+
+    format       = XMLProcessor::getElementContent (xml, FORMAT   , NULL);
+    type         = XMLProcessor::getElementContent (xml, TYPE     , NULL);
+    mark         = XMLProcessor::getElementContent (xml, MARK     , NULL);
+    
+    anchor       = getAnchor(xml);
+    version      = XMLProcessor::getElementContent (xml, VERSIONSTR       , NULL);
+    nextNonce    = getNextNonce(xml);
+    
+    maxMsgSizeW  = XMLProcessor::getElementContent (xml, MAX_MESSAGE_SIZE     , NULL);
+    maxObjSizeW  = XMLProcessor::getElementContent (xml, MAX_OBJ_SIZE     , NULL);
+    sizeW        = XMLProcessor::getElementContent (xml, SIZE             , NULL);
+        
+    if (maxMsgSizeW) {
+        maxMsgSize = bstrtol(maxMsgSizeW, NULL, 10);
+    }
+    if (maxObjSizeW) {
+        maxObjSize = bstrtol(maxObjSizeW, NULL, 10);
+    }
+    if (sizeW) {
+        size = bstrtol(sizeW, NULL, 10);
+    }
+        
+    emi          = getEMI(xml);
+    mem          = getMem(xml);    
+    
+    // check if someting is null, 0 or zero lenght
+    BOOL isToCreate = FALSE;
+    isToCreate = NotNullCheck(7, format, type, mark, version, maxMsgSizeW, maxObjSizeW, sizeW)
+                 || NotZeroArrayLenght(1, emi)
+                 || (mem)
+                 || (anchor) 
+                 || (nextNonce);
+                
+    if (isToCreate) {
+        ret = new MetInf(format, type, mark, size, anchor, version, nextNonce, maxMsgSize,
+                         maxObjSize, emi, mem);
+    }
+    deleteAll(7, &format, &type, &mark, &version, &maxMsgSizeW, &maxObjSizeW, &sizeW);
+       
+    deleteAnchor(&anchor);
+    deleteNextNonce(&nextNonce);
+    deleteArrayList(&emi);    
+    deleteMem(&mem);
+    
+    return ret;    
+}
+
+
+ArrayList* Parser::getSources(BCHAR* xml) {
+    
+    Source* source = NULL; 
+    SourceArray* sourceArray = NULL;
+    unsigned int pos = 0, previous = 0;
+    ArrayList* list = new ArrayList();
+
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent(&xml[pos], SOURCE, &pos);
+    while ((source = getSource(t)) != NULL) {
+        if (source) {
+            sourceArray = new SourceArray(source);
+            list->add(*sourceArray); // in the ArrayList NULL element cannot be inserted
+            deleteSource(&source);            
+            deleteSourceArray(&sourceArray);            
+        }
+        pos += previous;
+        previous = pos;
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContent(&xml[pos], SOURCE, &pos);
+    }
+    if (t) { delete [] t; t = NULL;}
+    return list;    
+}
+
+
+Source* Parser::getSource(BCHAR* xml) {
+    Source* ret      = NULL;
+    BCHAR* locURI  = NULL;
+    BCHAR* locName = NULL;
+    locURI  = XMLProcessor::getElementContent (xml, LOC_URI, NULL);
+    locName = XMLProcessor::getElementContent (xml, LOC_NAME, NULL);
+    
+    if (NotNullCheck(2, locURI, locName)) {
+        ret = new Source(locURI, locName);
+    }
+    
+    safeDel(&locURI);
+    safeDel(&locName);
+    
+    return ret;
+}
+
+Target* Parser::getTarget(BCHAR* xml) {
+    Target*  ret      = NULL;
+    BCHAR* locURI   = NULL;
+    BCHAR* locName  = NULL;
+    
+    locURI  = XMLProcessor::getElementContent (xml, LOC_URI, NULL);
+    locName = XMLProcessor::getElementContent (xml, LOC_NAME, NULL);
+    
+    if (NotNullCheck(2, locURI, locName)) {
+        ret = new Target(locURI, locName);
+    }
+    
+    safeDel(&locURI);
+    safeDel(&locName);
+
+    return ret;
+}
+
+Anchor* Parser::getAnchor(BCHAR* xml) {
+    Anchor*  ret    = NULL;
+    BCHAR* last   = NULL;
+    BCHAR* next   = NULL;
+    
+    last  = XMLProcessor::getElementContent (xml, LAST, NULL);
+    next  = XMLProcessor::getElementContent (xml, NEXT, NULL);
+    
+    if (NotNullCheck(2, last, next)) {
+        ret = new Anchor(last, next);
+    }
+    
+    safeDel(&next);
+    safeDel(&last);
+
+    return ret;   
+}
+
+NextNonce* Parser::getNextNonce(BCHAR* xml) {
+    NextNonce* ret   = NULL;
+    BCHAR* value   = NULL;   
+    
+    value  = XMLProcessor::getElementContent (xml, NEXT_NONCE, NULL);
+
+    if (NotNullCheck(1, value)) {
+
+        ret = new NextNonce(value);        
+    }
+    
+    safeDel(&value);
+    return ret;   
+}
+
+Mem* Parser::getMem(BCHAR* xml) {
+    Mem* ret            = NULL;
+    BCHAR* freeMemW   = NULL;   
+    BCHAR* sharedMemW = NULL;
+    BCHAR* freeIDW    = NULL;
+        
+    BOOL    sharedMem   = NULL;
+    long    freeMem     = 0;
+    long    freeID      = 0;
+    
+    BOOL isToCreate = FALSE;
+
+    freeMemW    = XMLProcessor::getElementContent (xml, FREE_MEM,   NULL);
+    sharedMemW  = XMLProcessor::getElementContent (xml, SHARED_MEM, NULL);
+    freeIDW     = XMLProcessor::getElementContent (xml, FREE_ID,    NULL);
+    
+    isToCreate = NotNullCheck(3, freeMemW, sharedMemW, freeIDW);
+
+    if (freeMemW != NULL) {
+        freeMem = bstrtol(freeMemW, NULL, 10);
+    }
+    if (freeIDW != NULL) {
+        freeID = bstrtol(freeIDW, NULL, 10);
+    } 
+    if (sharedMemW != NULL) {
+        sharedMem = bstrtol(sharedMemW, NULL, 10);
+    }
+    
+    if (isToCreate) {
+        ret = new Mem(sharedMem, freeMem, freeID);
+    }
+
+    safeDel(&freeMemW);
+    safeDel(&freeIDW);
+    safeDel(&sharedMemW);
+
+    return ret;   
+}
+
+
+SessionID* Parser::getSessionID(BCHAR* content) {
+    SessionID* ret = NULL;
+    if (content) {
+        ret = new SessionID(content);
+    }
+    return ret;
+}
+
+VerDTD* Parser::getVerDTD(BCHAR* content) {
+    VerDTD* ret = NULL;
+    if (content) {
+        ret = new VerDTD(content);
+    }
+    return ret;
+}
+
+VerProto* Parser::getVerProto(BCHAR* content) {
+    VerProto* ret = NULL;
+    if (content) {
+        ret = new VerProto(content);
+    }
+    return ret;
+}
+
+SyncBody* Parser::getSyncBody(BCHAR* xml) {
+    
+    SyncBody* syncBody   = NULL;
+    BOOL finalMsg        = FALSE;
+    ArrayList* commands;
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    commands = getCommands(xml);
+    t = XMLProcessor::getElementContent(xml, FINAL_MSG, NULL);
+    finalMsg = getFinalMsg(t);
+    if (t) {delete [] t; t = NULL;}
+    syncBody = new SyncBody(commands, finalMsg);
+    
+    deleteArrayList(&commands);    
+
+    return syncBody;
+}
+
+/*
+* The sequence tag can contains the common commands (Add, Replace, Delete, Copy) and
+* Alert
+* Exec
+* Get
+* Map
+*
+* Atomic
+* Sync
+*/
+Sequence* Parser::getSequence(BCHAR* xml) {    
+
+    Sequence* ret           = NULL;
+        
+    Meta*   meta            = NULL;
+    BOOL    noResp          = NULL;
+    CmdID*  cmdID           = NULL;
+    ArrayList* commands     = new ArrayList(); 
+    Sync* sync              = NULL;
+    Atomic* atomic          = NULL;
+    
+    Alert* alert            = NULL;
+    Map*   map              = NULL;
+    Get*   get              = NULL;
+    Exec* exec              = NULL;
+
+    ArrayList* list     = new ArrayList(); 
+    unsigned int pos = 0, previous = 0;
+
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent(xml, CMD_ID, NULL);
+    cmdID = getCmdID(t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContentLevel (xml,  META  , NULL);
+    meta = getMeta(t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
+    noResp   = getNoResp(t);
+    if (t) {delete [] t; t = NULL;}
+    // list of commands that must not be leaf of Sync and Atomic
+    commands = getCommonCommandList(xml, T("Atomic&Sync"));    
+
+    // Alert
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContentLevel(&xml[pos], ALERT, &pos);
+    while ((alert = getAlert(t)) != NULL) {
+        if (alert) {
+            list->add(*alert); // in the ArrayList NULL element cannot be inserted
+            deleteAlert(&alert);            
+        }
+        pos += previous;
+        previous = pos; 
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentLevel(&xml[pos], ALERT, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            commands->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);
+
+    // Map
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContentLevel(&xml[pos], MAP, &pos);
+    while ((map = getMap(t)) != NULL) {
+        if (map) {
+            list->add(*map); // in the ArrayList NULL element cannot be inserted
+            deleteMap(&map);            
+        }
+        pos += previous;
+        previous = pos;
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentLevel(&xml[pos], MAP, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            commands->add(*list->get(i));
+        }
+    }        
+
+    deleteArrayList(&list);
+    
+    // Get
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContentLevel(&xml[pos], GET, &pos);
+    while ((get = getGet(t)) != NULL) {
+        if (get) {
+            list->add(*get); // in the ArrayList NULL element cannot be inserted
+            deleteGet(&get);            
+        }
+        pos += previous;
+        previous = pos;
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentLevel(&xml[pos], GET, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            commands->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);   
+   
+    // Exec
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContentLevel(&xml[pos], EXEC, &pos);
+    while ((exec = getExec(t)) != NULL) {
+        if (exec) {
+            list->add(*exec); // in the ArrayList NULL element cannot be inserted
+            deleteExec(&exec);            
+        }
+        pos += previous;
+        previous = pos;
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentLevel(&xml[pos], EXEC, &pos);
+    }
+    if(t) {delete [] t; t = NULL;}
+    
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            commands->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);
+
+    BCHAR* element = XMLProcessor::getElementContentLevel (xml,  SYNC, NULL);
+
+    if (element) {       
+        sync = getSync(element);
+        if (sync) {
+            commands->add(*sync);
+            deleteSync(&sync);
+        }
+        safeDel(&element);
+    } 
+
+    element = XMLProcessor::getElementContentLevel (xml,  ATOMIC, NULL);
+
+    if (element) {    
+        atomic = getAtomic(element);
+        if (atomic) {
+            commands->add(*atomic);
+            deleteAtomic(&atomic);
+        }
+        safeDel(&element);
+    } 
+
+
+    if ((cmdID)   || 
+        (meta)    ||
+        NotZeroArrayLenght(1, commands)) {
+        
+        ret = new Sequence(cmdID, noResp, meta, commands);
+    }
+
+    deleteMeta(&meta);    
+    deleteCmdID(&cmdID);
+    deleteArrayList(&commands);
+
+    return ret;
+}
+
+/*
+* The Atomic tag can contains the common commands (Add, Replace, Delete, Copy) and
+* Alert
+* Exec
+* Get
+* Map
+*
+* Atomic
+* Sync
+* Sequence
+*/
+Atomic* Parser::getAtomic(BCHAR* xml) {    
+
+    Atomic* ret             = NULL;
+
+    Meta*   meta            = NULL;
+    BOOL    noResp          = NULL;
+    CmdID*  cmdID           = NULL;
+    ArrayList* commands     = new ArrayList(); 
+    Sync* sync              = NULL;
+    Sequence* sequence      = NULL;
+    BCHAR* element = NULL;
+    
+    Alert* alert            = NULL;
+    Map*   map              = NULL;
+    Get*   get              = NULL;
+    Exec* exec              = NULL;
+
+    ArrayList* list     = new ArrayList(); 
+    unsigned int pos = 0, previous = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent(xml, CMD_ID, NULL);
+    cmdID    = getCmdID(t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContentLevel(xml,  META  , NULL);
+    meta     = getMeta       (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent(xml, NO_RESP, NULL);
+    noResp   = getNoResp(t);
+    if (t) {delete [] t; t = NULL;}
+    // list of commands that must not be leaf of Sync and Atomic
+    commands = getCommonCommandList(xml, T("Sync&Sequence"));
+    
+    // Alert
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContentLevel(&xml[pos], ALERT, &pos);
+    while ((alert = getAlert(t)) != NULL) {
+        if (alert) {
+            list->add(*alert); // in the ArrayList NULL element cannot be inserted
+            deleteAlert(&alert);            
+        }
+        pos += previous;
+        previous = pos;
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentLevel(&xml[pos], ALERT, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            commands->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);
+
+    // Map
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContentLevel(&xml[pos], MAP, &pos);
+    while ((map = getMap(t)) != NULL) {
+        if (map) {
+            list->add(*map); // in the ArrayList NULL element cannot be inserted
+            deleteMap(&map);            
+        }
+        pos += previous;
+        previous = pos; 
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentLevel(&xml[pos], MAP, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            commands->add(*list->get(i));
+        }
+    }        
+
+    deleteArrayList(&list);
+    
+    // Get
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContentLevel(&xml[pos], GET, &pos);
+    while ((get = getGet(t)) != NULL) {
+        if (get) {
+            list->add(*get); // in the ArrayList NULL element cannot be inserted
+            deleteGet(&get);            
+        }
+        pos += previous;
+        previous = pos; 
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentLevel(&xml[pos], GET, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            commands->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);   
+   
+    // Exec
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContentLevel(&xml[pos], EXEC, &pos);
+    while ((exec = getExec(t)) != NULL) {
+        if (exec) {
+            list->add(*exec); // in the ArrayList NULL element cannot be inserted
+            deleteExec(&exec);            
+        }
+        pos += previous;
+        previous = pos;
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentLevel(&xml[pos], EXEC, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            commands->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);
+
+    element = XMLProcessor::getElementContentLevel (xml,  SYNC , NULL);
+    
+    if (element) {
+        sync = getSync(element);
+        if (sync) {
+            commands->add(*sync);
+            deleteSync(&sync);
+        }
+        safeDel(&element);
+    }
+    
+    element = XMLProcessor::getElementContentLevel (xml,  SEQUENCE, NULL);    
+    
+    if (element) {
+        sequence = getSequence(element);
+        if (sequence) {
+            commands->add(*sequence);
+            deleteSequence(&sequence);
+        }
+        safeDel(&element);
+    }    
+
+    //
+    // TBD: Atomic
+    //
+
+
+    if ((cmdID)   || 
+        (meta)    ||
+        NotZeroArrayLenght(1, commands)) {
+        
+        ret = new Atomic(cmdID, noResp, meta, commands);
+    }
+
+    deleteMeta(&meta);    
+    deleteCmdID(&cmdID);
+    deleteArrayList(&commands);
+
+    return ret;
+}
+
+/*
+* Contains the commands that the <sync> tag can have.
+*    Add    
+*    Replace
+*    Delete 
+*    Copy   
+*    Atomic 
+*    Map    
+*    Sync   
+*/
+
+Sync* Parser::getSync(BCHAR* xml) {    
+
+    Sync* ret               = NULL;
+    Sequence* sequence      = NULL;
+    Atomic* atomic          = NULL;
+    Cred*   cred            = NULL;
+    Meta*   meta            = NULL;
+    BOOL    noResp          = NULL;
+    CmdID*  cmdID           = NULL;
+    Target* target          = NULL;
+    Source* source          = NULL;
+    ArrayList* commands     = new ArrayList();   
+    long numberOfChanges    = 0;
+    BCHAR* numberOfChangesW = NULL;
+
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent(xml, CMD_ID,  NULL);
+    cmdID    = getCmdID      (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent(xml, TARGET,  NULL);
+    target   = getTarget     (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent(xml, SOURCE,  NULL);
+    source   = getSource     (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContentLevel (xml,  META  ,NULL);
+    meta     = getMeta       (t);
+    if (t) {delete [] t; t = NULL;}
+    numberOfChangesW = XMLProcessor::getElementContent (xml,  NUMBER_OF_CHANGES ,NULL);
+    if (numberOfChangesW) {
+        numberOfChanges = bstrtol(numberOfChangesW, NULL, 10);
+    }
+
+    t = XMLProcessor::getElementContent (xml, CRED   ,NULL);
+    cred     = getCred       (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
+    noResp   = getNoResp    (t);
+    if (t) {delete [] t; t = NULL;}
+    commands = getCommonCommandList(xml, T("Atomic&Sequence"));
+    
+    BCHAR* element = XMLProcessor::getElementContentExcept(xml,  SEQUENCE, T("Atomic"), NULL);
+    
+    if (element) {
+        sequence = getSequence(element);
+        if (sequence) {
+            commands->add(*sequence);
+            deleteSequence(&sequence);
+        }
+        safeDel(&element);
+    }
+
+    element = XMLProcessor::getElementContentExcept(xml,  ATOMIC, T("Atomic&Sequence"), NULL);
+    
+    if (element) {
+        atomic = getAtomic(element);
+        if (atomic) {
+            commands->add(*atomic);
+            deleteAtomic(&atomic);
+        }
+        safeDel(&element);
+    }
+    
+    if ((cmdID)   || 
+        (cred)    || 
+        (target)  ||
+        (source)  ||
+        (meta)    ||
+        NotZeroArrayLenght(1, commands)) {
+        
+        ret = new Sync(cmdID, noResp, cred, target, source, meta, numberOfChanges, commands);
+    }
+
+    deleteCred(&cred);
+    deleteMeta(&meta);    
+    deleteCmdID(&cmdID);
+    deleteTarget(&target);
+    deleteSource(&source);
+    deleteArrayList(&commands);
+
+    return ret;
+}
+
+ArrayList* Parser::getCommonCommandList(BCHAR* xml, BCHAR* except) {
+
+    ArrayList* commands = new ArrayList();
+    ArrayList* list = new ArrayList();
+
+    //
+    //Delete
+    //    
+    list = getDels(xml, except);   
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            commands->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);  
+
+    //
+    //Add
+    //    
+    list = getAdds(xml, except);
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            commands->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);    
+    
+    //
+    //Replace
+    //    
+    list = getReplaces(xml, except);
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            commands->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);  
+        
+
+    //
+    //Copy
+    //    
+    list = getCopies(xml, except);   
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            commands->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);  
+
+    return commands;
+}
+
+Copy* Parser::getCopy(BCHAR* xml) {
+    Copy* ret = NULL;
+        
+    CmdID*      cmdID   = NULL;
+    BOOL        noResp  = NULL;
+    Cred*       cred    = NULL;
+    Meta*       meta    = NULL;
+    ArrayList*  items   = NULL;
+
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
+    cmdID   = getCmdID     (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContentLevel (xml, META,    NULL);
+    meta    = getMeta      (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
+    cred    = getCred      (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
+    noResp  = getNoResp    (t);
+    if (t) {delete [] t; t = NULL;}
+    items = getItems(xml);
+    
+    if ((cmdID) || 
+        (cred)  || 
+        NotZeroArrayLenght(1, items)                                        
+        )  {
+
+        ret = new Copy(cmdID, noResp, cred, meta, items);
+    }
+    
+    deleteCmdID(&cmdID);
+    deleteMeta(&meta);
+    deleteCred(&cred);
+    deleteArrayList(&items);    
+
+    return ret;
+}
+
+
+Add* Parser::getAdd(BCHAR* xml) {
+    Add* ret = NULL;
+
+    CmdID*      cmdID   = NULL;
+    BOOL        noResp  = NULL;
+    Cred*       cred    = NULL;
+    Meta*       meta    = NULL;
+    ArrayList*  items   = NULL;
+    
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
+    cmdID   = getCmdID     (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContentLevel (xml, META,    NULL);
+    meta    = getMeta      (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
+    cred    = getCred      (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
+    noResp  = getNoResp    (t);
+    if (t) {delete [] t; t = NULL;}
+    items = getItems(xml);
+    
+    if ((cmdID) || 
+        (cred)  || 
+        NotZeroArrayLenght(1, items)                                        
+        )  {
+
+        ret = new Add(cmdID, noResp, cred, meta, items);
+    }
+    
+    deleteCmdID(&cmdID);
+    deleteMeta(&meta);
+    deleteCred(&cred);
+    deleteArrayList(&items);    
+
+    return ret;
+}
+
+Delete* Parser::getDelete(BCHAR* xml) {
+    Delete* ret = NULL;
+       
+    CmdID*      cmdID   = NULL;
+    BOOL        noResp  = NULL;
+    BOOL        archive = NULL;
+    BOOL        sftDel  = NULL;
+    Cred*       cred    = NULL;
+    Meta*       meta    = NULL;
+    ArrayList*  items   = NULL;
+
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
+    cmdID   = getCmdID     (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContentLevel (xml, META,    NULL);
+    meta    = getMeta      (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
+    cred    = getCred      (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
+    noResp  = getNoResp    (t);
+    if (t) {delete [] t; t = NULL;}
+    items = getItems(xml);
+    
+    if ((cmdID) || 
+        (cred)  || 
+        NotZeroArrayLenght(1, items)                                        
+        )  {
+
+        ret = new Delete(cmdID, noResp, archive, sftDel, cred, meta, items);
+    }
+        
+    deleteCmdID(&cmdID);
+    deleteMeta(&meta);
+    deleteCred(&cred);
+    deleteArrayList(&items);    
+
+    return ret;
+}
+
+Replace* Parser::getReplace(BCHAR* xml) {
+    Replace* ret = NULL;
+
+    CmdID*      cmdID   = NULL;
+    BOOL        noResp  = NULL;
+    Cred*       cred    = NULL;
+    Meta*       meta    = NULL;
+    ArrayList*  items   = NULL;
+
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
+    cmdID   = getCmdID     (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContentLevel (xml, META,    NULL);
+    meta    = getMeta      (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
+    cred    = getCred      (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
+    noResp  = getNoResp    (t);
+    if (t) {delete [] t; t = NULL;}
+    items = getItems(xml);
+    
+    if ((cmdID) || 
+        (cred)  || 
+        NotZeroArrayLenght(1, items)                                        
+        )  {
+
+        ret = new Replace(cmdID, noResp, cred, meta, items);
+    }
+        
+    deleteCmdID(&cmdID);
+    deleteMeta(&meta);
+    deleteCred(&cred);
+    deleteArrayList(&items);    
+
+    return ret;
+}
+
+MapItem* Parser::getMapItem(BCHAR* xml) {
+    MapItem* ret = NULL;
+    
+    Target*    target = NULL;
+    Source*    source = NULL;
+    
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent(xml, TARGET,NULL);
+    target   = getTarget(t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent(xml, SOURCE,NULL);
+    source   = getSource(t);
+    
+    if ((target)|| 
+        (source)) {
+
+        ret = new MapItem(target, source);
+    }
+    
+    deleteTarget(&target);
+    deleteSource(&source);
+    
+    return ret;
+}
+
+/*
+* Returns an ArrayList of mapItem command
+*/
+ArrayList* Parser::getMapItems(BCHAR* xml) {
+    
+    MapItem* mapItem = NULL;    
+    unsigned int pos = 0, previous = 0;
+    ArrayList* list = new ArrayList();
+
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent(&xml[pos], MAP_ITEM, &pos);
+    while ((mapItem = getMapItem(t)) != NULL) {
+        if (mapItem) {
+            list->add(*mapItem); // in the ArrayList NULL element cannot be inserted
+            deleteMapItem(&mapItem);            
+        }
+        pos += previous;
+        previous = pos;  
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContent(&xml[pos], MAP_ITEM, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+    return list;   
+}
+
+Map* Parser::getMap(BCHAR* xml) {
+    Map* ret = NULL;
+
+    CmdID*     cmdID  = NULL;
+    Cred*      cred   = NULL;
+    Meta*      meta   = NULL;
+    
+    Target*    target = NULL;
+    Source*    source = NULL;
+    ArrayList* mapItems; //MapItem[]
+    
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
+    cmdID   = getCmdID(t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContentLevel (xml, META,    NULL);
+    meta    = getMeta(t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
+    cred    = getCred(t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent(xml, TARGET,NULL);
+    target   = getTarget(t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent(xml, SOURCE,  NULL);
+    source   = getSource(t);
+    if (t) {delete [] t; t = NULL;}
+    mapItems = getMapItems(xml);
+    
+    if ((cmdID) ||
+        (meta)  ||
+        (cred)  ||
+        (target)|| 
+        (source)|| 
+        NotZeroArrayLenght(1, mapItems)                                        
+        )  {
+
+        ret = new Map(cmdID, target, source, cred, meta, mapItems);
+    }
+    
+    deleteCmdID(&cmdID);
+    deleteMeta(&meta);
+    deleteCred(&cred);
+    deleteTarget(&target);
+    deleteSource(&source);
+    deleteArrayList(&mapItems);    
+
+    return ret;
+}
+
+
+/*
+* Returns an ArrayList of copy command
+*/
+ArrayList* Parser::getCopies(BCHAR* xml, BCHAR* except) {
+    
+    Copy* copy = NULL;    
+    unsigned int pos = 0, previous = 0;
+    ArrayList* list = NULL;
+    
+   /*
+    * except is set to SYNC if we are looking for Copy commands external from <sync> tag
+    */
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContentExcept(&xml[pos], COPY, except, &pos);
+    while ((copy = getCopy(t)) != NULL) {
+        if (copy) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*copy); // in the ArrayList NULL element cannot be inserted
+            deleteCopy(&copy);            
+        }
+        pos += previous;
+        previous = pos; 
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentExcept(&xml[pos], COPY, except, &pos);
+    }  
+    if (t) {delete [] t; t = NULL;}
+    return list;   
+}
+
+/*
+* Returns an ArrayList of add command
+*/
+ArrayList* Parser::getAdds(BCHAR* xml, BCHAR* except) {
+    
+    Add* add         = NULL;    
+    unsigned int pos = 0, previous = 0;
+    ArrayList* list  = NULL;
+    BCHAR* t         = NULL;
+   /*
+    * except is set to SYNC if we are looking for Add commands external from <sync> tag
+    */
+    t = XMLProcessor::getElementContentExcept(&xml[pos], ADD, except, &pos);
+    while ((add = getAdd(t)) != NULL) {
+        if (add) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*add); // in the ArrayList NULL element cannot be inserted
+            deleteAdd(&add);            
+        }
+        pos += previous;
+        previous = pos;                
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentExcept(&xml[pos], ADD, except, &pos);
+    }   
+    if (t) { delete [] t; t = NULL; }
+    return list;   
+}
+
+/*
+* Returns an ArrayList of Replace commands
+*/
+ArrayList* Parser::getReplaces(BCHAR* xml, BCHAR* except) {
+    
+    Replace* replace = NULL;    
+    unsigned int pos = 0, previous = 0;
+    ArrayList* list = NULL;
+    BCHAR* t        = NULL;
+
+    t = XMLProcessor::getElementContentExcept(&xml[pos], REPLACE, except, &pos);
+    while ((replace = getReplace(t)) != NULL) {
+        if (replace) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*replace); // in the ArrayList NULL element cannot be inserted
+            deleteReplace(&replace);            
+        }
+        pos += previous;
+        previous = pos;                
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentExcept(&xml[pos], REPLACE, except, &pos);
+    }
+    if (t) { delete [] t; t = NULL; }
+    return list;   
+}
+
+/*
+* Returns an ArrayList of Dels command
+*/
+ArrayList* Parser::getDels(BCHAR* xml, BCHAR* except) {
+    
+    Delete* del        = NULL;    
+    unsigned int pos   = 0, previous = 0;
+    ArrayList* list    = NULL;
+    BCHAR* t           = NULL;
+
+    t = XMLProcessor::getElementContentExcept(&xml[pos], DEL, except, &pos);
+    while ((del = getDelete(t)) != NULL) {
+        if (del) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*del); // in the ArrayList NULL element cannot be inserted
+            deleteDelete(&del);            
+        }
+        pos += previous;
+        previous = pos;                
+        if (t) { delete [] t; t = NULL;}
+        t = XMLProcessor::getElementContentExcept(&xml[pos], DEL, except, &pos);
+    }
+    if (t) { delete [] t; t = NULL; }
+    return list;   
+}
+
+/*
+Commands of SyncBody tag
+    Alert
+    Add     
+    Atomic
+    Copy    
+    Delete
+    Exec    
+    Get
+    Map     
+    Put     
+    Replace
+    Results 
+    Search  
+    Sequence
+    Status  
+    Sync
+*/
+ArrayList* Parser::getCommands(BCHAR* xml) {    
+    ArrayList* ret    = new ArrayList();
+    
+    ArrayList* list     = NULL;
+    Alert* alert        = NULL;
+    Map*   map          = NULL;
+    Get*   get          = NULL;
+    Put*   put          = NULL;
+    Status* status      = NULL;
+    Results* result     = NULL;
+    Exec* exec          = NULL;
+    Search* search      = NULL;
+
+    Sequence* sequence  = NULL;
+    Atomic* atomic      = NULL;
+    Sync* sync          = NULL;
+    unsigned int pos = 0, previous = 0;
+    BCHAR* t            = NULL;
+
+
+    // Status
+    t = XMLProcessor::getElementContent(&xml[pos], STATUS, &pos);
+    while ((status = getStatus(t)) != NULL) {
+        if (status) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*status); // in the ArrayList NULL element cannot be inserted
+            deleteStatus(&status);            
+        }
+        pos += previous;
+        previous = pos;                
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContent(&xml[pos], STATUS, &pos);
+    }
+    if (t) { delete [] t; t = NULL; }
+   
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            ret->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);    
+        
+    // Alert: use the getElementContentLevel because Alert could be also in Atomic and Sequence commands
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContentLevel(&xml[pos], ALERT, &pos);
+    while ((alert = getAlert(t)) != NULL) {
+        if (alert) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*alert); // in the ArrayList NULL element cannot be inserted
+            deleteAlert(&alert);            
+        }
+        pos += previous;
+        previous = pos;       
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentLevel(&xml[pos], ALERT, &pos);
+    }
+    if (t) { delete [] t; t = NULL; }
+
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            ret->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);
+
+    // Map: use the getElementContentLevel because Map could be also in Atomic and Sequence commands
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContentLevel(&xml[pos], MAP, &pos);
+    while ((map = getMap(t)) != NULL) {
+        if (map) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*map); // in the ArrayList NULL element cannot be inserted
+            deleteMap(&map);            
+        }
+        pos += previous;
+        previous = pos;   
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentLevel(&xml[pos], MAP, &pos);
+    }
+    if (t) { delete [] t; t = NULL; }
+    
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            ret->add(*list->get(i));
+        }
+    }        
+
+    deleteArrayList(&list);
+    
+    // Get: use the getElementContentLevel because Get could be also in Atomic and Sequence commands
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContent(&xml[pos], GET, &pos);
+    while ((get = getGet(t)) != NULL) {
+        if (get) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*get); // in the ArrayList NULL element cannot be inserted
+            deleteGet(&get);            
+        }
+        pos += previous;
+        previous = pos;   
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContent(&xml[pos], GET, &pos);
+    }
+    if (t) { delete [] t; t = NULL; }
+
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            ret->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);
+
+    // Put
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContent(&xml[pos], PUT, &pos);
+    while ((put = getPut(t)) != NULL) {
+        if (put) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*put); // in the ArrayList NULL element cannot be inserted
+            deletePut(&put);            
+        }
+        pos += previous;
+        previous = pos;   
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContent(&xml[pos], PUT, &pos);
+    }
+    if (t) { delete [] t; t = NULL; }
+    
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            ret->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);
+
+    // Results
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContent(&xml[pos], RESULTS, &pos);
+    while ((result = getResult(t)) != NULL) {
+        if (result) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*result); // in the ArrayList NULL element cannot be inserted
+            deleteResults(&result);            
+        }
+        pos += previous;
+        previous = pos;         
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContent(&xml[pos], RESULTS, &pos);
+    }
+    if (t) { delete [] t; t = NULL; }
+
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            ret->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);
+
+    // Exec: use the getElementContentLevel because Exec could be also in Atomic and Sequence commands
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContentLevel(&xml[pos], EXEC, &pos);
+    while ((exec = getExec(t)) != NULL) {
+        if (exec) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*exec); // in the ArrayList NULL element cannot be inserted
+            deleteExec(&exec);            
+        }
+        pos += previous;
+        previous = pos;     
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentLevel(&xml[pos], EXEC, &pos);
+    }
+    if (t) { delete [] t; t = NULL; }
+    
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            ret->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);
+
+    // Search
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContent(&xml[pos], SEARCH, &pos);
+    while ((search = getSearch(t)) != NULL) {
+        if (search) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*search); // in the ArrayList NULL element cannot be inserted
+            deleteSearch(&search);            
+        }
+        pos += previous;
+        previous = pos;              
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContent(&xml[pos], SEARCH, &pos);
+    }
+    if (t) { delete [] t; t = NULL; }
+
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            ret->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);
+
+    // get the Sync commands. not belonging to Atomic and Sequence
+    //sync = getSync(XMLProcessor::getElementContentExcept (xml, SYNC, T("Atomic&Sequence"), NULL));
+    
+    //if (sync) {
+    //    ret->add(*sync);
+    //    deleteSync(&sync);
+    //}
+    
+    // Sync
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContentExcept(&xml[pos], SYNC, T("Atomic&Sequence"), &pos);
+    while ((sync = getSync(t)) != NULL) {
+        if (sync) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*sync); // in the ArrayList NULL element cannot be inserted
+            deleteSync(&sync);
+        }
+        pos += previous;
+        previous = pos;     
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContentExcept(&xml[pos], SYNC, T("Atomic&Sequence"), &pos);
+    }
+    if (t) { delete [] t; t = NULL; }
+    
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            ret->add(*list->get(i));
+        }
+    }        
+    deleteArrayList(&list);
+
+
+
+    // get the Sequence commands. Not belonging to Atomic and Sync
+    t = XMLProcessor::getElementContentExcept(xml, SEQUENCE, T("Atomic&Sync"), &pos);
+    sequence = getSequence(t);
+    if (t) {delete [] t; t = NULL;}
+    
+    if (sequence) {
+        ret->add(*sequence);
+        deleteSequence(&sequence);
+    }
+    
+    // get the Sequence commands. Not belonging to Sequence and Sync and Atomic
+    t = XMLProcessor::getElementContentExcept(xml, ATOMIC, T("Atomic&Sync&Sequence"), &pos);
+    atomic = getAtomic(t);   
+    if (t) {delete [] t; t = NULL;}
+    
+    if (atomic) {
+        ret->add(*atomic);
+        deleteAtomic(&atomic);
+    }
+    
+    
+    list = getCommonCommandList(xml, T("Atomic&Sync&Sequence"));
+
+    if (list && list->size() > 0) {
+        for (int i = 0; i < list->size(); i++) {
+            ret->add(*list->get(i));
+        }
+    }
+    deleteArrayList(&list);
+    
+    return ret;
+}
+
+Status* Parser::getStatus(BCHAR* xml) {
+    
+    if (!xml)
+        return NULL;
+    
+    Status*     ret         = NULL;
+    
+    CmdID*      cmdID       = NULL;
+    BCHAR*    msgRef      = NULL;
+    BCHAR*    cmdRef      = NULL;
+    BCHAR*    cmd         = NULL;
+    ArrayList*  targetRefs  = new ArrayList();
+    ArrayList*  sourceRefs  = new ArrayList();
+    Cred*       cred        = NULL;
+    Chal*       chal        = NULL;
+    Data*       data        = NULL;
+    ArrayList*  items       = new ArrayList();
+
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
+    cmdID = getCmdID(t);
+    if (t) {delete [] t; t = NULL;}
+    
+    msgRef          = XMLProcessor::getElementContent (xml, MSG_REF, NULL);
+    cmdRef          = XMLProcessor::getElementContent (xml, CMD_REF, NULL);
+    cmd             = XMLProcessor::getElementContent (xml, CMD,     NULL);
+    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
+    cred            = getCred      (t);
+    if (t) {delete [] t; t = NULL;}
+    // get Data <Data>200</Data>
+    t = XMLProcessor::getElementContent (xml, DATA   , NULL);
+    data            = getData      (t);
+    if (t) {delete [] t; t = NULL;}
+    items           = getItems     (xml);
+    targetRefs      = getTargetRefs(xml);
+    sourceRefs      = getSourceRefs(xml);
+    t = XMLProcessor::getElementContent (xml, CHAL   , NULL);
+    chal            = getChal      (t);    
+    if (t) {delete [] t; t = NULL;}
+    
+    if (NotNullCheck(2, msgRef, cmdRef) || (cred) 
+                                        || (data)
+                                        || (cmdID) 
+                                        || (chal) 
+                                        || NotZeroArrayLenght(3, items, targetRefs, sourceRefs)                                        
+                                        )  {
+
+        ret = new Status(cmdID, msgRef, cmdRef, cmd, targetRefs, sourceRefs, cred, chal, data, items);
+    }
+    deleteArrayList(&sourceRefs);
+    deleteArrayList(&targetRefs);
+    deleteArrayList(&items);
+    deleteAll(3, &msgRef, &cmdRef, &cmd);
+    deleteCmdID(&cmdID);
+    deleteCred(&cred);
+    deleteData(&data);
+    deleteChal(&chal);
+
+    return ret;   
+}
+
+Chal* Parser::getChal(BCHAR* xml) {
+    
+    Chal* ret  = NULL;
+    Meta* meta = NULL;
+
+    meta     = getMeta (xml);    
+
+    if (meta) {
+        ret = new Chal(meta);
+        deleteMeta(&meta); 
+    }
+
+    return ret;
+}
+
+ArrayList* Parser::getTargetRefs(BCHAR* xml) {
+    ArrayList* list = new ArrayList();
+    TargetRef* targetRef = NULL;
+    unsigned int pos = 0, previous = 0;
+
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent(&xml[pos], TARGET_REF, &pos);
+    while ((targetRef = getTargetRef(t)) != NULL) {
+        if (targetRef) {
+            list->add(*targetRef); // in the ArrayList NULL element cannot be inserted
+            deleteTargetRef(&targetRef);            
+        }
+        pos += previous;
+        previous = pos;               
+        if (t) {delete [] t; t = NULL;}
+        t = XMLProcessor::getElementContent(&xml[pos], TARGET_REF, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+    
+    return list;
+}
+
+ArrayList* Parser::getSourceRefs(BCHAR* xml) {
+    ArrayList* list = new ArrayList();
+    SourceRef* sourceRef = NULL;
+    unsigned int pos = 0, previous = 0;
+
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent(&xml[pos], SOURCE_REF, &pos);
+    while ((sourceRef = getSourceRef(t)) != NULL) {
+        if (sourceRef) {
+            list->add(*sourceRef); // in the ArrayList NULL element cannot be inserted
+            deleteSourceRef(&sourceRef);            
+        }
+        pos += previous;
+        previous = pos;               
+        if (t) {delete [] t; t = NULL;}
+        t = XMLProcessor::getElementContent(&xml[pos], SOURCE_REF, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+    return list;
+}
+
+SourceRef* Parser::getSourceRef(BCHAR* xml) {    
+    SourceRef* ret = NULL;        
+    Source* source;   
+    
+    source = getSource(xml);    
+    if (source) {
+        ret = new SourceRef(source);
+    } else if (xml) {
+        ret = new SourceRef(xml);
+    }
+    
+    return ret;
+}
+
+TargetRef* Parser::getTargetRef(BCHAR* xml) {    
+    TargetRef* ret = NULL;        
+    Target* target;   
+    
+    target = getTarget(xml);    
+    if (target) {
+        ret = new TargetRef(target);
+    } else if (xml) {
+        ret = new TargetRef(xml);
+    }
+    
+    return ret;
+}
+
+Alert* Parser::getAlert(BCHAR* xml) {
+    
+    Alert* ret = NULL;
+    ArrayList* items = new ArrayList();    
+    
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
+    CmdID* cmdID     = getCmdID   (t);
+    if(t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
+    Cred*  cred      = getCred    (t);
+    if(t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, DATA   , NULL);
+    int    data      = getDataCode(t);
+    if(t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
+    BOOL   noResp    = getNoResp  (t);
+    if(t) {delete [] t; t = NULL;}
+    
+    items = getItems(xml);
+    if (items && items->size() > 0) {
+        ret = new Alert(cmdID, noResp, cred, data, items); //Item[]
+    }
+    
+    deleteCmdID(&cmdID);
+    deleteCred(&cred);
+    deleteArrayList(&items);
+    
+    return ret;
+}
+
+Exec* Parser::getExec(BCHAR* xml) {
+    
+    Exec* ret = NULL;
+    
+    CmdID* cmdID        = NULL;
+    BOOL   noResp       = FALSE;
+    Cred*  cred         = NULL;
+    ArrayList*  items   = new ArrayList();
+
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
+    cmdID     = getCmdID   (t);
+    if(t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
+    cred      = getCred    (t);
+    if(t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
+    noResp    = getNoResp  (t);    
+    if(t) {delete [] t; t = NULL;}
+    items = getItems(xml);
+
+    if (cmdID || NotZeroArrayLenght(1, items) || (cred)) {
+        ret = new Exec(cmdID, noResp, cred, items); 
+    }
+    
+    deleteCmdID(&cmdID);
+    deleteCred(&cred);
+    deleteArrayList(&items);
+    
+    return ret;
+}
+
+Get* Parser::getGet(BCHAR* xml) {
+       
+    Get* ret = NULL;    
+    ArrayList* items = NULL;    
+    
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
+    CmdID* cmdID     = getCmdID   (t);
+    if(t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
+    Cred*  cred      = getCred    (t);
+    if(t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
+    BOOL   noResp    = getNoResp  (t);
+    if(t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContentLevel (xml, META ,   NULL);
+    Meta*  meta      = getMeta    (t);
+    if(t) {delete [] t; t = NULL;}    
+    BCHAR* lang    = XMLProcessor::getElementContent        (xml, LANG, NULL);
+    items = getItems(xml);
+
+    if (NotNullCheck(1, lang)  || (cred) 
+                               || (cmdID) 
+                               || (meta) 
+                               || NotZeroArrayLenght(1, items))  {
+    
+        ret = new Get(cmdID, noResp, lang, cred, meta, items); //Item[]
+    }
+       
+    deleteCmdID(&cmdID);
+    deleteCred(&cred);
+    deleteMeta(&meta);
+    safeDel(&lang);
+    deleteArrayList(&items);
+    
+    return ret;
+}
+
+Put* Parser::getPut(BCHAR* xml) {
+    
+    Put* ret = NULL;    
+    ArrayList* items = NULL;    
+    
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
+    CmdID* cmdID     = getCmdID   (t);
+    if(t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
+    Cred*  cred      = getCred    (t);
+    if(t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
+    BOOL   noResp    = getNoResp  (t);
+    if(t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContentLevel (xml, META ,   NULL);
+    Meta*  meta      = getMeta    (t);
+    if(t) {delete [] t; t = NULL;}
+    BCHAR* lang    = XMLProcessor::getElementContent        (xml, LANG, NULL);        
+    items = getItems(xml);
+
+    if (NotNullCheck(1, lang)  || (cred) 
+                               || (cmdID) 
+                               || (meta) 
+                               || NotZeroArrayLenght(1, items))  {
+    
+        ret = new Put(cmdID, noResp, lang, cred, meta, items); //Item[]
+    }
+       
+    deleteCmdID(&cmdID);
+    deleteCred(&cred);
+    deleteMeta(&meta);
+    safeDel(&lang);
+    deleteArrayList(&items);
+    
+    return ret;
+}
+
+Search* Parser::getSearch(BCHAR* xml) {    
+    
+    Search*     ret      = NULL;
+    CmdID*      cmdID    = NULL;
+    BOOL        noResp   = NULL;
+    BOOL        noResults= NULL;
+    Cred*       cred     = NULL;
+    Target*     target   = NULL;
+    ArrayList*  sources  = new ArrayList();  // an Array of SourceArray object
+    BCHAR*    lang     = NULL;
+    Meta*       meta     = NULL;
+    Data*       data     = NULL;
+    
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
+    cmdID     = getCmdID   (t);
+    if (t) { delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, CRED   , NULL);
+    cred      = getCred    (t);
+    if (t) { delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, NO_RESP, NULL);
+    noResp    = getNoResp  (t);
+    if (t) { delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent(xml, NO_RESULTS, NULL);
+    noResults = getNoResults(t);
+    if (t) { delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent (xml, TARGET,NULL);
+    target    = getTarget  (t);
+    if (t) { delete [] t; t = NULL;}    
+    lang      = XMLProcessor::getElementContent             (xml, LANG, NULL);            
+    t = XMLProcessor::getElementContentLevel (xml, META , NULL);
+    meta      = getMeta    (t);
+    if (t) { delete [] t; t = NULL;}    
+    t = XMLProcessor::getElementContent (xml, DATA ,   NULL);
+    data      = getData    (t);    
+    if (t) { delete [] t; t = NULL;}    
+    sources   = getSources (xml);
+
+    if (NotNullCheck(1, lang) || (cmdID) || (cred) 
+                              || (meta)  || (target) 
+                              || (data)  || NotZeroArrayLenght(1, sources))  {
+                
+        ret = new Search(cmdID, noResp, noResults, cred, target, sources, lang, meta, data);
+    }
+
+    deleteCmdID(&cmdID);
+    deleteCred(&cred);
+    deleteTarget(&target);
+    safeDel(&lang);
+    deleteData(&data);
+    deleteMeta(&meta);
+    deleteArrayList(&sources);
+    
+  return ret;
+}
+
+Results* Parser::getResult(BCHAR* xml) {
+    
+    if (!xml)
+        return NULL;
+    
+    Results*    ret         = NULL;        
+    CmdID*      cmdID       = NULL;
+    BCHAR*    msgRef      = NULL;
+    BCHAR*    cmdRef      = NULL;
+    Meta*       meta        = NULL;   
+    ArrayList*  targetRefs  = new ArrayList(); // it could be an array with only a value
+    ArrayList*  sourceRefs  = new ArrayList();
+    ArrayList*  items       = new ArrayList();
+
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent (xml, CMD_ID , NULL);
+    cmdID           = getCmdID     (t);
+    if (t) {delete [] t; t = NULL;}    
+    msgRef          = XMLProcessor::getElementContent (xml, MSG_REF, NULL);
+    cmdRef          = XMLProcessor::getElementContent (xml, CMD_REF, NULL);
+    t = XMLProcessor::getElementContentLevel(xml, META, NULL);
+    meta            = getMeta      (t);
+    if (t) {delete [] t; t = NULL;}
+    targetRefs      = getTargetRefs(xml);
+    sourceRefs      = getSourceRefs(xml);    
+    items           = getItems     (xml);
+    
+    if (NotNullCheck(2, msgRef, cmdRef) || (cmdID) || (meta) 
+                                        || NotZeroArrayLenght(3, items, targetRefs, sourceRefs)                                        
+                                        )  {
+
+        ret = new Results(cmdID, msgRef, cmdRef, meta, targetRefs, sourceRefs, items);
+    }
+    deleteArrayList(&sourceRefs);
+    deleteArrayList(&targetRefs);
+    deleteArrayList(&items);
+    deleteAll(2, &msgRef, &cmdRef);
+    deleteCmdID(&cmdID);
+    deleteMeta(&meta);
+    
+    return ret;   
+}
+
+
+//
+// return and array list of items
+//
+ArrayList* Parser::getItems(BCHAR* xml) {
+
+    Item* item = NULL;
+    ArrayList* items = NULL;
+    unsigned int pos = 0, previous = 0;
+    BCHAR*      t       = NULL;
+    
+    t = XMLProcessor::getElementContent(&xml[pos], ITEM, &pos);    
+    while ((item = getItem(t)) != NULL) {
+        if (item) {
+            if (!items)
+                items = new ArrayList();
+            items->add(*item);    // in the ArrayList NULL element cannot be inserted
+            deleteItem(&item);    
+        }
+        pos += previous;
+        previous = pos;                
+        if (t) { delete [] t; t = NULL; }
+        t = XMLProcessor::getElementContent(&xml[pos], ITEM, &pos);
+    }
+    if (t) { delete [] t; t = NULL; }
+
+    return items;    
+}
+
+Item* Parser::getItem(BCHAR* xml) {    
+    Item*   ret       = NULL;
+    Target* target    = NULL;
+    Source* source    = NULL;
+    Meta*   meta      = NULL;
+    ComplexData* data = NULL;
+    BOOL moreData     = FALSE;  
+    BCHAR* targetParent = NULL;
+    BCHAR* sourceParent = NULL;
+    BCHAR*      t       = NULL;   
+    unsigned int pos = 0;
+    t = XMLProcessor::getElementContent(xml, TARGET,NULL);
+    target   = getTarget     (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContent(xml, SOURCE,NULL);
+    source   = getSource     (t);
+    if (t) {delete [] t; t = NULL;}
+    t = XMLProcessor::getElementContentLevel(xml, META,NULL);
+    meta     = getMeta       (t);
+    if (t) {delete [] t; t = NULL;}
+    
+    t = XMLProcessor::getElementContent(xml, COMPLEX_DATA,NULL);
+    data     = getComplexData(t);
+    if (t) { delete [] t; t = NULL; } 
+    
+    t = XMLProcessor::getElementContent(xml, MORE_DATA,NULL);
+    moreData = getMoreData   (t);
+    if (t) {delete [] t; t = NULL;}
+    targetParent = XMLProcessor::getElementContent(xml, TARGET_PARENT,      NULL);
+    sourceParent = XMLProcessor::getElementContent(xml, SOURCE_PARENT,      NULL);
+
+    if ((target)     || 
+            (source) || 
+            (meta)   ||
+            (data))  {
+        // ret = new Item(target, source, meta, data, moreData);
+        ret = new Item(target, source, targetParent, sourceParent, meta, data, moreData);
+
+    }
+    
+    deleteTarget     (&target);
+    deleteSource     (&source);
+    deleteMeta       (&meta);
+    deleteComplexData(&data);
+    deleteAll(2, &targetParent, &sourceParent);
+    
+    return ret;
+}
+
+int Parser::getDataCode(BCHAR* content) {    
+   int ret = 0;
+   if (content) {
+        ret = bstrtol(content, NULL, 10);
+   }
+   return ret;
+}
+
+Data* Parser::getData(BCHAR* content) {    
+   Data* ret = 0;
+   if (content) {
+        ret = new Data(content);
+   }
+   return ret;
+}
+
+BOOL Parser::getFinalMsg(BCHAR* content) {    
+    BOOL ret = FALSE;
+    if (content) {
+        ret = TRUE;
+    }
+    return ret;
+}
+
+CmdID* Parser::getCmdID(BCHAR* content) {
+    CmdID* ret = NULL;
+    if (content) {
+        ret = new CmdID(content);
+    }
+    return ret;
+}
+
+ComplexData* Parser::getComplexData(BCHAR* xml) {
+    
+    ComplexData* ret = NULL;
+    Anchor* anchor   = NULL;
+    DevInf* devInf   = NULL;
+    
+    anchor = getAnchor(xml);
+    devInf = getDevInf(xml);    
+    
+    if (anchor || devInf) {
+        ret = new ComplexData(NULL); 
+    
+        if (anchor) 
+            ret->setAnchor(anchor);
+        if (devInf)
+            ret->setDevInf(devInf);
+    }
+    else if (xml) {
+        ret = new ComplexData(xml);
+    }    
+
+    return ret;
+}
+
+DevInf* Parser::getDevInf(BCHAR* xml) {
+    DevInf* ret             = NULL;
+    DataStore* dataStore    = NULL;
+    CTCap* ctCap            = NULL;
+    Ext* ext                = NULL;
+
+    VerDTD* verDTD          = NULL;
+    BCHAR* man            = NULL;
+    BCHAR* mod            = NULL;
+    BCHAR* oem            = NULL;
+    BCHAR* fwV            = NULL;
+    BCHAR* swV            = NULL;
+    BCHAR* hwV            = NULL;
+    BCHAR* devId          = NULL;
+    BCHAR* devTyp         = NULL;
+    ArrayList* dataStores   = NULL;       // DataStore[]
+    ArrayList* ctCaps       = NULL;       // CTCap[]
+    ArrayList* exts         = NULL;       // Ext[]
+    BOOL utc                = NULL;         // if present they Support UTC
+    BOOL supportLargeObjs   = NULL;         // if present they Support largeObject
+    BOOL supportNumberOfChanges = NULL;     // if present they Support NumberOfChanges
+    SyncCap* syncCap        = NULL;
+    
+    BCHAR* value          = NULL;
+    
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent(xml, VER_DTD,NULL);
+    verDTD = getVerDTD(t);
+    if (t) {delete [] t; t = NULL;}
+    man     = XMLProcessor::getElementContent(xml, MAN,           NULL);
+    mod     = XMLProcessor::getElementContent(xml, MOD,           NULL);
+    oem     = XMLProcessor::getElementContent(xml, OEM,           NULL);
+    fwV     = XMLProcessor::getElementContent(xml, FWV,           NULL);
+    swV     = XMLProcessor::getElementContent(xml, SWV,           NULL);
+    hwV     = XMLProcessor::getElementContent(xml, HWV,           NULL);
+    devId   = XMLProcessor::getElementContent(xml, DEV_ID,        NULL);
+    devTyp  = XMLProcessor::getElementContent(xml, DEV_TYP,       NULL);
+
+    t = XMLProcessor::getElementContent(xml, SYNC_CAP,NULL);
+    syncCap = getSyncCap(t);
+    if (t) {delete [] t; t = NULL;}
+    
+    unsigned int previous = 0;
+    pos = 0; 
+        
+    // DataStore
+    t = XMLProcessor::getElementContent(&xml[pos], DATA_STORE, &pos);
+    while ((dataStore = getDataStore(t)) != NULL) {
+        if (dataStore) {
+            if (!dataStores) {
+                dataStores = new ArrayList();                
+            }
+            dataStores->add(*dataStore); // in the ArrayList NULL element cannot be inserted
+            deleteDataStore(&dataStore);            
+        }
+        pos += previous;
+        previous = pos;            
+        if (t) {delete [] t; t = NULL;}
+        t = XMLProcessor::getElementContent(&xml[pos], DATA_STORE, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+        
+    // ctCap
+    pos = 0; previous = 0;
+    t = XMLProcessor::getElementContent(&xml[pos], CT_CAP, &pos);
+    while ((ctCap = getCTCap(t)) != NULL) {
+        if (ctCap) {
+            if (!ctCaps) {
+                ctCaps = new ArrayList();                
+            }
+            ctCaps->add(*ctCap); // in the ArrayList NULL element cannot be inserted
+            deleteCTCap(&ctCap);            
+        }
+        pos += previous;
+        previous = pos;       
+        if (t) {delete [] t; t = NULL;}
+        t = XMLProcessor::getElementContent(&xml[pos], CT_CAP, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+
+    // ext
+    pos = 0; previous = 0;
+    t = XMLProcessor::getElementContent(&xml[pos], EXT, &pos);
+    while ((ext = getExt(t)) != NULL) {
+        if (ext) {
+            if (!exts) {
+                exts = new ArrayList();                
+            }
+            exts->add(*ext); // in the ArrayList NULL element cannot be inserted
+            deleteExt(&ext);            
+        }
+        pos += previous;
+        previous = pos;   
+        if (t) {delete [] t; t = NULL;}
+        t = XMLProcessor::getElementContent(&xml[pos], EXT, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+
+    //
+    // The large object value depends on SUPPORT_LARGE_OBJECT tag.
+    //
+    if ((value = XMLProcessor::getElementContent(xml, SUPPORT_LARGE_OBJECT, NULL)) != NULL) {
+        if (wcscmpIgnoreCase(value, T("TRUE"))) {
+            supportLargeObjs = TRUE;
+        }
+        safeDel(&value);
+    }
+
+    //
+    // The large object value depends on SUPPORT_NUMBER_OF_CHANGES tag. 
+    //    
+    if ((value = XMLProcessor::getElementContent(xml, SUPPORT_NUMBER_OF_CHANGES, NULL)) != NULL) {
+        if (wcscmpIgnoreCase(value, T("TRUE"))) {
+            supportNumberOfChanges = TRUE;
+        }
+        safeDel(&value);
+    }
+
+    //
+    // The large object value depends on UTC tag.
+    //
+    if ((value = XMLProcessor::getElementContent(xml, UTC, NULL)) != NULL) {
+        if (wcscmpIgnoreCase(value, T("TRUE"))) {
+            utc = TRUE;
+        }
+        safeDel(&value);
+    }    
+    
+    if (NotNullCheck(8, man, mod, oem, fwV, swV, hwV, devId, devTyp) ||
+                                     (verDTD)      ||
+                                     (syncCap)     ||
+                                      NotZeroArrayLenght(3, dataStores, ctCaps, exts) ) {
+
+        ret = new DevInf(verDTD, man, mod, oem,  fwV, swV, hwV, devId, devTyp,
+                                dataStores, ctCaps, exts,
+                                utc, supportLargeObjs, supportNumberOfChanges,
+                                syncCap);
+
+    }
+    deleteAll(8, &man, &mod, &oem, &fwV, &swV, &hwV, &devId, &devTyp);
+    deleteArrayList(&dataStores);
+    deleteArrayList(&ctCaps);
+    deleteArrayList(&exts);
+    deleteVerDTD(&verDTD);
+    deleteSyncCap(&syncCap);
+    return ret;
+}
+
+
+/*
+* TBD. There is to use the getNextTag method in xmlProcessor.
+* This CTCap is no nested as a usual XML. See syncml_devinf_v11_20020215.pdf
+*
+*/
+Ext* Parser::getExt(BCHAR* xml) {
+    Ext* ret = NULL;
+    BCHAR* XNam         = NULL;
+    BCHAR* value        = NULL;
+    ArrayList* list     = NULL;
+    StringElement* s    = NULL;
+    unsigned int pos = 0, previous = 0;
+
+    XNam = XMLProcessor::getElementContent(xml, XNAM, NULL);
+
+    // XVal
+    while ((value = XMLProcessor::getElementContent(&xml[pos], XVAL, &pos)) != NULL) {
+        if (value) {
+            if (!list)
+                list = new ArrayList();
+            s = new StringElement(value);
+            list->add(*s); 
+            deleteStringElement(&s);            
+            safeDel(&value);
+        }
+        pos += previous;
+        previous = pos;                
+    }
+       
+    if ( XNam || NotZeroArrayLenght(1, list) ) {
+        ret = new Ext(XNam, list);
+    }
+    
+    safeDel(&XNam);
+    deleteArrayList(&list);
+
+    return ret;
+}
+
+DataStore* Parser::getDataStore(BCHAR* xml) {
+    DataStore* ret = NULL;
+    
+    SourceRef*       sourceRef      = NULL;
+    BCHAR*           displayName    = NULL;
+    long             maxGUIDSize    = 0;
+    BCHAR*           maxGUIDSizeW   = NULL;
+    ContentTypeInfo* rxPref         = NULL;
+    ArrayList*       rx             = NULL; // ContentTypeInfo[]
+    ContentTypeInfo* txPref         = NULL;;
+    ArrayList*       tx             = NULL; // ContentTypeInfo[]
+    DSMem*           dsMem          = NULL;
+    SyncCap*         syncCap        = NULL;  
+
+    ContentTypeInfo* x              = NULL;
+    
+    unsigned int pos = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent(xml, SOURCE_REF,  NULL);
+    sourceRef   = getSourceRef(t);
+    if (t) {delete [] t; t = NULL;}    
+    displayName = XMLProcessor::getElementContent(xml, DISPLAY_NAME,             NULL);
+    maxGUIDSizeW = XMLProcessor::getElementContent(xml, MAX_GUID_SIZE,           NULL);
+    if (maxGUIDSizeW) {
+        maxGUIDSize = bstrtol(maxGUIDSizeW, NULL, 10);
+    }
+    t = XMLProcessor::getElementContent(xml, RX_PREF,  NULL);
+    rxPref = getContentTypeInfo(t);
+    if (t) {delete [] t; t = NULL;}    
+    t = XMLProcessor::getElementContent(xml, TX_PREF,  NULL);
+    txPref = getContentTypeInfo(t);
+    if (t) {delete [] t; t = NULL;}    
+
+    unsigned int previous = 0;
+    pos = 0;
+        
+    // Rx 
+    t = XMLProcessor::getElementContent(&xml[pos], RX, &pos);
+    while ((x = getContentTypeInfo(t)) != NULL) {
+        if (x) {
+            if (!rx)
+                rx = new ArrayList();
+            rx->add(*x); // in the ArrayList NULL element cannot be inserted
+            deleteContentTypeInfo(&x);            
+        }
+        pos += previous;
+        previous = pos;             
+        if (t) {delete [] t; t = NULL;}    
+        t = XMLProcessor::getElementContent(&xml[pos], RX, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}    
+
+    // Tx 
+    pos = 0, previous = 0;
+    t = XMLProcessor::getElementContent(&xml[pos], TX, &pos);
+    while ((x = getContentTypeInfo(t)) != NULL) {
+        if (x) {
+            if (!tx)
+                tx = new ArrayList();
+            tx->add(*x); // in the ArrayList NULL element cannot be inserted
+            deleteContentTypeInfo(&x);            
+        }
+        pos += previous;
+        previous = pos;             
+        if (t) {delete [] t; t = NULL;}    
+        t = XMLProcessor::getElementContent(&xml[pos], TX, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}    
+    
+    t = XMLProcessor::getElementContent(xml, DS_MEM,  NULL);
+    dsMem = getDSMem(t);    
+    if (t) {delete [] t; t = NULL;}    
+    t = XMLProcessor::getElementContent(xml, SYNC_CAP,  NULL);
+    syncCap = getSyncCap(t);  
+    if (t) {delete [] t; t = NULL;}    
+        
+    if (NotNullCheck(2, displayName, maxGUIDSizeW) ||
+                                     (sourceRef)   ||
+                                     (rxPref)      ||
+                                     (txPref)      ||
+                                     (dsMem)       ||
+                                     (syncCap)     ||
+                                     NotZeroArrayLenght(2, rx, tx) ) {
+        ret = new DataStore(sourceRef, displayName, maxGUIDSize, rxPref, rx, txPref, tx, dsMem, syncCap);
+    }
+    
+    safeDel(&displayName);
+    safeDel(&maxGUIDSizeW);
+    deleteContentTypeInfo(&rxPref);
+    deleteContentTypeInfo(&txPref);
+    deleteArrayList(&tx);
+    deleteArrayList(&rx);
+    deleteSyncCap(&syncCap);
+    deleteDSMem(&dsMem);
+
+
+    return ret;
+}
+
+
+SyncCap* Parser::getSyncCap(BCHAR* xml) {
+    
+    SyncCap* ret            = NULL;
+    SyncType* syncType      = NULL;
+    ArrayList* list         = NULL;
+
+    unsigned int pos = 0, previous = 0;
+    BCHAR* t = NULL;
+    t = XMLProcessor::getElementContent(&xml[pos], SYNC_TYPE, &pos);
+    while ((syncType = getSyncType(t)) != NULL) {
+        if (syncType) {
+            if (!list)
+                list = new ArrayList();
+            list->add(*syncType); // in the ArrayList NULL element cannot be inserted
+            deleteSyncType(&syncType);            
+        }
+        pos += previous;
+        previous = pos;             
+        if (t) {delete [] t; t = NULL;}
+        t = XMLProcessor::getElementContent(&xml[pos], SYNC_TYPE, &pos);
+    }
+    if (t) {delete [] t; t = NULL;}
+        
+    if (NotZeroArrayLenght(1, list)) {
+        ret = new SyncCap(list);
+    }
+
+    deleteArrayList(&list);
+
+    return ret;
+}
+
+SyncType* Parser::getSyncType(BCHAR* content) {
+    
+    SyncType* ret            = NULL;    
+    int value                = 0;
+  
+    if (content) {
+         value = bstrtol(content, NULL, 10);
+         if (value >= 1 && value <= 7) {
+             ret = new SyncType(value);
+         }
+    }    
+    
+    return ret;
+}
+
+
+ContentTypeInfo* Parser::getContentTypeInfo(BCHAR* xml) {
+    
+    ContentTypeInfo* ret = NULL;
+    BCHAR* ctType      = NULL;
+    BCHAR* verCT       = NULL;     
+
+    ctType = XMLProcessor::getElementContent(xml, CT_TYPE,             NULL);
+    verCT  = XMLProcessor::getElementContent(xml, VER_CT,             NULL);
+    
+    if (NotNullCheck(2, ctType, verCT)) {
+        ret = new ContentTypeInfo(ctType, verCT);
+    }
+    
+    safeDel(&ctType);
+    safeDel(&verCT);
+    return ret;
+}
+
+DSMem* Parser::getDSMem(BCHAR* xml) {    
+    
+    DSMem* ret          = NULL;
+    BCHAR* maxMemW   = NULL;   
+    BCHAR* sharedMemW = NULL;
+    BCHAR* maxIDW    = NULL;
+        
+    BOOL    sharedMem   = NULL;
+    long    maxMem     = 0;
+    long    maxID      = 0;
+    
+    BOOL isToCreate = FALSE;
+
+    maxMemW     = XMLProcessor::getElementContent (xml, MAX_MEM,   NULL);
+    sharedMemW  = XMLProcessor::getElementContent (xml, SHARED_MEM, NULL);
+    maxIDW      = XMLProcessor::getElementContent (xml, MAX_ID,    NULL);
+    
+    isToCreate = NotNullCheck(3, maxMemW, sharedMemW, maxIDW);
+
+    if (maxMemW != NULL) {
+        maxMem = bstrtol(maxMemW, NULL, 10);
+    }
+    if (maxIDW != NULL) {
+        maxID = bstrtol(maxIDW, NULL, 10);
+    } 
+    if (sharedMemW != NULL) {
+        sharedMem = bstrtol(sharedMemW, NULL, 10);
+    }
+    
+    if (isToCreate) {
+        ret = new DSMem(sharedMem, maxMem, maxID);
+    }
+
+    safeDel(&maxMemW);
+    safeDel(&maxIDW);
+    safeDel(&sharedMemW);
+
+    return ret;   
+
+}
+
+BOOL Parser::getNoResp(BCHAR* content) {    
+  if (content)
+      return TRUE;
+  else
+      return FALSE;
+}
+
+BOOL Parser::getNoResults(BCHAR* content) {    
+    
+    if (content)
+        return TRUE;
+    else    
+        return FALSE;
+}
+
+BOOL Parser::getMoreData(BCHAR* content) {
+     if (content)
+        return TRUE;
+    else    
+        return FALSE;
+}
+
+/*
+* TBD. There is to use the getNextTag method in xmlProcessor.
+* This CTCap is no nested as a usual XML. See syncml_devinf_v11_20020215.pdf
+* TBD
+*
+*/
+CTCap* Parser::getCTCap(BCHAR* xml) {
+    CTCap* ret = NULL;
+    CTTypeSupported* ctTypeSupported = NULL;
+
+    // ArrayList* ctTypes = new ArrayList();       
+       
+    return ret;
+}
+
+//
+// TBD 
+//
+ArrayList* Parser::getEMI(BCHAR* content) {
+    ArrayList* ret = NULL;    
+    return ret;
+}
