Fixes several problems in combination with Synthesis (and probably
other) servers:
- CDATA in <Data></Data> parts not supported
- escape & and < with CDATA because the Synthesis server only supports that;
  is also cheaper to do at runtime (no replaceAll).
- bugfix: code which replaced &amp; and &lt; was unconditionally applied
  at high levels and broke e.g. <Add><Data><![CDATA[ literal entity &amp; ]]></Data></Add>
  but it was also applied multiple times to the same text and thus might have
  incorrectly replaced &amp;amp; with & although &amp; would have been correct
- <LocName> required for MD5 authentication
- after failed authentication <SourceRef> might be missing in reply,
  ignore it
- moved code into new SyncManager::checkForServerChanges() to deal with
  server <Sync> which might come before the 222 alert and wasn't expected
  there by the client without this patch
- several XML tags must have the xmlns parameter to be accepted as valid XML

#
# Patch managed by http://www.holgerschurig.de/patcher.html
#

--- native/src/c++/common/base/util/XMLProcessor.cpp~synthesis
+++ native/src/c++/common/base/util/XMLProcessor.cpp
@@ -183,10 +183,64 @@
         return 0;
     }
 
-    ret = new BCHAR[endPos - startPos + 1];
+    // figure out whether the text that we are about to copy
+    // contains further elements; if not, treat it as a leaf
+    // element and decode entities
+    BOOL isLeaf = TRUE;
+    unsigned int pos = startPos;
+    while (pos < endPos) {
+        if (xml[pos] == '<') {
+            isLeaf = FALSE;
+            break;
+        }
+        pos++;
+    }
 
-    bstrncpy(ret, xml+startPos, endPos - startPos);
-    ret[endPos - startPos] = 0;
+    const BCHAR cdataStart[] = T("<![CDATA[");
+    const int cdataStartLen = sizeof(cdataStart) - 1;
+    const BCHAR cdataEnd[] = T("]]>");
+    const int cdataEndLen = sizeof(cdataEnd) - 1;
+
+    // strip CDATA markers at start and end?
+    if (!isLeaf &&
+        endPos - pos > cdataStartLen + cdataEndLen &&
+        !bstrncmp(xml + pos, cdataStart, cdataStartLen)) {
+        // yep, copy content verbatim;
+        // search real end of data first
+        pos += cdataStartLen;
+        unsigned int cdataEndPos = endPos;
+        while (cdataEndPos - cdataEndLen > pos) {
+            if (!bstrncmp(xml + cdataEndPos - cdataEndLen,
+                          cdataEnd,
+                          cdataEndLen)) {
+                // found "]]>"
+                cdataEndPos -= cdataEndLen;
+                break;
+            }
+            cdataEndPos--;
+        }
+        
+        ret = new BCHAR[cdataEndPos - pos + 1];
+        bstrncpy(ret, xml + pos, cdataEndPos - pos);
+        ret[cdataEndPos - pos] = 0;
+    } else if (isLeaf) {
+        // Decode content of final element:
+        // might contain escaped special characters.
+        //
+        // This must _not_ be done for tags which contain other
+        // tags because then we might destroy the content of e.g.
+        // <Add><Data><![CDATA[ literal entity &amp; ]]></Data></Add>
+        //
+        StringBuffer tmp(xml+startPos, endPos - startPos);
+        tmp.replaceAll("&amp;", "&");
+        tmp.replaceAll("&lt;", "<");
+        ret = stringdup(tmp.c_str());
+    } else {
+        size_t len = endPos - startPos;
+        ret = new BCHAR [len + 1];
+        memcpy( ret, xml + startPos, len * sizeof(BCHAR));
+        ret[len] = 0;
+    }
 
     return ret;
 }
@@ -582,7 +636,16 @@
     p1 = p2 = xml;
     
     for (i = 0; i < xmlLength; i ++) {
-        
+        if (!bstrncmp(p1 + i, T("<![CDATA["), bstrlen(T("<![CDATA[")))) {
+            // skip over content
+            while(p1[i]) {
+                i++;
+                if (!bstrcmp(p1 + i, T("]]>"))) {
+                    i += bstrlen(T("]]>"));
+                    break;
+                }
+            }
+        }
         if (p1[i] == '<') {
             openBracket = TRUE;
             previousIndex = i;
--- native/src/c++/common/spds/CredentialHandler.cpp~synthesis
+++ native/src/c++/common/spds/CredentialHandler.cpp
@@ -62,11 +62,19 @@
     username = stringdup(t);
 }
 
+const BCHAR *CredentialHandler::getUsername() {
+    return username;
+}
+
 void CredentialHandler::setPassword(const BCHAR* t) {
     safeDel(&password);
     password = stringdup(t);
 }
 
+const BCHAR *CredentialHandler::getPassword() {
+    return password;
+}
+
 void CredentialHandler::setClientAuthType(const BCHAR* t){
     safeDel(&clientAuthType);
     clientAuthType = stringdup(t);
--- native/src/c++/common/spds/SyncManager.cpp~synthesis
+++ native/src/c++/common/spds/SyncManager.cpp
@@ -296,11 +296,13 @@
                 }
                 alerts->add(*alert);
                 deleteAlert(&alert);
-            }                        
+            }
             cred = credentialHandler.getClientCredential();             
-            bstrcpy(credentialInfo, cred->getAuthentication()->getData(NULL));            
+            bstrcpy(credentialInfo, cred->getAuthentication()->getData(NULL));
         }
-        syncml = syncMLBuilder.prepareInitObject(cred, alerts, commands);
+        // "cred" only contains an encoded strings as username, also
+        // need the original username for LocName
+        syncml = syncMLBuilder.prepareInitObject(credentialHandler.getUsername(), cred, alerts, commands);
         if (syncml == NULL) {
             ret = lastErrorCode;
             goto finally;
@@ -340,13 +342,25 @@
         deleteCred(&cred);
 
         responseMsg = transportAgent->sendMessage(initMsg);
-        if (responseMsg == NULL) {
+        // Non-existant or empty reply?
+        // Synthesis server replies with empty message to
+        // a message that it cannot parse.
+        if (responseMsg == NULL || !responseMsg[0]) {
+            if (responseMsg) {
+                delete [] responseMsg;
+                responseMsg = NULL;
+            }
+
             // This is an error only is it is not an AddressChange
             if ( addressChange && lastErrorCode == ERR_READING_CONTENT ) {
                 ret = 0;
             }
             else {
+                // use last error code if one has been set (might not be the case)
                 ret = lastErrorCode;
+                if (!ret) {
+                    ret = ERR_READING_CONTENT;
+                }
             }
             goto finally;
         }
@@ -385,7 +399,14 @@
             if (!check[count])
                 continue;
 
-            ret = syncMLProcessor.processAlertStatus(*sources[count], syncml, alerts);
+            int sourceRet = syncMLProcessor.processAlertStatus(*sources[count], syncml, alerts);
+            if (isAuthFailed(ret) && sourceRet == -1) {
+                // Synthesis server does not include SourceRefs if
+                // authentication failed. Remember the authentication
+                // failure in that case, otherwise we'll never get to the getChal() below.
+            } else {
+                ret = sourceRet;
+            }
             if (ret == -1 || ret == 404 || ret == 415) {
                 lastErrorCode = ret;
                 bsprintf(logmsg, T("AlertStatus from server %d"), ret);
@@ -469,7 +490,7 @@
         //
         clientChal = syncMLProcessor.getChal(syncml->getSyncBody());
 
-        if (isAuthFailed(ret)) {                        
+        if (isAuthFailed(ret)) {
             if (clientChal == NULL) {
                 requestedAuthType = credentialHandler.getClientAuthType();
             } else {
@@ -541,6 +562,88 @@
     return ret;
 }
 
+//
+// utility function to process any <Sync> command that the server might
+// have included in its <SyncBody>
+//
+// @param syncml       the server response
+// @param statusList   list to which statuses for changes are to be added
+// @return TRUE if a fatal error occurred
+//
+BOOL SyncManager::checkForServerChanges(SyncML* syncml, ArrayList &statusList)
+{
+    BOOL result = FALSE;
+    
+    // Danger, danger: count is a member variable!
+    // It has to be because that's the context for some of
+    // the other methods. Modifying it has to be careful to
+    // restore the initial value before returning because
+    // our caller might use it, too.
+    int oldCount = this->count;
+    
+    for (count = 0; count < sourcesNumber; count ++) {
+        if (!check [count])
+            continue;
+
+        Sync* sync = syncMLProcessor.processSyncResponse(*sources[count], syncml);
+
+        if (sync) {
+            ArrayList* items = sync->getCommands();
+            Status* status = syncMLBuilder.prepareSyncStatus(*sources[count], sync);
+            statusList.add(*status);
+            deleteStatus(&status);
+
+            ArrayList* previousStatus = new ArrayList();
+            for (int i = 0; i < items->size(); i++) {
+                CommandInfo cmdInfo;
+                ModificationCommand* modificationCommand = (ModificationCommand*)(items->get(i));
+                Meta* meta = modificationCommand->getMeta();
+                ArrayList* list = modificationCommand->getItems();
+                        
+                cmdInfo.commandName = modificationCommand->getName();
+                cmdInfo.cmdRef = modificationCommand->getCmdID()->getCmdID();
+
+                if (meta) {
+                    cmdInfo.dataType = meta->getType();
+                    cmdInfo.format = meta->getFormat(); 
+                }
+                else {
+                    cmdInfo.dataType = 0;
+                    cmdInfo.format = 0;
+                }
+
+                for (int j = 0; j < list->size(); j++) {
+                    Item *item = (Item*)list->get(j);
+                    if (item == NULL) {
+                        LOG.error("SyncManager::sync() - unexpected NULL item.");
+                        result = TRUE;
+                        goto finally;
+                    }
+
+                    //
+                    // set the syncItem element
+                    //
+                    status = processSyncItem(item, cmdInfo);
+
+                    syncMLBuilder.addItemStatus(previousStatus, status);
+                    deleteStatus(&status);            
+                }
+
+                if (previousStatus) {
+                    statusList.add(previousStatus);
+                    deleteArrayList(&previousStatus);                    
+                }
+            }
+        }                               
+    } // End for (count = 0; count < sourcesNumber; count ++)
+
+    
+  finally:
+    this->count = oldCount;
+    return result;
+}
+
+
 int SyncManager::sync() {
 
     BCHAR* msg         = NULL;
@@ -965,6 +1068,19 @@
                 break;
             }
 
+            // The server might have included a <Sync> command without waiting
+            // for a 222 alert. If it hasn't, then nothing is done here.
+            ArrayList statusList;
+            if (checkForServerChanges(syncml, statusList)) {
+                goto finally;
+            }
+            if (statusList.size()) {
+                Status* status = syncMLBuilder.prepareSyncHdrStatus(NULL, 200);
+                commands->add(*status);
+                deleteStatus(&status);
+                commands->add(&statusList);
+            }
+
             // deleteSyncML(&syncml);
 
         } while (last == FALSE);
@@ -1055,73 +1171,9 @@
             commands->add(*status);
             deleteStatus(&status); 
 
-            /* The server should not send any alert...
-               list = syncMLProcessor.getCommands(syncml->getSyncBody(), ALERT);   
-               status = syncMLBuilder.prepareAlertStatus(*sources[0], list, 200);
-
-               if (status) {
-               commands->add(*status);
-               deleteStatus(&status);    
-               }
-               deleteArrayList(&list);
-             */
-            for (count = 0; count < sourcesNumber; count ++) {
-                if (!check[count])
-                    continue;
-
-                Sync* sync = syncMLProcessor.processSyncResponse(*sources[count], syncml);
-
-                if (sync) {
-     
-                    ArrayList* items = sync->getCommands();
-                    status = syncMLBuilder.prepareSyncStatus(*sources[count], sync);
-                    statusList.add(*status);
-                    deleteStatus(&status);
-
-                    ArrayList* previousStatus = new ArrayList();
-                    for (int i = 0; i < items->size(); i++) {
-                        CommandInfo cmdInfo;
-                        modificationCommand = (ModificationCommand*)(items->get(i));
-                        Meta* meta = modificationCommand->getMeta();
-                        ArrayList* list = modificationCommand->getItems();
-                        
-                        cmdInfo.commandName = modificationCommand->getName();
-                        cmdInfo.cmdRef = modificationCommand->getCmdID()->getCmdID();
-
-                        if (meta) {
-                            cmdInfo.dataType = meta->getType();
-                            cmdInfo.format = meta->getFormat(); 
-                        }
-                        else {
-                            cmdInfo.dataType = 0;
-                            cmdInfo.format = 0;
-                        }
-
-                        for (int j = 0; j < list->size(); j++) {
-                            Item *item = (Item*)list->get(j);
-                            if (item == NULL) {
-                                LOG.error("SyncManager::sync() - unexpected NULL item.");
-                                goto finally;
-                            }
-
-                            //
-                            // set the syncItem element
-                            //
-                            status = processSyncItem(item, cmdInfo);
-
-                            syncMLBuilder.addItemStatus(previousStatus, status);
-                            deleteStatus(&status);            
-                        }
-
-                        if (previousStatus) {
-                            statusList.add(previousStatus);
-                            deleteArrayList(&previousStatus);                    
-                        }
-
-                    }
-                }                               
-
-            } // End for (count = 0; count < sourcesNumber; count ++) 
+            if (checkForServerChanges(syncml, statusList)) {
+                goto finally;
+            }
 
             commands->add(&statusList);
 
--- native/src/c++/common/spds/SyncMLBuilder.cpp~synthesis
+++ native/src/c++/common/spds/SyncMLBuilder.cpp
@@ -480,7 +480,7 @@
     return alert;
 }
 
-SyncHdr* SyncMLBuilder::prepareSyncHdr(Cred* cred) {
+SyncHdr* SyncMLBuilder::prepareSyncHdr(Cred* cred, const BCHAR *username) {
 
     ++msgID;
 
@@ -489,7 +489,7 @@
     SessionID* sessID    = new SessionID(ltow(sessionID));
     BCHAR*   messageID = itow(msgID);
     Target*    tar       = new Target(target);
-    Source*    sou       = new Source(device);       
+    Source*    sou       = new Source(device, username);       
     Meta* meta           = NULL;
 
     if (maxMsgSize > 0) {
@@ -513,9 +513,9 @@
     return syncHdr;    
 }
 
-SyncML* SyncMLBuilder::prepareInitObject(Cred* cred, ArrayList* alerts, ArrayList* commands) {
+SyncML* SyncMLBuilder::prepareInitObject(const BCHAR *username, Cred* cred, ArrayList* alerts, ArrayList* commands) {
 
-    SyncHdr* syncHdr     = prepareSyncHdr(cred);
+    SyncHdr* syncHdr     = prepareSyncHdr(cred, username);
     SyncML*  syncml      = NULL;               
     ArrayList* list      = new ArrayList();
     SyncBody* syncBody   = NULL;
@@ -883,4 +883,4 @@
         return data;
 
 }
-*/
\ No newline at end of file
+*/
--- native/src/c++/common/spds/SyncMLProcessor.cpp~synthesis
+++ native/src/c++/common/spds/SyncMLProcessor.cpp
@@ -65,10 +65,19 @@
                 if (bstrcmp(s->getCmd(), ALERT) == 0) { 
                     sourceRef = (SourceRef*)(s->getSourceRef()->get(0));
 
-                    if (bstrcmp(_wcc(source.getName()),
-                                sourceRef->getValue()) == 0) {
-                        ret = getAlertStatusCode(s, _wcc(source.getName()));
-                        break;
+                    if (sourceRef) {
+                        if (bstrcmp(_wcc(source.getName()),
+                                    sourceRef->getValue()) == 0) {
+                            ret = getAlertStatusCode(s, _wcc(source.getName()));
+                            break;
+                        }
+                    } else {
+                        // Server did not include <SourceRef>, which
+                        // is a violation of the standard for commands
+                        // which were sent with <SourceRef>. Happens
+                        // with Synthesis server if authentication
+                        // failed, in which case we can simply ignore
+                        // it.
                     }
                 }
             }
@@ -99,8 +108,17 @@
     do {
         a = getCommand(syncml->getSyncBody(), ALERT, iterator);                   
         if (a == NULL) {
-            lastErrorCode = ERR_REPRESENTATION;
-            bsprintf(lastErrorMsg, T("SyncBody/Alert not found!"));
+            // This happens with the Synthesis server's reply:
+            // instead of sending SyncBody/Alert we get SyncBody/Put
+            // with device infos and a SyncBody/Get requesting our own
+            // device infos. Ignoring the request is not correct, but
+            // allows synchronization to proceed and complete eventually
+            // without any further errors. For that to work we must not
+            // set lastErrorCode here, as it will be checked at the end of
+            // the sync.
+            //
+            // lastErrorCode = ERR_REPRESENTATION;
+            // bsprintf(lastErrorMsg, T("SyncBody/Alert not found!"));
             goto finally;
         }
         Alert* alert = (Alert*)a;
--- native/src/c++/common/syncml/formatter/Formatter.cpp~synthesis
+++ native/src/c++/common/syncml/formatter/Formatter.cpp
@@ -77,13 +77,17 @@
 * Returns a StringBuffer giving the tag and the value as wchar.
 * To use for generic simple value
 */
-StringBuffer* Formatter::getValue(BCHAR* tagName, BCHAR* value) {    
+StringBuffer* Formatter::getValue(BCHAR* tagName, BCHAR* value, BCHAR *params) {    
     if (!value)
         return NULL;
 
-    BCHAR* t1 = new BCHAR[bstrlen(tagName) + 3]; // <  >  0
+    BCHAR* t1 = new BCHAR[bstrlen(tagName) + 3 + (params ? 1 + bstrlen(params) : 0)]; // <  >  0
     BCHAR* t2 = new BCHAR[bstrlen(tagName) + 5]; // </ > \n 0
-    bsprintf(t1, T("<%s>"), tagName);
+    if (params) {
+        bsprintf(t1, T("<%s %s>"), tagName, params);
+    } else {
+        bsprintf(t1, T("<%s>"), tagName);
+    }
     bsprintf(t2, T("</%s>\n"), tagName);
 
     StringBuffer* s = new StringBuffer(t1);
@@ -269,8 +273,8 @@
 
     // get all the values
 
-    format       = getValue(FORMAT, metInf->getFormat(NULL));
-    type         = getValue(TYPE,   metInf->getType(NULL)); 
+    format       = getValue(FORMAT, metInf->getFormat(NULL), METINFO);
+    type         = getValue(TYPE,   metInf->getType(NULL), METINFO); 
     mark         = getValue(MARK,   metInf->getMark(NULL));
     
     anchor       = getAnchor(metInf->getAnchor());
@@ -350,7 +354,7 @@
     buf->append(tmp);
     if (tmp) { delete tmp; tmp = NULL; }
         
-    ret = getValue(ANCHOR, buf);    
+    ret = getValue(ANCHOR, (BCHAR *)buf->c_str(), METINFO);    
     
     if (buf) {delete buf; buf = NULL; }
     return ret;    
@@ -1728,10 +1732,9 @@
         s.append(anchor);
         s.append(devInf);
     } else {
-        StringBuffer tmp(data->getData());
-        tmp.replaceAll("&", "&amp;");
-        tmp.replaceAll("<", "&lt;");
-        s.append(tmp);        
+        s.append("<![CDATA[");
+        s.append(data->getData());
+        s.append("]]>");
     }
 
     deleteAllStringBuffer(2, &anchor, &devInf);
--- native/src/include/common/spds/CredentialHandler.h~synthesis
+++ native/src/include/common/spds/CredentialHandler.h
@@ -73,7 +73,9 @@
          */        
         
         void setUsername(const BCHAR* t) EXTRA_SECTION_01;
+        const BCHAR* getUsername() EXTRA_SECTION_01;
         void setPassword(const BCHAR* t) EXTRA_SECTION_01;
+        const BCHAR* getPassword() EXTRA_SECTION_01;
         void setClientAuthType(const BCHAR* t) EXTRA_SECTION_01;
         void setClientNonce(const BCHAR* t) EXTRA_SECTION_01;
         const BCHAR* getClientAuthType(BCHAR* t=0 /* deprecated */) EXTRA_SECTION_01;
--- native/src/include/common/spds/SyncManager.h~synthesis
+++ native/src/include/common/spds/SyncManager.h
@@ -98,6 +98,7 @@
         Status *processSyncItem(Item* item, const CommandInfo &cmdInfo) EXTRA_SECTION_01;
         char* processItemContent(const BCHAR* data, const BCHAR* encodings, long* size) EXTRA_SECTION_01;
         void decodeSyncItemContent(char** c, TransformationInfo& info, const BCHAR* encoding) EXTRA_SECTION_01;
+        BOOL checkForServerChanges(SyncML* syncml, ArrayList &statusList) EXTRA_SECTION_01;
 };
 
 #endif
--- native/src/include/common/spds/SyncMLBuilder.h~synthesis
+++ native/src/include/common/spds/SyncMLBuilder.h
@@ -58,12 +58,12 @@
         /*
         * Prepare the init SyncML* message with credential and db alert to sync
         */
-        SyncML*  prepareInitObject(Cred* cred, ArrayList* alerts, ArrayList* commands) EXTRA_SECTION_01;
+        SyncML*  prepareInitObject(const BCHAR *username, Cred* cred, ArrayList* alerts, ArrayList* commands) EXTRA_SECTION_01;
         
         /*
         * Prepare the SyncHdr message with credential if not null
         */        
-        SyncHdr* prepareSyncHdr(Cred* cred) EXTRA_SECTION_01;
+        SyncHdr* prepareSyncHdr(Cred* cred, const BCHAR *username = NULL) EXTRA_SECTION_01;
         
         /*
         * Prepare the init alert
--- native/src/include/common/syncml/core/Cred.h~synthesis
+++ native/src/include/common/syncml/core/Cred.h
@@ -66,7 +66,7 @@
          *
          * @return the username stored in this credential
          */
-        BCHAR* getUsername(BCHAR* retUsername);
+        BCHAR* getUsername(BCHAR* retUsername = NULL);
 
 
         /**
--- native/src/include/common/syncml/core/TagNames.h~synthesis
+++ native/src/include/common/syncml/core/TagNames.h
@@ -120,6 +120,8 @@
 #define TARGET_PARENT       T("TargetParent"     )
 #define SOURCE_PARENT       T("SourceParent"     )
 
+// parameters 
+#define METINFO             T("xmlns='syncml:metinf'")
 
 
 // Commands
--- native/src/include/common/syncml/formatter/Formatter.h~synthesis
+++ native/src/include/common/syncml/formatter/Formatter.h
@@ -36,7 +36,7 @@
     // ---------------------------------------------------------- Public data    
     public:
         
-        static StringBuffer*    getValue            (BCHAR* tagName, BCHAR* value);
+        static StringBuffer*    getValue            (BCHAR* tagName, BCHAR* value, BCHAR *params = NULL);
         static StringBuffer*    getValue            (BCHAR* tagName, const BCHAR* value);
         static StringBuffer*    getValue            (BCHAR* tagName, StringBuffer* value);
         static StringBuffer*    getValue            (BCHAR* tagName, long value);
