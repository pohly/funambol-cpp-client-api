This patch replaces several older patches and reimplements
their functionality using a new sync client API provided
by the SyncClient class:

http://wiki.objectweb.org/sync4j/Wiki.jsp?page=CClientDevelopmentHOWTO

Various changes:
- replaces one getSyncMode() with getPreferredSyncMode() because at
  that time getSyncMode() normally wouldn't be set yet
- if an error has been set already in SyncManager::beginSync(), do
  not overwrite it with a follow-up error
- added missing const qualifiers whenever necessary

(Curl)TransportAgent:
- did not set userAgent member in constructor,
  causing an uninitialized memory read in the
  CurlTransportAgent constructor
- CurlTransportAgent needs to be notified of
  userAgent modifications, therefore made all
  calls in TransportAgent virtual and added
  CurlTransportAgent::setUserAgent

Client API:
- SyncClient replaces Sync4jClient: API is backwards
  compatible, code using Sync4jClient compiles without
  changes
- SyncClient is expected to be subclassed by client
  to override certain functions which will be called
  by the base SyncClient:sync() and createDevInf() methods

SyncManager:
- fix for uninitialized memory (and potential crashes)
  when constructing a SyncManager and immediately
  deleting it again

Support for DevInf:
- constructed by SyncClient, passed to SyncManager
- fixed spelling of tag names
- instead of implementing the copying of devInfHash into a new
  SyncSource property, the code was refactored so that a SyncSource
  now has a SyncSourceConfig

Support for DevInf was tested with the Synthesis and Funambol
servers. A client does not have to implement any calls, default
implementations of the calls fill provide reasonable defaults for
required properties or leave them empty.

DevInf is actively sent as part of a Put if they have changed since
the last time, the new "syncml/devInfHash" property stores a hash of
the DevInf string to detect that. Sending DevInf as part of Results in
reply to a Get is also supported.

#
# Patch managed by http://www.holgerschurig.de/patcher.html
#

--- native/src/c++/common/base/util/baseutils.cpp~devinfo
+++ native/src/c++/common/base/util/baseutils.cpp
@@ -296,7 +296,7 @@
 
 
 
-char* calculateMD5(void* token, int len, char* wdigest) {
+char* calculateMD5(const void* token, int len, char* wdigest) {
 
     //algo for md5 digest
     char dig [18];
--- native/src/c++/common/client/DMTClientConfig.cpp~devinfo
+++ native/src/c++/common/client/DMTClientConfig.cpp
@@ -28,12 +28,20 @@
 #include "spdm/ManagementNode.h"
 
 
+void DMTClientConfig::initialize() {
+    dmt = NULL;
+    syncMLNode = NULL;
+    sourcesNode = NULL;
+}
+
 DMTClientConfig::DMTClientConfig() : SyncManagerConfig() {
+    initialize();
     rootContext = 0;
 }
 
 
 DMTClientConfig::DMTClientConfig(const BCHAR* root): SyncManagerConfig() {
+    initialize();
     rootContext = new BCHAR[bstrlen(root)+1];
     bstrcpy(rootContext, root);
 }
@@ -43,6 +51,7 @@
     if (rootContext) {
         delete [] rootContext;
     }
+    close();
 }
 
 BOOL DMTClientConfig::getSyncSourceConfig(
@@ -89,31 +98,13 @@
     //
     BCHAR nodeName[DIM_MANAGEMENT_PATH];
 
-    bsprintf(nodeName, T("%s%s"), rootContext, T(CONTEXT_SPDS_SYNCML));
-
-    DMTree* dmt = DMTreeFactory::getDMTree(rootContext);
-
-    ManagementNode *node = dmt->getManagementNode(nodeName);
-    
-    if ( ! node ) {
-        lastErrorCode = ERR_INVALID_CONTEXT;
-        bsprintf(lastErrorMsg, ERRMSG_INVALID_CONTEXT, nodeName);
-        goto finally;
+    if (!open()) {
+        return FALSE;
     }
 
-    readAccessConfig(*node);
-    delete node;
-    node = 0;
-
-    bstrcpy(nodeName, rootContext); bstrcat(nodeName, T(CONTEXT_SPDS_SOURCES));
+    readAccessConfig(*syncMLNode);
 
-    node = dmt->getManagementNode(nodeName);
-    if ( ! node ) {
-        lastErrorCode = ERR_INVALID_CONTEXT;
-        bsprintf(lastErrorMsg, ERRMSG_INVALID_CONTEXT, nodeName);
-        goto finally;
-    }
-    n = node->getChildrenMaxCount();
+    n = sourcesNode->getChildrenMaxCount();
 
     //
     // Let's remove previously created config objects and reinitialize
@@ -127,20 +118,14 @@
 
     for (i=0; i<n; ++i) {
         // node owns children, we must not delete them
-        readSourceConfig(i, *(node->getChild(i)) );
+        readSourceConfig(i, *(sourcesNode->getChild(i)) );
     }
 
     ret = TRUE;
 
 finally:
 
-    if (dmt) {
-        delete dmt;
-    }
-    if (node) {
-        delete node;
-    }
-
+    close();
     return ret;
 }
 
@@ -148,12 +133,11 @@
 BOOL DMTClientConfig::save() {
     BOOL ret = FALSE;
     unsigned int i = 0;
-    BCHAR nodeName[DIM_MANAGEMENT_PATH];
-	ManagementNode *node = 0;
-
-    DMTree* dmt = DMTreeFactory::getDMTree(rootContext);
 
     LOG.debug(DBG_WRITING_CONFIG_TO_DM);
+    if (!open()) {
+        return FALSE;
+    }
 
     if (accessConfig.getDirty()) {
         resetError();
@@ -161,19 +145,7 @@
         //
         // SyncML management node
         //
-        bstrcpy(nodeName, rootContext); bstrcat(nodeName, T(CONTEXT_SPDS_SYNCML));
-        
-        node = dmt->getManagementNode(nodeName);
-        if ( ! node ) {
-            lastErrorCode = ERR_INVALID_CONTEXT;
-            bsprintf(lastErrorMsg, ERRMSG_INVALID_CONTEXT, nodeName);
-            goto finally;
-        }
-
-        saveAccessConfig(*node);
-
-        delete node;
-        node = 0;
+        saveAccessConfig(*syncMLNode);
     }
 
     //
@@ -183,39 +155,81 @@
     //
     // Sources management node
     //
-    bstrcpy(nodeName, rootContext); bstrcat(nodeName, T(CONTEXT_SPDS_SOURCES));
-
-    node = dmt->getManagementNode(nodeName);
-    if ( ! node ) {
-        lastErrorCode = ERR_INVALID_CONTEXT;
-        bsprintf(lastErrorMsg, ERRMSG_INVALID_CONTEXT, nodeName);
-        goto finally;
-    }
-
     for(i=0; i<sourceConfigsCount; ++i) {
-        saveSourceConfig(i, *(node->getChild(i)) );
+        saveSourceConfig(i, *(sourcesNode->getChild(i)) );
 
         if (lastErrorCode != ERR_NONE) {
             goto finally;
         }
     }
-    delete node;
-    node = 0;
 
     ret = (lastErrorCode == ERR_NONE);
 
 finally:
 
-    if (dmt) {
-        delete dmt;
+    close();
+    return ret;
+}
+
+BOOL DMTClientConfig::open() {
+    BCHAR nodeName[DIM_MANAGEMENT_PATH];
+    nodeName[0] = 0;
+
+    dmt = DMTreeFactory::getDMTree(rootContext);
+
+    bsprintf(nodeName, T("%s%s"), rootContext, T(CONTEXT_SPDS_SYNCML));
+    syncMLNode = dmt->getManagementNode(nodeName);
+    if (!syncMLNode ) {
+        goto failed;
     }
-    if (node) {
-        delete node;
+    
+    bsprintf(nodeName, T("%s%s"), rootContext, T(CONTEXT_SPDS_SOURCES));
+    sourcesNode = dmt->getManagementNode(nodeName);
+    if (!sourcesNode) {
+        goto failed;
     }
 
-    return ret;
+    return TRUE;
+
+failed:
+    lastErrorCode = ERR_INVALID_CONTEXT;
+    bsprintf(lastErrorMsg, ERRMSG_INVALID_CONTEXT, nodeName);
+    close();
+    return FALSE;
 }
 
+ManagementNode* DMTClientConfig::getSyncMLNode() {
+    return syncMLNode;
+}
+
+int DMTClientConfig::getNumSources() {
+    return sourcesNode ?
+        sourcesNode->getChildrenMaxCount() :
+        -1;
+}
+
+ManagementNode* DMTClientConfig::getSyncSourceNode(int index) {
+    return sourcesNode ?
+        sourcesNode->getChild(index) :
+        NULL;
+}
+
+void DMTClientConfig::close() {
+    if (syncMLNode) {
+        delete syncMLNode;
+        syncMLNode = NULL;
+    }
+    if (sourcesNode) {
+        delete sourcesNode;
+        sourcesNode = NULL;
+    }
+    if (dmt) {
+        delete dmt;
+        dmt = NULL;
+    }
+}
+
+
 BOOL DMTClientConfig::readAccessConfig(ManagementNode& n) {
 
     BCHAR *tmp;
@@ -249,6 +263,10 @@
     accessConfig.setEndSync(bstrtol(tmp, NULL, 10));
     delete [] tmp;
 
+    tmp = n.getPropertyValue(PROPERTY_SOURCE_DEVINF_HASH);
+    accessConfig.setDevInfHash(tmp);
+    delete [] tmp;
+    
     tmp = n.getPropertyValue(PROPERTY_USE_PROXY);     
     accessConfig.setUseProxy((*tmp == 'T') ? TRUE : FALSE);
     delete [] tmp;
@@ -334,6 +352,7 @@
     timestampToAnchor(accessConfig.getEndSync(), buf);
     n.setPropertyValue(PROPERTY_SYNC_END, buf);
 
+    n.setPropertyValue(PROPERTY_SOURCE_DEVINF_HASH, accessConfig.getDevInfHash());
     n.setPropertyValue(PROPERTY_USE_PROXY,
 		(accessConfig.getUseProxy() ? T("T"): T("F")) );     
     n.setPropertyValue(PROPERTY_PROXY_HOST, accessConfig.getProxyHost());   
--- native/src/c++/common/client/Sync4jClient.cpp~devinfo
+++ native/src/c++/common/client/Sync4jClient.cpp
@@ -18,33 +18,40 @@
 
 
 #include "client/Sync4jClient.h"
-#include "base/LogErrorHandler.h"
 #include "spds/SyncManager.h"
-
-//----------------------------------------------------------- Static variables
-static DMTClientConfig *defaultConfig = 0;
-static LogErrorHandler *defaultErrorHandler = 0;
+#include "spds/spdsutils.h"
+#include "base/LogErrorHandler.h"
+#include "syncml/core/CTTypeSupported.h"
+#include "syncml/core/CTCap.h"
+#include "syncml/core/CTPropParam.h"
 
 Sync4jClient* Sync4jClient::instance = 0;
 
 //--------------------------------------------------- Constructor & Destructor
-Sync4jClient::Sync4jClient() {
-    syncManager  = NULL;
+SyncClient::SyncClient() {
     defaultErrorHandler = new LogErrorHandler();
-    errorHandler = defaultErrorHandler;
+    customErrorHandler = NULL;
+    config = NULL;
+    isOurConfig = FALSE;
 }
 
-Sync4jClient::~Sync4jClient() {
-    if(syncManager)
-        delete syncManager;
-    if(defaultErrorHandler)
-        delete defaultErrorHandler;
+SyncClient::~SyncClient() {
+    if (isOurConfig && config) {
+        delete config;
+    }
+    delete defaultErrorHandler;
 }
 
 //------------------------------------------------------------- Public Methods
 
+Sync4jClient::Sync4jClient() {
+}
+
+Sync4jClient::~Sync4jClient() {
+}
+
 /*
- * Get, or create, Sync4jClient instance 
+ * Get, or create, SyncClient instance 
  */
 Sync4jClient& Sync4jClient::getInstance() {
     
@@ -62,49 +69,41 @@
         delete instance;         
     }        
     instance = NULL;
-    if (defaultConfig)
-        delete defaultConfig;
-    defaultConfig = NULL;
 }
 
 /*
  * Set config from user defined Config
  */
-void Sync4jClient::setDMConfig(DMTClientConfig& config) {
-    if (syncManager)
-        delete syncManager;
-
-    if (defaultConfig) {
-        delete defaultConfig; 
-        defaultConfig = NULL;
+void SyncClient::setDMConfig(DMTClientConfig& dc) {
+    if (isOurConfig && config) {
+        delete config;
     }
-    syncManager = new SyncManager(config);
+    config = &dc;
+    isOurConfig = false;
 }
 
 /*
  * Set config from DM using an application URI
  */
-void Sync4jClient::setDMConfig(const BCHAR *root) {
-    if (defaultConfig)
-        delete defaultConfig;
-    if (syncManager)
-        delete syncManager;
-
-    defaultConfig = new DMTClientConfig(root);
-    defaultConfig->read();    
-    syncManager = new SyncManager(*defaultConfig);
-
+void SyncClient::setDMConfig(const BCHAR *root) {
+    if (isOurConfig && config) {
+        delete config;
+    }
+    config = new DMTClientConfig(root);
+    isOurConfig = TRUE;
+    config->read();
 }
 
-ErrorHandler& Sync4jClient::getErrorHandler() {
-    return *errorHandler;
+ErrorHandler& SyncClient::getErrorHandler() {
+    if (customErrorHandler) {
+        return *customErrorHandler;
+    } else {
+        return *defaultErrorHandler;
+    }
 }
 
-void Sync4jClient::setErrorHandler(ErrorHandler& e) {
-    if (defaultErrorHandler) {
-        delete defaultErrorHandler; defaultErrorHandler = NULL;
-    }    
-    errorHandler = &e;
+void SyncClient::setErrorHandler(ErrorHandler& e) {
+    customErrorHandler = &e;
 }
 
 
@@ -112,14 +111,40 @@
 * Used to start the sync process. The argument is an array of SyncSources
 * that have to be synched with the sync process
 */
-int Sync4jClient::sync(SyncSource** sources) {
+int SyncClient::sync(SyncSource** sources) {
 
     resetError();
     int ret = 0;
-    if (!syncManager)
-        return -1;
+    DevInf *devInf = NULL;
 
-    if ((ret = syncManager->prepareSync(sources))) {
+    if (!config) {
+        LOG.error("SyncClient::sync() called without valid config");
+        return ERR_PARAMETER_IS_NULL;
+    }
+
+    // ensure that the user agent string is valid
+    StringBuffer userAgent(config->getAccessConfig().getUserAgent());
+    StringBuffer buffer;
+    if (!userAgent.length()) {
+        const BCHAR *clientID = getClientID();
+        const BCHAR *clientVer = getClientVersion();
+        if (clientID) {
+            // use our own version as default
+            buffer.append(clientID);
+            if (clientVer) {
+                buffer.append(" ");
+                buffer.append(clientVer);
+            }
+            config->getAccessConfig().setUserAgent(buffer.c_str());
+        } else {
+            config->getAccessConfig().setUserAgent(BCHAR_USER_AGENT);
+        }
+    }
+    
+    devInf = createDeviceInfo(sources);
+    SyncManager syncManager(*config, devInf);
+
+    if ((ret = syncManager.prepareSync(sources))) {
         BCHAR dbg[256];
         bsprintf(dbg, T("Error in preparing sync: %s"), lastErrorMsg);//
         LOG.error(dbg);
@@ -127,54 +152,259 @@
         goto finally;
     }
        
-    if ((ret = syncManager->sync())) {   
+    if ((ret = syncManager.sync())) {   
         BCHAR dbg[256];
         bsprintf(dbg, T("Error in syncing: %s"), lastErrorMsg);
         LOG.error(dbg);
         goto finally;
     }
 
-    if ((ret = syncManager->endSync())) {       
+    if ((ret = syncManager.endSync())) {       
         BCHAR dbg[256];
         bsprintf(dbg, T("Error in ending sync: %s"), lastErrorMsg);
         LOG.error(dbg);
         goto finally;
     }
 
-    if (defaultConfig) {
-        defaultConfig->save();
+    if (isOurConfig) {
+        // restore old settings
+        config->getAccessConfig().setUserAgent(userAgent.c_str());
+        config->save();
     }
        
-finally:    
+  finally:
+    config->getAccessConfig().setUserAgent(userAgent.c_str());
+    if (devInf) {
+        delete devInf;
+    }
 
-//    if (syncManager != NULL) {
-//        delete syncManager;
-//    }
-   
     return ret;
 }
 
 
-#if 0
-/*
- * Used to start the sync process. The argument is an array of SyncSource
- * that have to be synched
- *
- * @param sources the SyncSource& array
- */
-int Sync4jClient::sync(ArrayList& sources) {
-    const int ml = 10;
-    int l = sources.size();
-
-    SyncSource* array[ml];
+int SyncClient::sync() {
+    SyncSource **sources = NULL;
+    int currSource = 0, numActive = 0;
+    int ret = 0;
     
-    for (int i=0; (i<l) && (i<ml-1); ++i) {
-        array[i] = (SyncSource*)sources[i];
+    if (!config) {
+        LOG.error("SyncClient::sync() called without valid config");
+        return ERR_PARAMETER_IS_NULL;
     }
 
-    array[l] = NULL;
+    if (!config->open()) {
+        return lastErrorCode;
+    }
 
-    return sync(array);
+    ManagementNode* syncMLNode = config->getSyncMLNode();
+    if (!syncMLNode) {
+        // shouldn't happen
+        ret = lastErrorCode;
+        goto finally;
+    }
+    ret = prepareSync(config->getAccessConfig(),
+                      *syncMLNode);
+    if (ret) {
+        goto finally;
+    }
+
+    // make room for all potential sync sources
+    sources = new SyncSource* [config->getNumSources() + 1];
+
+    // iterate over all configs and add those which the client
+    // wants to have synchronized
+    while (currSource < config->getNumSources()) {
+        SyncSourceConfig sc;
+        ManagementNode* node = config->getSyncSourceNode(currSource);
+        if (!node) {
+            ret = lastErrorCode;
+            goto finally;
+        }
+        if (!config->getSyncSourceConfig(node->getName(), sc)) {
+            ret = lastErrorCode;
+            goto finally;
+        }
+        ret = createSyncSource(node->getName(),
+                               sc, *node,
+                               sources + numActive);
+        if (ret) {
+            goto finally;
+        }
+
+        if (sources[numActive]) {
+            numActive++;
+        }
+
+        currSource++;
+    }
+    sources[numActive] = NULL;
+    config->close();
+
+    ret = beginSync();
+    if (ret) {
+        goto finally;
+    }
+
+    // ready to synchronize
+    ret = sync(sources);
+
+  finally:
+    if (sources) {
+        // sources themselves are owned by creator
+        delete [] sources;
+    }
+    config->close();
+
+    return ret;
 }
 
+// copy from SyncSource::getSend/RecvTypes() format into array list
+// of ContentTypeInfos
+static void fillContentTypeInfoList(ArrayList &l, const BCHAR** types)
+{
+    const BCHAR** curr;
+    
+    l.clear();
+    if (!types) {
+        return;
+    }
+
+    curr = types;
+    while (curr[0] && curr[1]) {
+        ContentTypeInfo cti(curr[0], curr[1]);
+        l.add(cti);
+        curr += 2;
+    }
+}
+
+DevInf *SyncClient::createDeviceInfo(SyncSource **sources)
+{
+    VerDTD verdtd(T("1.1"));
+    const BCHAR *rxType, *rxVer,
+        *txType, *txVer;
+
+    // check that essential information is available
+    // for each source
+    for (SyncSource **source = sources;
+         *source;
+         source++) {
+        
+        (*sources)->getPreferredTypes(rxType, rxVer,
+                                      txType, txVer);
+
+        if (!rxType || !rxVer || !txType || !txVer) {
+            return NULL;
+        }
+    }
+    
+    DevInf *devinfo = new DevInf();
+    devinfo->setVerDTD(&verdtd);
+    devinfo->setMan(getManufacturer());
+    devinfo->setMod(getClientID());
+    devinfo->setSwV(getClientVersion());
+    devinfo->setDevID(config->getAccessConfig().getDeviceId());
+    const char *devType = getClientType();
+    devinfo->setDevTyp(devType ? devType : "workstation");
+    devinfo->setUTC(isUTC());
+    // not sure whether the client library supports this
+    devinfo->setSupportLargeObjs(FALSE);
+    devinfo->setSupportNumberOfChanges(FALSE);
+
+    static const struct {
+        SyncMode mode;
+        int type;
+    } mapping[] = {
+        { SYNC_TWO_WAY, 1 },             // Support of 'two-way sync'
+        { SYNC_SLOW, 2 },                // Support of 'slow two-way sync'
+        { SYNC_ONE_WAY_FROM_CLIENT, 3 }, // Support of 'one-way sync from client only'
+        { SYNC_REFRESH_FROM_CLIENT, 4 }, // Support of 'refresh sync from client only'
+        { SYNC_ONE_WAY_FROM_SERVER, 5 }, // Support of 'one-way sync from server only'
+        { SYNC_REFRESH_FROM_SERVER, 6 }, // Support of 'refresh sync from server only'
+        // 7, // Support of 'server alerted sync'
+        { SYNC_NONE, -1 }
+    };
+
+    ArrayList dataStores;
+    for (SyncSource **source = sources;
+         *source;
+         source++) {
+        ArrayList syncModeList;
+        const BCHAR *syncModes = (*source)->getConfig().getSyncModes();
+        if (syncModes) {
+            BCHAR buffer[80];
+            const BCHAR *mode = syncModes;
+
+            while (*mode) {
+                // skip leading spaces and commas
+                while (isspace(*mode) || *mode == ',') {
+                    mode++;
+                }
+                // fast-forward to comma
+                const BCHAR *eostr = mode;
+                while (*eostr && *eostr != ',') {
+                    eostr++;
+                }
+                // strip spaces directly before comma
+                while (eostr > mode && isspace(eostr[-1])) {
+                    eostr--;
+                }
+                // make temporary copy (mode is read-only)
+                size_t len = eostr - mode;
+                if (len > sizeof(buffer) - 1) {
+                    len = sizeof(buffer) - 1;
+                }
+                memcpy(buffer, mode, sizeof(BCHAR) * len);
+                buffer[len] = 0;
+                SyncMode sm = syncModeCode(buffer);
+                for (int i = 0; mapping[i].type >= 0; i++) {
+                    if (mapping[i].mode == sm) {
+                        SyncType syncType(mapping[i].type);
+                        syncModeList.add(syncType);
+                        break;
+                    }
+                }
+
+                // next item
+                mode = eostr;
+            }
+        }
+
+        SourceRef sourceRef((*source)->getName());
+        (*sources)->getPreferredTypes(rxType, rxVer,
+                                      txType, txVer);
+        ContentTypeInfo rxPref(rxType, rxVer);
+        ArrayList rx;
+        fillContentTypeInfoList(rx, (*source)->getRecvTypes());
+        ContentTypeInfo txPref(txType, txVer);
+        ArrayList tx;
+        fillContentTypeInfoList(rx, (*source)->getSendTypes());
+        SyncCap syncCap(&syncModeList);
+        DataStore dataStore(&sourceRef,
+                            NULL,
+                            -1,
+                            &rxPref,
+                            &rx,
+                            &txPref,
+                            &tx,
+                            NULL,
+                            &syncCap);
+        dataStores.add(dataStore);
+    }
+    devinfo->setDataStore(&dataStores);
+
+#if 0
+    // dummy CTCap - has no effect because Formatter::getCTCaps() has
+    // not be implemented yet
+    ArrayList empty;
+    ArrayList ctPropParams;
+    CTPropParam param(T("X-FOO"),
+                      NULL, 0, NULL, &empty);
+    ctPropParams.add(param);
+    CTTypeSupported cttType(T("text/x-foo"), &ctPropParams);
+    ArrayList ctCap;
+    ctCap.add(cttType);
+    devinfo->setCTCap(&ctCap);
 #endif
+
+    return devinfo;
+}
--- native/src/c++/common/http/TransportAgent.cpp~devinfo
+++ native/src/c++/common/http/TransportAgent.cpp
@@ -30,6 +30,7 @@
     url     = newURL ;
     timeout = timeout;
     maxmsgsize  = maxmsgsize;
+    userAgent[0] = 0;
 }
 
 TransportAgent::~TransportAgent() {
@@ -74,4 +75,4 @@
 
 BCHAR* TransportAgent::getUserAgent() {
     return stringdup(userAgent);
-}
\ No newline at end of file
+}
--- native/src/c++/common/spdm/ManagementNode.cpp~devinfo
+++ native/src/c++/common/spdm/ManagementNode.cpp
@@ -80,6 +80,10 @@
 	return 0;
 }
 
+const BCHAR *ManagementNode::getName() {
+    return name;
+}
+
 /*
  * Returns how many children belong to this node.
  *
--- native/src/c++/common/spds/AccessConfig.cpp~devinfo
+++ native/src/c++/common/spds/AccessConfig.cpp
@@ -45,6 +45,7 @@
     clientAuthType        = NULL;
     serverAuthType        = NULL;
     isServerAuthRequired  = FALSE;  // F = FALSE, T = TRUE
+    devInfHash            = NULL;
 
     maxMsgSize            = 0;
     maxModPerMsg          = 0;
@@ -75,9 +76,10 @@
     safeDelete(&userAgent           );
     safeDelete(&proxyUsername       );
     safeDelete(&proxyPassword       );
+    safeDelete(&devInfHash          );
 }
 
-BOOL AccessConfig::getServerAuthRequired() {
+BOOL AccessConfig::getServerAuthRequired() const {
     return isServerAuthRequired;
 }
 
@@ -87,7 +89,7 @@
     dirty |= DIRTY_SERVERAUTH_REQUIRED;
 }
 
-const BCHAR* AccessConfig::getServerAuthType(const BCHAR* buf) {
+const BCHAR* AccessConfig::getServerAuthType(const BCHAR* buf) const {
     if (buf == NULL) {
         return serverAuthType;
     }
@@ -101,7 +103,7 @@
 }
 
 
-const BCHAR* AccessConfig::getClientAuthType(const BCHAR* buf) {
+const BCHAR* AccessConfig::getClientAuthType(const BCHAR* buf) const {
     if (buf == NULL) {
         return clientAuthType;
     }
@@ -116,7 +118,7 @@
     dirty |= DIRTY_CLIENTAUTHTYPE; 
 }
 
-const BCHAR* AccessConfig::getServerPWD(const BCHAR* buf) {
+const BCHAR* AccessConfig::getServerPWD(const BCHAR* buf) const {
     if (buf == NULL) {
 		return serverPWD;
     }
@@ -131,7 +133,7 @@
     dirty |= DIRTY_SERVERPWD;
 }
 
-const BCHAR* AccessConfig::getServerID(const BCHAR* buf) {
+const BCHAR* AccessConfig::getServerID(const BCHAR* buf) const {
     if (buf == NULL) {
 		return serverID;
     }
@@ -146,7 +148,7 @@
     dirty |= DIRTY_SERVERID;
 }
 
-const BCHAR* AccessConfig::getServerNonce(const BCHAR* buf) {
+const BCHAR* AccessConfig::getServerNonce(const BCHAR* buf) const {
     if (buf == NULL) {
 		return serverNonce;
     }
@@ -161,7 +163,7 @@
     dirty |= DIRTY_SERVER_NONCE;
 }
 
-const BCHAR* AccessConfig::getClientNonce(const BCHAR* buf) {
+const BCHAR* AccessConfig::getClientNonce(const BCHAR* buf) const {
     if (buf == NULL) {
 		return clientNonce;
     }
@@ -176,7 +178,7 @@
     dirty |= DIRTY_CLIENT_NONCE;
 }
 
-const BCHAR* AccessConfig::getUsername(const BCHAR* buf) {
+const BCHAR* AccessConfig::getUsername(const BCHAR* buf) const {
     if (buf == NULL) {
 		return username;
     }
@@ -192,7 +194,7 @@
 }
 
 
-const BCHAR* AccessConfig::getPassword(const BCHAR* buf) {
+const BCHAR* AccessConfig::getPassword(const BCHAR* buf) const {
     if (buf == NULL) {
 		return password;
     }
@@ -207,7 +209,7 @@
 }
 
 
-const BCHAR* AccessConfig::getDeviceId(const BCHAR* buf) {
+const BCHAR* AccessConfig::getDeviceId(const BCHAR* buf) const {
     if (buf == NULL) {
 		return deviceId;
     }
@@ -221,7 +223,7 @@
     dirty |= DIRTY_DEVICE_ID;
 }
 
-SyncMode AccessConfig::getFirstTimeSyncMode() {
+SyncMode AccessConfig::getFirstTimeSyncMode() const {
     return firstTimeSyncMode;
 }
 
@@ -231,7 +233,7 @@
     dirty |= DIRTY_FIRST_TIME_SYNC_MODE;
 }
 
-BOOL AccessConfig::getUseProxy() {
+BOOL AccessConfig::getUseProxy() const {
     return useProxy;
 }
 
@@ -241,7 +243,7 @@
     dirty |= DIRTY_USE_PROXY;
 }
 
-const BCHAR* AccessConfig::getProxyHost(const BCHAR* buf) {
+const BCHAR* AccessConfig::getProxyHost(const BCHAR* buf) const {
     if (buf == NULL) {
 		return proxyHost;
 	}
@@ -256,7 +258,7 @@
 }
 
 
-BCHAR* AccessConfig::getProxyUsername(const BCHAR* buf) {
+BCHAR* AccessConfig::getProxyUsername(const BCHAR* buf) const {
     if (buf == NULL) {
 		return proxyUsername;
 	}
@@ -268,7 +270,7 @@
 	set(&proxyUsername, v);
 }
 
-BCHAR* AccessConfig::getProxyPassword(const BCHAR* buf) {
+BCHAR* AccessConfig::getProxyPassword(const BCHAR* buf) const {
     if (buf == NULL) {
 		return proxyPassword;
 	}
@@ -280,7 +282,7 @@
 	set(&proxyPassword, v);
 }
 
-const BCHAR* AccessConfig::getUserAgent() {    
+const BCHAR* AccessConfig::getUserAgent() const {    
     return userAgent;	
 }
 
@@ -288,7 +290,7 @@
 	set(&userAgent, v);	    
 }
 
-const BCHAR* AccessConfig::getSyncURL(const BCHAR* buf) {
+const BCHAR* AccessConfig::getSyncURL(const BCHAR* buf) const {
     if (buf == NULL) {
 		return syncURL;
 	}
@@ -325,7 +327,7 @@
     dirty |= DIRTY_SYNC_BEGIN;
 }
 
-unsigned long AccessConfig::getBeginSync() {
+unsigned long AccessConfig::getBeginSync() const {
     return beginTimestamp;
 }
 
@@ -333,7 +335,7 @@
     maxMsgSize = msgSize;
 }
 
-unsigned long AccessConfig::getMaxMsgSize() {
+unsigned long AccessConfig::getMaxMsgSize() const {
     return maxMsgSize;
 }
 
@@ -341,7 +343,7 @@
     readBufferSize = bufferSize;
 }
 
-unsigned long AccessConfig::getReadBufferSize() {
+unsigned long AccessConfig::getReadBufferSize() const {
     return readBufferSize;
 }
 
@@ -349,7 +351,7 @@
     maxModPerMsg = mod;
 }
 
-unsigned long AccessConfig::getMaxModPerMsg() {
+unsigned long AccessConfig::getMaxModPerMsg() const {
     return maxModPerMsg;
 }
 
@@ -358,11 +360,20 @@
     dirty |= DIRTY_SYNC_END;
 }
 
-unsigned long AccessConfig::getEndSync() {
+unsigned long AccessConfig::getEndSync() const {
     return endTimestamp;
 }
 
-unsigned int AccessConfig::getDirty() {
+const BCHAR* AccessConfig::getDevInfHash() const {
+    return devInfHash;
+}
+
+void AccessConfig::setDevInfHash(const BCHAR *v) {
+    set(&devInfHash, v);
+    dirty |= DIRTY_DEV_INF_HASH;
+}
+
+unsigned int AccessConfig::getDirty() const {
     return dirty;
 }
 
@@ -378,7 +389,7 @@
 	bstrcpy(*buf, v);
 }
 
-BOOL AccessConfig::getEncryption() {
+BOOL AccessConfig::getEncryption() const {
     return encryption;   
 }
 
@@ -416,6 +427,7 @@
     setMaxModPerMsg(s.getMaxModPerMsg());
     setReadBufferSize(s.getReadBufferSize());
     setEncryption  (s.getEncryption()  );
+    setDevInfHash(s.getDevInfHash());
 
 	dirty = s.getDirty();
 }
--- native/src/c++/common/spds/SyncManager.cpp~devinfo
+++ native/src/c++/common/spds/SyncManager.cpp
@@ -64,19 +64,28 @@
     return true;
 }
 
-SyncManager::SyncManager(SyncManagerConfig* c) : config(*c) {
-    initialize();
-}
-
-SyncManager::SyncManager(SyncManagerConfig& c) : config(c) {
+SyncManager::SyncManager(SyncManagerConfig& c, DevInf* di) : config(c), devInf(di) {
     initialize();
 }
 
 void SyncManager::initialize() {
+    // set all values which are checked by the destructor;
+    // previously some pointers were only set later, leading to
+    // uninitialized memory reads and potential crashes when
+    // constructing a SyncManager, but not using it
+    transportAgent = NULL;
+    mappings       = NULL;
+    sources        = NULL;
+    currentState   = STATE_START;
+    mappings       = NULL;
+    check          = NULL;
+    sourcesNumber  = 0;
+    sources        = NULL;
+    count          = 0;
+    commands       = NULL;
+
     AccessConfig& c = config.getAccessConfig();   
     
-    credentialHandler = CredentialHandler();
-
     bstrncpy(syncURL, c.getSyncURL(), 511);
     bstrncpy(deviceId, c.getDeviceId(), 31);
     
@@ -91,15 +100,7 @@
     credentialHandler.setServerAuthType     (c.getServerAuthType());
     credentialHandler.setServerAuthRequired (c.getServerAuthRequired());
             
-    transportAgent = NULL;
-    
-    currentState = STATE_START;
-
     commands = new ArrayList();
-    mappings      = NULL;
-    check         = NULL;
-    sourcesNumber = 0;
-    count         = 0;
 
     maxMsgSize   = c.getMaxMsgSize();
     maxModPerMsg = 150;  // dafault value
@@ -111,12 +112,6 @@
     if (c.getReadBufferSize() > 0)
         readBufferSize = c.getReadBufferSize();
     
-    memset(userAgent, 0, 128*sizeof(BCHAR));
-    bstrcpy(userAgent, c.getUserAgent());
-    if (bstrlen(userAgent) == 0) {
-        bstrcpy(userAgent, BCHAR_USER_AGENT);
-    }
-                  
     syncMLBuilder.set(syncURL, deviceId, maxMsgSize);
     memset(credentialInfo, 0, 256*sizeof(BCHAR));
 }
@@ -176,6 +171,9 @@
     Cred*   cred                = NULL;
     Alert*  alert               = NULL;
     SyncSource** buf            = NULL;
+    StringBuffer* devInfStr     = NULL;
+    BOOL putDevInf              = FALSE;
+    BCHAR devInfHash[16 * 4 +1]; // worst case factor base64 is four
     const BCHAR *syncURL;
     
     syncURL = config.getAccessConfig().getSyncURL(); //sizeof(syncURL));
@@ -226,20 +224,47 @@
             check[count] = 0;
         }
     }
+
+    // check device information for changes
+    if (devInf) {
+        char md5[16];
+        devInfStr = Formatter::getDevInf(devInf);
+        LOG.debug(T("devinfo: %s"), devInfStr->c_str());
+        calculateMD5(devInfStr->c_str(), devInfStr->length(), md5);
+        devInfHash[b64_encode(devInfHash, md5, sizeof(md5))] = 0;
+        LOG.debug(T("devinfo hash: %s"), devInfHash);
+
+        // compare against previous device info hash:
+        // if different, then the local config has changed and
+        // infos should be sent again
+        if (bstrcmp(devInfHash, config.getAccessConfig().getDevInfHash())) {
+            putDevInf = TRUE;
+        }
+        LOG.debug(T("devinfo %s"), putDevInf ? T("changed, retransmit") : T("unchanged, no need to send"));
+    } else {
+        LOG.debug(T("no devinfo available"));
+    }
+
+    // have device infos changed since the last time that they were
+    // sent or is this the initial sync?
     
+
+    // disable all SyncSources without a preferred sync mode
     for (count = 0; count < sourcesNumber; count ++) {
         if (!check[count])
             continue;
 
-        if (sources[count]->getSyncMode() == SYNC_NONE) {
+        if (sources[count]->getPreferredSyncMode() == SYNC_NONE) {
             check[count] = 0;
         }
     }
         
     if (isToExit(check, sourcesNumber)) {
-        // error. no source to sync
-        ret = lastErrorCode = ERR_NO_SOURCE_TO_SYNC;
-        bsprintf(lastErrorMsg, ERRMSG_NO_SOURCE_TO_SYNC);
+        if (!ret) {
+            // error: no source to sync
+            ret = lastErrorCode = ERR_NO_SOURCE_TO_SYNC;
+            bsprintf(lastErrorMsg, ERRMSG_NO_SOURCE_TO_SYNC);
+        }
 
         goto finally;
     }
@@ -285,6 +310,17 @@
             cred = credentialHandler.getClientCredential();             
             bstrcpy(credentialInfo, cred->getAuthentication()->getData(NULL));
         }
+
+        // actively send out device infos?
+        if (putDevInf) {
+            AbstractCommand* put = syncMLBuilder.prepareDevInf(NULL, *devInf);
+            if (put) {
+                commands->add(*put);
+                delete put;
+            }
+            putDevInf = FALSE;
+        }
+        
         // "cred" only contains an encoded strings as username, also
         // need the original username for LocName
         syncml = syncMLBuilder.prepareInitObject(cred, alerts, commands);
@@ -307,7 +343,8 @@
         if (transportAgent == NULL) {
             transportAgent = TransportAgentFactory::getTransportAgent(url, proxy);
             transportAgent->setReadBufferSize(readBufferSize);
-            transportAgent->setUserAgent(userAgent);            
+            // TODO: change API of TransportAgent to use const
+            transportAgent->setUserAgent((BCHAR *)config.getAccessConfig().getUserAgent());
             
             if (maxMsgSize > 0) {
                 transportAgent->setMaxMsgSize(maxMsgSize);
@@ -468,7 +505,68 @@
                 commands->add(*status);
                 deleteStatus(&status);    
             }
-        }  
+        }
+
+        //
+        // Process Put/Get commands
+        //
+        list = syncml->getSyncBody()->getCommands();
+        int cmdindex;
+        for (cmdindex = 0; cmdindex < list->size(); cmdindex++) {
+            AbstractCommand* cmd = (AbstractCommand*)list->get(cmdindex);
+            BCHAR* name = cmd->getName();
+            if (name) {
+                BOOL isPut = !bstrcmp(name, PUT);
+                BOOL isGet = !bstrcmp(name, GET);
+
+                if (isGet || isPut) {
+                    int statusCode = 200; // if set, then send it (on by default)
+
+                    if (isGet) {
+                        Get *get = (Get *)cmd;
+                        ArrayList *items = get->getItems();
+                        BOOL sendDevInf = FALSE;
+
+                        Results results;
+                        for (int i = 0; i < items->size(); i++) {
+                            Item *item = (Item *)items->get(i);
+                        
+                            // we are not very picky: as long as the Item is
+                            // called "./devinf11" as required by the standard
+                            // we return our device infos
+                            Target *target = item->getTarget();
+                            if (target && target->getLocURI() &&
+                                !bstrcmp(target->getLocURI(),
+                                         DEVINF_URI)) {
+                                sendDevInf = TRUE;
+                            } else {
+                                LOG.debug(T("ignoring request to Get item #%d"), i);
+                            }
+                        }
+
+                        // cannot send if we have nothing, then simply acknowledge the request,
+                        // but ignore it
+                        if (sendDevInf && devInf) {
+                            AbstractCommand *result = syncMLBuilder.prepareDevInf(cmd, *devInf);
+                            if (result) {
+                                commands->add(*result);
+                                delete result;
+                            }
+                        }
+                    } else {
+                        // simply acknowledge Put
+                    }
+
+                    if (statusCode) {
+                        status = syncMLBuilder.prepareCmdStatus(*cmd, statusCode);
+                        if (status) {
+                            commands->add(*status);
+                            deleteStatus(&status);    
+                        }
+                    }
+                }
+            }
+        }
         
         //
         // Client Authentication. The auth of the client on the server
@@ -517,6 +615,7 @@
 
     config.getAccessConfig().setClientNonce(credentialHandler.getClientNonce(NULL));
     config.getAccessConfig().setServerNonce(credentialHandler.getServerNonce(NULL));
+    config.getAccessConfig().setDevInfHash(devInfHash);
     
     if (isToExit(check, sourcesNumber)) {
         // error. no source to sync
@@ -538,6 +637,9 @@
     if (initMsg) {
         safeDelete(&initMsg);
     }
+    if (devInfStr) {
+        delete devInfStr;
+    }
 
     deleteSyncML(&syncml);
     deleteCred(&cred);
@@ -699,7 +801,7 @@
             } else {
                 // TBD: if we are using vcard/icalendar, we need to 
                 // set the encoding to PLAIN
-                if (bstrcmp(_wcc(sources[count]->getEncoding()), B64_ENCODING) == 0) {
+                if (bstrcmp(sources[count]->getConfig().getEncoding(), B64_ENCODING) == 0) {
                     syncMLBuilder.setEncoding(B64);
                 } else {
                     syncMLBuilder.setEncoding(PLAIN);
@@ -752,13 +854,13 @@
                                     syncMLBuilder.prepareModificationCommand(
                                                             REPLACE_COMMAND_NAME, 
                                                             syncItem,
-                                                            sources[count]->getType()
+                                                            sources[count]->getConfig().getType()
                                                   );
                             } else {
                                 syncMLBuilder.addItem(modificationCommand,
                                                       REPLACE_COMMAND_NAME,
                                                       syncItem, 
-                                                      sources[count]->getType());
+                                                      sources[count]->getConfig().getType());
                             }
 
                             if (syncItem) {
@@ -808,10 +910,10 @@
                             }
                             if (modificationCommand == NULL) {
                                 modificationCommand = syncMLBuilder.prepareModificationCommand(REPLACE_COMMAND_NAME, 
-                                        syncItem, sources[count]->getType());
+                                                                                               syncItem, sources[count]->getConfig().getType());
                             } else {
                                 syncMLBuilder.addItem(modificationCommand, REPLACE_COMMAND_NAME, syncItem, 
-                                        sources[count]->getType());
+                                                      sources[count]->getConfig().getType());
                             }
 
                             if (syncItem) {
@@ -846,10 +948,10 @@
                                 }
                                 if (modificationCommand == NULL) {
                                     modificationCommand = syncMLBuilder.prepareModificationCommand(ADD_COMMAND_NAME, 
-                                            syncItem, sources[count]->getType());
+                                                                                                   syncItem, sources[count]->getConfig().getType());
                                 } else {
                                     syncMLBuilder.addItem(modificationCommand, ADD_COMMAND_NAME, 
-                                            syncItem, sources[count]->getType());
+                                                          syncItem, sources[count]->getConfig().getType());
                                 }
 
                                 if (syncItem) {
@@ -888,10 +990,10 @@
                                 }
                                 if (modificationCommand == NULL) {
                                     modificationCommand = syncMLBuilder.prepareModificationCommand(REPLACE_COMMAND_NAME, 
-                                            syncItem, sources[count]->getType());
+                                                                                                   syncItem, sources[count]->getConfig().getType());
                                 } else {
                                     syncMLBuilder.addItem(modificationCommand, REPLACE_COMMAND_NAME, 
-                                            syncItem, sources[count]->getType());
+                                                          syncItem, sources[count]->getConfig().getType());
                                 }
 
                                 if (syncItem) {                            
@@ -929,10 +1031,10 @@
                                 }
                                 if (modificationCommand == NULL) {
                                     modificationCommand = syncMLBuilder.prepareModificationCommand(DELETE_COMMAND_NAME, 
-                                            syncItem, sources[count]->getType());
+                                                                                                   syncItem, sources[count]->getConfig().getType());
                                 } else {
                                     syncMLBuilder.addItem(modificationCommand, DELETE_COMMAND_NAME, 
-                                            syncItem, sources[count]->getType());
+                                            syncItem, sources[count]->getConfig().getType());
                                 }
 
                                 if (syncItem) {                            
@@ -1338,7 +1440,7 @@
                 lastErrorCode = sret;
             }
         }        
-    }         
+    }
             
  finally:
 
@@ -1377,46 +1479,26 @@
 }
 
 BOOL SyncManager::readSyncSourceDefinition(SyncSource& source) {
-    SyncSourceConfig ssc;
     BCHAR anchor[DIM_ANCHOR];
     
-    if (config.getSyncSourceConfig(_wcc(source.getName()), ssc) == FALSE) {
+    if (config.getSyncSourceConfig(_wcc(source.getName()), source.getConfig()) == FALSE) {
         return FALSE;
     }
 
-    /* This check could be removed because the sync type is decided later from server.
-       This kind of sync should be read by the settings
-       So, the follow code was used in the previous version of the api.
-
-    // syncMode set only if value has no good value...
-    if (source.getPreferredSyncMode() == NULL ||
-        source.getPreferredSyncMode() < 0     ||
-        source.getPreferredSyncMode() > 210      )  {
-
-        //source.setPreferredSyncMode(syncModeCode(ssc.getSync()));
-    }
-    */
-    source.setPreferredSyncMode(syncModeCode(ssc.getSync()));
+    SyncSourceConfig& ssc(source.getConfig());
 
-    source.setType(ssc.getType());
-    source.setLastSync(ssc.getLast());
+    // only copy properties which either have a different format
+    // or are expected to change during the synchronization
     timestampToAnchor(ssc.getLast(), anchor);
     source.setLastAnchor(anchor);
     timestampToAnchor(source.getNextSync(), anchor);
     source.setNextAnchor(anchor);
 
-    wchar_t *remuri = toWideChar(ssc.getURI());
-    wchar_t *enc = toWideChar(ssc.getEncoding());
-    source.setRemoteURI(remuri);
-    source.setEncoding(enc);
-
-    delete [] remuri; delete [] enc;
-
     return TRUE;
 }
 
 
-BOOL SyncManager::commitChanges(SyncSource& source) {
+BOOL SyncManager::commitChanges(SyncSource& source) { 
     unsigned int n = config.getSyncSourceConfigsCount();
     SyncSourceConfig* configs = config.getSyncSourceConfigs();
 
@@ -1637,5 +1719,3 @@
     }
     
 }
-
-
--- native/src/c++/common/spds/SyncMLBuilder.cpp~devinfo
+++ native/src/c++/common/spds/SyncMLBuilder.cpp
@@ -216,7 +216,7 @@
     CmdID* cmdRef            = sync->getCmdID();
 
     
-    TargetRef*    tar        = new TargetRef(_wcc(source.getRemoteURI()));
+    TargetRef*    tar        = new TargetRef(source.getConfig().getURI());
     SourceRef*    sou        = new SourceRef(_wcc(source.getName()));
     targetRefs->add(*tar);
     sourceRefs->add(*sou);
@@ -300,7 +300,7 @@
     ArrayList*    targetRefs = new ArrayList();
     ArrayList*    sourceRefs = new ArrayList();
     
-    TargetRef*    tar        = new TargetRef(_wcc(source.getRemoteURI()));
+    TargetRef*    tar        = new TargetRef(source.getConfig().getURI());
     SourceRef*    sou        = new SourceRef(_wcc(source.getName()));
     targetRefs->add(*tar);
     sourceRefs->add(*sou);
@@ -355,12 +355,114 @@
     return s;
 }
 
+/*
+* Return the status against an arbitrary command.
+*/
+Status* SyncMLBuilder::prepareCmdStatus(AbstractCommand &cmd, int status) {
+    /*
+    <Status>\n
+        <CmdID>2</CmdID>\n
+        <MsgRef>1</MsgRef>
+        <CmdRef>1</CmdRef>
+        <Cmd>cmd</Cmd>\n
+        <Data>status</Data>\n
+    </Status>
+    */
+    
+    ++cmdID;
+
+    CmdID commandID(itow(cmdID));
+    Data d(status);
+    char *msgRefStr = itow(msgRef);
+    ArrayList empty;
+
+    Status* s = new Status(&commandID, msgRefStr, cmd.getCmdID()->getCmdID(), cmd.getName(), &empty, &empty, NULL, NULL, &d, NULL);
+    
+    delete [] msgRefStr;
+    
+    return s;
+}
+
+AbstractCommand *SyncMLBuilder::prepareDevInf(AbstractCommand *cmd, DevInf &devInf)
+{
+    AbstractCommand *res = NULL;
+    char *msgRefStr = NULL;
+
+    Source source(DEVINF_URI);
+    Meta meta;
+    meta.setType(DEVINF_FORMAT);
+    // meta.setFormat(T("xml"));
+    ComplexData complexData;
+    complexData.setDevInf(&devInf);
+    Item item(NULL,
+              &source,
+              NULL,
+              &complexData,
+              FALSE);
+    
+
+    ++cmdID;
+    CmdID commandID(itow(cmdID));
+    ArrayList items;
+    items.add(item);
+
+    if (cmd) {
+        /*
+          <Result>
+          <CmdID>2</CmdID>
+          <MsgRef>1</MsgRef>
+          <CmdRef>4</CmdRef>
+          <Meta><Type xmlns='syncml:metinf'>application/vnd.syncml-devinf+xml</Type></Meta>
+          <Item>
+            <SourceRef><LocURI>./devinf11</LocURI></SourceRef>
+            <Data>
+              <DevInf>...</DevInf>
+            </Data>
+          </Item>
+          </Result>
+        */
+
+        msgRefStr = itow(msgRef);
+        ArrayList empty;
+        res = new Results(&commandID,
+                          msgRefStr,
+                          cmd->getCmdID()->getCmdID(),
+                          &meta,
+                          &empty,
+                          &empty,
+                          &items);
+    } else {
+        /*
+          <Put>
+            <CmdID>2</CmdID>
+            <Meta><Type xmlns='syncml:metinf'>application/vnd.syncml-devinf+xml</Type></Meta>
+            <Item>
+              <Source><LocURI>./devinf11</LocURI></Source>
+              <Data>
+                <DevInf xmlns='syncml:devinf'>...</DevInf>
+              </Data>
+            </Item>
+          </Put>
+        */
+
+        res = new Put(&commandID,
+                      FALSE,
+                      NULL,
+                      NULL,
+                      &meta,
+                      &items);
+    }
+    safeDelete(&msgRefStr);
+    return res;
+}
+
+
 Alert* SyncMLBuilder::prepareRequestAlert(SyncSource& s) {
     
     ++cmdID;
 
     CmdID* commandID     = new CmdID(itow(cmdID));    
-    Target* tar          = new Target(_wcc(s.getRemoteURI()));
+    Target* tar          = new Target(s.getConfig().getURI());
     Source* sou          = new Source(_wcc(s.getName()));     
     Item* item           = new Item(tar, sou, NULL, NULL, FALSE);
 
@@ -383,7 +485,7 @@
 
     CmdID* commandID     = new CmdID(itow(cmdID));
     int data             = s.getPreferredSyncMode();
-    Target* tar          = new Target(_wcc(s.getRemoteURI()));    
+    Target* tar          = new Target(s.getConfig().getURI());
     Source* sou          = new Source(_wcc(s.getName()));
 
     //
@@ -708,7 +810,7 @@
     ++cmdID;
 
     CmdID* commandID     = new CmdID(itow(cmdID));
-    Target* tar          = new Target(_wcc(source.getRemoteURI()));
+    Target* tar          = new Target(source.getConfig().getURI());
     Source* sou          = new Source(_wcc(source.getName())); 
     ArrayList* list      = new ArrayList();  
     Sync* sync           = NULL;
@@ -736,7 +838,7 @@
     */
     ++cmdID;
     CmdID* commandID     = new CmdID(itow(cmdID));    
-    Target* tar          = new Target(_wcc(s.getRemoteURI()));
+    Target* tar          = new Target(s.getConfig().getURI());
     Source* sou          = new Source(_wcc(s.getName()));
     ArrayList* mapItems  = new ArrayList();
     Map* map = new Map(commandID, tar, sou, NULL, NULL, mapItems);
--- native/src/c++/common/spds/SyncMLProcessor.cpp~devinfo
+++ native/src/c++/common/spds/SyncMLProcessor.cpp
@@ -195,9 +195,17 @@
             for (k = 0; k < items->size(); k++) {
                 item = (Item*)items->get(k);
                 if (item) {
-                    wchar_t *uri = toWideChar(item->getSource()->getLocURI());
-                    source.setItemStatus(uri, val);
-                    delete [] uri;
+                    Source* itemSource = item->getSource();
+                    if (itemSource) {
+                        wchar_t *uri = toWideChar(itemSource->getLocURI());
+                        source.setItemStatus(uri, val);
+                        delete [] uri;
+                    } else {
+                        // the item might consist of additional information, as in:
+                        // <SourceRef>pas-id-44B544A600000092</SourceRef>
+                        // <Data>200</Data>
+                        // <Item><Data>Conflict resolved by server</Data></Item>
+                    }
                 }
             }
             items = s->getSourceRef();
--- native/src/c++/common/spds/SyncSourceConfig.cpp~devinfo
+++ native/src/c++/common/spds/SyncSourceConfig.cpp
@@ -54,12 +54,8 @@
 }
 
 
-const BCHAR* SyncSourceConfig::getName(BCHAR* buf) const {
-    if (buf == NULL) {
-        return name;
-    }
-
-    return bstrcpy(buf, name);
+const BCHAR* SyncSourceConfig::getName() const {
+    return name;
 }
 
 void SyncSourceConfig::setName(const BCHAR* n) {
@@ -67,12 +63,10 @@
     name = stringdup(n);
 }
 
-const BCHAR* SyncSourceConfig::getURI(BCHAR* buf) const {
-    if (buf == NULL) {
-        return uri;
-    }
-
-    return bstrcpy(buf, uri);
+const BCHAR* SyncSourceConfig::getURI() const {
+    return uri ? uri :
+        name ? name :
+        "";
 }
 
 void SyncSourceConfig::setURI(const BCHAR* u) {
@@ -81,12 +75,10 @@
 }
 
 
-const BCHAR* SyncSourceConfig::getSyncModes(BCHAR* buf) const {
-    if (buf == NULL) {
-        return syncModes;
-    }
-
-    return bstrcpy(buf, syncModes);
+const BCHAR* SyncSourceConfig::getSyncModes() const {
+    return syncModes ? syncModes :
+        "";
+        
 }
 
 void SyncSourceConfig::setSyncModes(const BCHAR* s) {
@@ -98,12 +90,9 @@
     }
 }
 
-const BCHAR* SyncSourceConfig::getType(BCHAR* buf) const {
-    if (buf == NULL) {
-        return type;
-    }
-
-    return bstrcpy(buf, type);
+const BCHAR* SyncSourceConfig::getType() const {
+    return type ? type :
+        "";
 }
 
 void SyncSourceConfig::setType(const BCHAR* t) {
@@ -115,12 +104,9 @@
     }
 }
 
-const BCHAR* SyncSourceConfig::getSync(BCHAR* buf) const {
-    if (buf == NULL) {
-        return sync;
-    }
-
-    return bstrcpy(buf, sync);
+const BCHAR* SyncSourceConfig::getSync() const {
+    return sync ? sync :
+        "";
 }
 
 void SyncSourceConfig::setSync(const BCHAR *s) {
@@ -140,12 +126,9 @@
     return (unsigned long)last;
 }
 
-const BCHAR* SyncSourceConfig::getEncoding(BCHAR* buf) const {
-     if (buf == NULL) {
-        return encodings;
-    }
-
-    return bstrcpy(buf, encodings); 
+const BCHAR* SyncSourceConfig::getEncoding() const {
+    return encodings ? encodings :
+        "";
 }
         
 void SyncSourceConfig::setEncoding(const BCHAR* s) {
--- native/src/c++/common/spds/SyncSource.cpp~devinfo
+++ native/src/c++/common/spds/SyncSource.cpp
@@ -20,19 +20,23 @@
 #include "base/util/utils.h"
 #include "base/Log.h"
 #include "client/Sync4jClient.h"
+#include "spds/spdsutils.h"
+
+SyncSource::SyncSource(const wchar_t* sourceName, const SyncSourceConfig *sc) {
+    name = NULL;
+
+    if (sc) {
+        config.assign(*sc);
+    }
 
-SyncSource::SyncSource(const wchar_t* sourceName) {
     if ((sourceName == NULL) || (*sourceName == 0)) {
         lastErrorCode = ERR_PARAMETER_IS_EMPTY;
         bsprintf(lastErrorMsg, T("name cannot be empty (NULL or 0-length)"));
         goto finally;
     }
-
     name = wstrdup(sourceName);
-    remoteURI = wstrdup(sourceName);
 
-    *type = *next = *last = 0;
-    finally:
+  finally:
 
     syncMode = SYNC_NONE;
     lastSync = 0;
@@ -40,7 +44,6 @@
     
     errorHandler = NULL;
     filter       = NULL;
-    encoding     = NULL;
 }
 
 /**
@@ -50,11 +53,6 @@
     if (name) {
         delete [] name;
     }
-
-    if (remoteURI) {
-        delete [] remoteURI;
-    }
-
     if (filter) {
        delete filter;
     }
@@ -97,6 +95,11 @@
      return name;
  }
 
+void SyncSource::setConfig(const SyncSourceConfig& sc) {
+    config.assign(sc);
+    setPreferredSyncMode(syncModeCode(sc.getSync()));
+}
+
 /*
  * Sets the synchronization mode required for the
  * SyncSource.
@@ -115,78 +118,6 @@
 }
 
 /*
- * Sets the synchronization mode required for the
- * SyncSource.
- *
- * @param syncMode - sync synchronization mode
- */
-void SyncSource::setRemoteURI(const wchar_t* uri) {
-    if (remoteURI) {
-        delete [] remoteURI;
-    }
-
-    if (uri) {
-        remoteURI = wstrdup(uri);
-    } else {
-        remoteURI = wstrdup(TEXT(""));
-    }
-}
-
-/*
- * Returns the preferred synchronization mode for the SyncSource
- */
-const wchar_t* SyncSource::getRemoteURI() {   
-    return remoteURI;   
-}
-
-
-/*
- * Sets the encoding parameter
- *
- * @param ecnc - encoding
- */
-void SyncSource::setEncoding(const wchar_t* enc) {
-    if (encoding) {
-        delete [] encoding;
-    }
-
-    if (enc) {
-        encoding = wstrdup(enc);
-    } else {
-        encoding = wstrdup(TEXT(""));
-    }
-}
-
-/*
- * Returns the preferred synchronization mode for the SyncSource
- */
-const wchar_t* SyncSource::getEncoding() {   
-    return encoding;   
-}
-
-/*
- * Sets the mime type standard for the source items
- *
- * @param mimeType the mime type
- */
-void SyncSource::setType(const BCHAR* mimeType) {
-    bstrncpy(type, (mimeType == NULL) ? T("") : mimeType, DIM_MIME_TYPE);
-    type[DIM_MIME_TYPE-1] = 0;
-}
-
-/*
- * Returns the items data mime type. If type is NULL, the pointer to the
- * internal buffer is returned, otherwise the value is copied in the
- * given buffer, which is also returned to the caller.
- *
- * @param mimeType the buffer where to copy the mime type value
- */
-const BCHAR* SyncSource::getType() {
-        return type;
-}
-
-
-/*
  * Sets the server imposed synchronization mode for the SyncSource.
  *
  * @param syncMode - sync synchronization mode
@@ -202,18 +133,13 @@
     return syncMode;
 }
 
-/*
- * Ends the synchronization of the specified source.
- *
- * @param source - the SyncSource to sync
- 
-int SyncSource::endSync(SyncSource& source) {
-    //
-    // TBD
-    //
+int SyncSource::beginSync() {
+    return 0;
+}
+
+int SyncSource::endSync() {
     return 0;
 }
-*/
 
 /*
  * Returns the timestamp in milliseconds of the last synchronization.
@@ -313,3 +239,28 @@
         filter->setClause(f->getClause());
     }
 }
+
+void SyncSource::getPreferredTypes(const BCHAR*& recvType,
+                                   const BCHAR*& recvVersion,
+                                   const BCHAR*& sendType,
+                                   const BCHAR*& sendVersion)
+{
+    const BCHAR *type = config.getType();
+    const BCHAR *ver;
+
+    recvType =
+        sendType = type;
+    if (!bstrcmp(type, "text/x-vcard")) {
+        ver = "2.1";
+    } else if (!bstrcmp(type, "text/vcard")) {
+        ver = "3.0";
+    } else if (!bstrcmp(type, "text/x-calendar")) {
+        ver = "1.0";
+    }else if (!bstrcmp(type, "text/calendar")) {
+        ver = "2.0";
+    } else {
+        ver = "";
+    }
+    sendVersion =
+        recvVersion = ver;
+}
--- native/src/c++/common/syncml/core/ContentTypeInfo.cpp~devinfo
+++ native/src/c++/common/syncml/core/ContentTypeInfo.cpp
@@ -45,7 +45,7 @@
  *                specification - NOT NULL
  *
  */
-ContentTypeInfo::ContentTypeInfo(BCHAR* ctType, BCHAR* verCT) {
+ContentTypeInfo::ContentTypeInfo(const BCHAR* ctType, const BCHAR* verCT) {
     
     this->ctType = NULL;
     this->verCT  = NULL;
@@ -77,7 +77,7 @@
  *
  * @param ctType the content type properties
  */
-void ContentTypeInfo::setCTType(BCHAR* ctType) {
+void ContentTypeInfo::setCTType(const BCHAR* ctType) {
     if (this->ctType) {
         delete [] this->ctType; this->ctType = NULL;
     }
@@ -101,7 +101,7 @@
  *
  * @param verCT the version of the content type
  */
-void ContentTypeInfo::setVerCT(BCHAR* verCT) {
+void ContentTypeInfo::setVerCT(const BCHAR* verCT) {
     if (this->verCT) {
         delete [] this->verCT; this->verCT = NULL;
     }
--- native/src/c++/common/syncml/core/CTPropParam.cpp~devinfo
+++ native/src/c++/common/syncml/core/CTPropParam.cpp
@@ -21,8 +21,12 @@
  
 
 CTPropParam::CTPropParam() {
+    initialize();
+}
+
+void CTPropParam::initialize() {
     propName        = NULL;
-    valEnum         = NULL;       //String[]
+    valEnum         = NULL;
     displayName     = NULL;
     dataType        = NULL;
     size            = 0;
@@ -43,7 +47,7 @@
                         ArrayList* valEnum,
                         BCHAR*   displayName,
                         ArrayList* ctParameters) {
-
+    initialize();
     setPropName(propName);
     setValEnum(valEnum);
     setContentTypeParameters(ctParameters);
@@ -73,10 +77,11 @@
                    int size,
                    BCHAR* displayName,
                    ArrayList* ctParameters) {
-
+    initialize();
     setPropName(propName);
     setContentTypeParameters(ctParameters);
-    
+
+    this->valEnum      = new ArrayList();
     this->dataType     = stringdup(dataType);
     this->size         = size;
     this->displayName  = stringdup(displayName);
--- native/src/c++/common/syncml/core/CTTypeSupported.cpp~devinfo
+++ native/src/c++/common/syncml/core/CTTypeSupported.cpp
@@ -21,8 +21,7 @@
  
 
 CTTypeSupported::CTTypeSupported(){
-    ctType       = NULL;
-    ctPropParams = NULL;    // CTPropParam[]   
+    initialize();
 }
 
 CTTypeSupported::~CTTypeSupported() {
@@ -43,8 +42,14 @@
  *
  */
 CTTypeSupported::CTTypeSupported(BCHAR* ctType, ArrayList* ctPropParams ) {
-     setCTType(ctType);
-     setCTPropParams(ctPropParams);
+    initialize();
+    setCTType(ctType);
+    setCTPropParams(ctPropParams);
+}
+
+void CTTypeSupported::initialize() {
+    ctType       = NULL;
+    ctPropParams = NULL;
 }
 
 
--- native/src/c++/common/syncml/core/DevInf.cpp~devinfo
+++ native/src/c++/common/syncml/core/DevInf.cpp
@@ -68,14 +68,14 @@
 *
 */
 DevInf::DevInf(VerDTD* verDTD,
-        BCHAR* man,
-        BCHAR* mod,
-        BCHAR* oem,
-        BCHAR* fwV,
-        BCHAR* swV,
-        BCHAR* hwV,
-        BCHAR* devID,
-        BCHAR* devTyp,
+        const BCHAR* man,
+        const BCHAR* mod,
+        const BCHAR* oem,
+        const BCHAR* fwV,
+        const BCHAR* swV,
+        const BCHAR* hwV,
+        const BCHAR* devID,
+        const BCHAR* devTyp,
         ArrayList* dataStores,
         ArrayList* ctCap,
         ArrayList* ext,
@@ -173,7 +173,7 @@
 * @param man the device manufacturer property
 *
 */
-void DevInf::setMan(BCHAR* man) {
+void DevInf::setMan(const BCHAR* man) {
     if (this->man) {
         delete [] this->man; this->man = NULL;
     }
@@ -198,7 +198,7 @@
 * @param mod the device model property
 *
 */
-void DevInf::setMod(BCHAR* mod) {
+void DevInf::setMod(const BCHAR* mod) {
     if (this->mod) {
         delete [] this->mod; this->mod = NULL;
     }
@@ -223,7 +223,7 @@
 * @param oem the Original Equipment Manufacturer of the device
 *
 */
-void DevInf::setOEM(BCHAR* oem) {
+void DevInf::setOEM(const BCHAR* oem) {
     if (this->oem) {
         delete [] this->oem; this->oem = NULL;
     }
@@ -248,7 +248,7 @@
 * @param fwV the firmware version property
 *
 */
-void DevInf::setFwV(BCHAR* fwV) {
+void DevInf::setFwV(const BCHAR* fwV) {
     if (this->fwV) {
         delete [] this->fwV; this->fwV = NULL;
     }
@@ -273,7 +273,7 @@
 * @param swV the software version property
 *
 */
-void DevInf::setSwV(BCHAR* swV) {
+void DevInf::setSwV(const BCHAR* swV) {
     if (this->swV) {
         delete [] this->swV; this->swV = NULL;
     }
@@ -298,7 +298,7 @@
 * @param hwV the hardware version property
 *
 */
-void DevInf::setHwV(BCHAR* hwV) {
+void DevInf::setHwV(const BCHAR* hwV) {
     if (this->hwV) {
         delete [] this->hwV; this->hwV = NULL;
     }
@@ -323,7 +323,7 @@
 * @param devID the device identifier
 *
 */
-void DevInf::setDevID(BCHAR* devID) {
+void DevInf::setDevID(const BCHAR* devID) {
     if (devID == NULL) {
             // TBD
     } else {
@@ -352,7 +352,7 @@
 * @param devTyp the device type
 *
 */
-void DevInf::setDevTyp(BCHAR* devTyp) {
+void DevInf::setDevTyp(const BCHAR* devTyp) {
     if (devTyp == NULL) {
             // TBD
     } else {
--- native/src/c++/common/syncml/core/StringElement.cpp~devinfo
+++ native/src/c++/common/syncml/core/StringElement.cpp
@@ -25,7 +25,7 @@
 #include "base/util/utils.h"
 #include "syncml/core/StringElement.h"
  
-StringElement::StringElement(BCHAR* value) {
+StringElement::StringElement(const BCHAR* value) {
     this->value = NULL;
     setValue(value);
 }
@@ -56,7 +56,7 @@
  * @param value the value of string element
  *
  */
-void StringElement::setValue(BCHAR* value) {
+void StringElement::setValue(const BCHAR* value) {
     if (value) {
         delete [] this->value; this->value = NULL;
     }        
--- native/src/c++/common/syncml/formatter/Formatter.cpp~devinfo
+++ native/src/c++/common/syncml/formatter/Formatter.cpp
@@ -1423,7 +1423,7 @@
 
     cmdID     = getCmdID   (put->getCmdID());
     noResp    = getValue   (NO_RESP, put->getNoResp());
-    lang      = getValue   (LANG, put->getNoResp());    
+    lang      = getValue   (LANG, put->getLang());    
     cred      = getCred    (put->getCred());
     meta      = getMeta    (put->getMeta());
     items     = getItems   (put->getItems());        
@@ -1775,7 +1775,7 @@
     
     if (!devInf)
         return NULL;
-    
+
     StringBuffer* ret = NULL;
     StringBuffer* s   = NULL;
     
@@ -1838,7 +1838,8 @@
         s->append(supportNumberOfChanges);            
     }
 
-    ret = getValue(DEV_INF, s);
+    // TODO: getValue() should accept const strings
+    ret = getValue((BCHAR *)DEV_INF, (BCHAR *)s->c_str(), (BCHAR *)DEVINF);
     
     deleteAllStringBuffer(16, &s, &verDTD, &man, &mod, &oem, &fwV, &swV, &hwV, 
                               &devID, &devTyp, &dataStores, &ctCaps, &exts, &utc, 
@@ -1974,7 +1975,10 @@
     
     sourceRef   = getSourceRef(dataStore->getSourceRef());
     displayName = getValue(DISPLAY_NAME, dataStore->getDisplayName(NULL));
-    maxGUIDSize = getValue(MAX_GUID_SIZE, dataStore->getMaxGUIDSize());
+    int maxGUIDSizeVal = dataStore->getMaxGUIDSize();
+    maxGUIDSize = maxGUIDSizeVal > 0 ?
+        getValue(MAX_GUID_SIZE, maxGUIDSizeVal) :
+        new StringBuffer;
     rxPref      = getContentTypeInfo(dataStore->getRxPref(), RX_PREF);
     rx          = getContentTypeInfos(dataStore->getRx(), RX);
     txPref      = getContentTypeInfo(dataStore->getTxPref(), TX_PREF);
@@ -1986,7 +1990,9 @@
         s = new StringBuffer();
         s->append(sourceRef);
         s->append(displayName);
-        s->append(maxGUIDSize);
+        if (maxGUIDSize->length()) {
+            s->append(maxGUIDSize);
+        }
         s->append(rxPref);
         s->append(rx);
         s->append(txPref);
@@ -2230,6 +2236,73 @@
 * 
 */
 StringBuffer* Formatter::getCTCaps(ArrayList* ctCaps) {
+#if 0
+    return new StringBuffer(
+        "<CTCap>"
+        "<CTType>text/x-vcard</CTType>"
+        "<PropName>BEGIN</PropName>"
+        "<ValEnum>VCARD</ValEnum>"
+        "<PropName>VERSION</PropName>"
+        "<ValEnum>2.1</ValEnum>"
+        "<PropName>END</PropName>"
+        "<ValEnum>VCARD</ValEnum>"
+        "<PropName>N</PropName>"
+        "<PropName>TEL</PropName>"
+        "<ParamName>PREF</ParamName>"
+        "<ParamName>WORK</ParamName>"
+        "<ParamName>HOME</ParamName>"
+        "<ParamName>VOICE</ParamName>"
+        "<ParamName>FAX</ParamName>"
+        "<ParamName>CELL</ParamName>"
+        "<PropName>NOTE</PropName>"
+        "<PropName>URL</PropName>"
+        "<PropName>EMAIL</PropName>"
+        "<PropName>ADR</PropName>"
+        "</CTCap>"
+        "<CTCap>"
+        "<CTType>text/x-vcalendar</CTType>"
+        "<PropName>BEGIN</PropName>"
+        "<ValEnum>VCALENDAR</ValEnum>"
+        "<ValEnum>VEVENT</ValEnum>"
+        "<ValEnum>VTODO</ValEnum>"
+        "<PropName>VERSION</PropName>"
+        "<ValEnum>1.0</ValEnum>"
+        "<PropName>END</PropName>"
+        "<ValEnum>VCALENDAR</ValEnum>"
+        "<ValEnum>VEVENT</ValEnum>"
+        "<ValEnum>VTODO</ValEnum>"
+        "<PropName>DTSTART</PropName>"
+        "<PropName>DTEND</PropName>"
+        "<PropName>SUMMARY</PropName>"
+        "<PropName>DESCRIPTION</PropName>"
+        "<PropName>DUE</PropName>"
+        "<PropName>AALARM</PropName>"
+        "<PropName>DALARM</PropName>"
+        "<PropName>RRULE</PropName>"
+        "<PropName>CATEGORIES</PropName>"
+        "<ParamName>SPECIAL OCCASION</ParamName>"
+        "<ParamName>MEETING</ParamName>"
+        "<ParamName>PHONE CALL</ParamName>"
+        "<ParamName>MISCELLANEOUS</ParamName>"
+        "<ParamName>REMINDER</ParamName>"
+        "<PropName>LOCATION</PropName>"
+        "<PropName>STATUS</PropName>"
+        "<ParamName>NEEDS ACTION</ParamName>"
+        "<ParamName>COMPLETED</ParamName>"
+        "<PropName>PRIORITY</PropName>"
+        "<ParamName>1</ParamName>"
+        "<ParamName>2</ParamName>"
+        "<ParamName>3</ParamName>"
+        "<PropName>EXDATE</PropName>"
+        "</CTCap>"
+        "<CTCap>"
+        "<CTType>text/plain</CTType>"
+        "<PropName></PropName>"
+        "<DataType>chr</DataType>"
+        "<Size>3000</Size>"
+        "</CTCap>" );
+#endif
+
     
     if (!ctCaps || !NotZeroArrayLenght(1, ctCaps))
         return NULL;
--- native/src/c++/posix/http/CurlTransportAgent.cpp~devinfo
+++ native/src/c++/posix/http/CurlTransportAgent.cpp
@@ -65,7 +65,6 @@
         curl_easy_setopt(easyhandle, CURLOPT_ERRORBUFFER, this->curlerrortxt );
         curl_easy_setopt(easyhandle, CURLOPT_AUTOREFERER, TRUE);
         curl_easy_setopt(easyhandle, CURLOPT_FOLLOWLOCATION, TRUE);
-        curl_easy_setopt(easyhandle, CURLOPT_USERAGENT, userAgent[0] ? userAgent : "Funambol POSIX SyncML client");
         if (proxy.host[0]) {
             curl_easy_setopt(easyhandle, CURLOPT_PROXY, proxy.host);
             if (proxy.port) {
@@ -77,8 +76,19 @@
             }
         }
     }
+    setUserAgent("Funambol POSIX SyncML client");
+}
+
+void CurlTransportAgent::setUserAgent(BCHAR* ua) {
+    if (ua) {
+        TransportAgent::setUserAgent(ua);
+        if (easyhandle) {
+            curl_easy_setopt(easyhandle, CURLOPT_USERAGENT, userAgent);
+        }
+    }
 }
 
+
 CurlTransportAgent::~CurlTransportAgent() {
     if (easyhandle) {
         curl_easy_cleanup(easyhandle);
--- native/src/include/common/base/util/utils.h~devinfo
+++ native/src/include/common/base/util/utils.h
@@ -136,7 +136,7 @@
 /*
 * Calculates the digest given the token and its lenght
 */
-char* calculateMD5(void* token, int len, char* wdigest);
+char* calculateMD5(const void* token, int len, char* wdigest);
 
 /*
  * Return a filename composed by the system temp dir and the name given
--- native/src/include/common/client/DMTClientConfig.h~devinfo
+++ native/src/include/common/client/DMTClientConfig.h
@@ -26,13 +26,20 @@
 #include "spds/SyncSourceConfig.h"
 #include "spdm/ManagementNode.h"
 
+class DMTree;
 
 /**
  * This class is an extension of SyncManagerConfig that is DM tree aware; this
  * means that configuration properties are read/stored from/to the DM tree.
  */
 class DMTClientConfig : public SyncManagerConfig {
-    
+    private:
+        DMTree* dmt;
+        ManagementNode* syncMLNode;
+        ManagementNode* sourcesNode;
+
+        void initialize();
+
     protected:
         BCHAR* rootContext;
 
@@ -49,14 +56,50 @@
 
         ~DMTClientConfig() EXTRA_SECTION_01;
 
-        BOOL getSyncSourceConfig(
+        virtual BOOL getSyncSourceConfig(
                 const BCHAR* name,
                 SyncSourceConfig& sc,
                 BOOL refresh = FALSE) EXTRA_SECTION_01;
-       
-        BOOL read() EXTRA_SECTION_01;
-        BOOL save() EXTRA_SECTION_01;
 
+        virtual BOOL read() EXTRA_SECTION_01;
+        virtual BOOL save() EXTRA_SECTION_01;
+
+        /**
+         * Opens the configuration backend associated with the root context.
+         * Calling on an open config does nothing.
+         *
+         * @return TRUE for success
+         */
+        virtual BOOL open() EXTRA_SECTION_01;
+
+        /**
+         * Provides access to the "syncml" configuration node,
+         * can be used to read/write custom configuration options.
+         * Config must have been opened before.
+         *
+         * @return node pointer owned by config and valid while the config is open
+         */
+        virtual ManagementNode* getSyncMLNode() EXTRA_SECTION_01;
+
+        /**
+         * Gets number of sync source configurations, -1 if not open.
+         */
+        virtual int getNumSources() EXTRA_SECTION_01;
+
+        /**
+         * Get the specified sync source configuration.
+         *
+         * @param index    number of the requested sync source configuration
+         * @return node pointer owned by config and valid while the config is open
+         */
+        virtual ManagementNode* getSyncSourceNode(int index) EXTRA_SECTION_01;
+
+        /**
+         * Closes the configuration backend. Frees all resources associated
+         * with and invalidates all ManagementNode pointers returned by this
+         * config.
+         */
+        virtual void close() EXTRA_SECTION_01;
 };
 
 #endif
--- native/src/include/common/client/Sync4jClient.h~devinfo
+++ native/src/include/common/client/Sync4jClient.h
@@ -25,56 +25,277 @@
     #include "base/util/ArrayList.h"
     #include "client/DMTClientConfig.h"
     #include "spds/SyncSource.h"
+    #include "spdm/ManagementNode.h"
     #include "spds/constants.h"
 
     class SyncManager;
+    class AccessConfig;
+    class DevInf;
 
     /**
-     * This class wrap the common operations requested by the client to
-     * handle a synchronization. It uses the signleton pattern to make
+     * This class wraps the common operations executed by a typical
+     * client. It contains default implementations for calls invoked
+     * by the library core to parameterize or control the
+     * synchronization. A client can override these calls by
+     * subclassing SyncClient and using an instance of its own class
+     * instead.
+     * 
+     * Warning: the library contains global data in several different
+     * places. Therefore it is not possible to execute multiple
+     * sessions in parallel.
+     */
+    class SyncClient {
+      public:
+        SyncClient();
+        virtual ~SyncClient();
+        
+        // set the default client configuration (using context root):
+        // when using this call the client handles the loading/saving
+        // of the configuration properties automatically
+        //
+        // @param   root     identifies the root node in a configuration
+        //                   tree with sub nodes "spds/syncml" and "spds/sources"
+        virtual void setDMConfig(const BCHAR* root);
+        
+        // set a client-provided DMTree config: in this mode
+        // the caller owns the configuration and is responsible for
+        // saving the (possibly modified) configuration after the
+        // synchronization
+        virtual void setDMConfig(DMTClientConfig& c);
+
+        // get the defined error handler
+        virtual ErrorHandler& getErrorHandler();
+        // set a custom error handler
+        virtual void setErrorHandler(ErrorHandler& e);
+
+
+        /*
+         * Execute a synchronization on the specified sources.
+         * The sources will be configured automatically using the
+         * client configuration set earlier with one of the setDMConfig()
+         * calls.
+         *
+         * @param sources - NULL terminated array of sources to sync.
+         *
+         * @return - 0 on success, an error otherwise
+         */
+        virtual int sync(SyncSource** sources);
+
+        /**
+         * Execute a synchronization with sources that are chosen based
+         * on the configuration:
+         * - calls prepareSync() to give a derived class the chance to
+         *   setup syncing and get ready for creating sources
+         * - iterates over the configuration and for
+         *   each source configuration, asks for the corresponding
+         *   client source with createSource():
+         *   the derived class creates the sources and for each of them can
+         *   modify the configuration or decide to not synchronize
+         *   the source; it is expected to remember all active sources so
+         *   that it can free them later, if necessary
+         * - calls beginSync() to give the derived class a class to do
+         *   after all sources have been configured successfully
+         * - executes the synchronization
+         *
+         * This version of the call is easier to use for clients whose
+         * sync sources are determined by the configuration or who need
+         * access to extended configuration properties because these clients
+         * can be implemented without having to copy the configuration
+         * handling code.
+         *
+         * @return 0 on success, an error otherwise
+         */
+        virtual int sync();
+
+        /**
+         * Gathers the various bits and pieces known about the client and
+         * its sources and builds a SyncML devinfo 1.1 instance.
+         *
+         * For simplicity reasons this function is called for the currently
+         * active sync sources, changing them between runs thus causes
+         * a (valid!) retransmission of the device info.
+         *
+         * @param sources     NULL terminated array of sync sources
+         * @return device infos, to be deleted by caller, or NULL if unavailable
+         */
+        virtual DevInf *createDeviceInfo(SyncSource **sources) EXTRA_SECTION_01;
+
+        /*********************************************************************
+         * The following calls provide information about the client that the
+         * client library may need during synchronization.
+         *
+         * Implementing them is optional.
+         ********************************************************************/
+        
+        /**
+         * Get a short string describing the client, f.i.
+         * "SyncEvolution Client"
+         *
+         * Currently used as HTTP transport agent together with the
+         * version number unless overridden by the userAgent config
+         * property. Also embedded in device infos sent to server in the
+         * <Mod> model property.
+         *
+         * @return a pointer to a string owned by the client, NULL if not available
+         */
+        virtual const BCHAR *getClientID() const { return NULL; }
+
+        /**
+         * Get a short string with the version of the client software,
+         * e.g. "1.0".
+         *
+         * Appended to the client ID string in the HTTP transport agent unless
+         * that is configured explicitly and sent as <SwV> software version
+         * property of the device infos.
+         *
+         * @return a pointer to a string owned by the client, NULL if not available
+         */
+        virtual const BCHAR *getClientVersion() const { return NULL; }
+
+        /**
+         * Get a short string describing the manufacturer/author of the client software.
+         *
+         * Only used as part of the detailed device infos in the <Man> tag.
+         *
+         * @return a pointer to a string owned by the client, NULL if not available
+         */
+        virtual const BCHAR *getManufacturer() const { return NULL; }
+
+        /**
+         * Get a short string describing the type of device the client is running
+         * on.
+         *
+         * Only used as part of the detailed device infos in the <DevType> tag.
+         * SyncML devinfo V1.1 defines the following strings, but mentions that
+         * "other values can be defined":
+         * - pager
+         * - handheld
+         * - pda
+         * - phone
+         * - smartphone
+         * - server
+         * - workstation
+         *
+         * @return a pointer to a string owned by the client, must be provided
+         */
+        virtual const BCHAR *getClientType() const { return "workstation"; }
+
+        /**
+         * Returning TRUE here tells the server that the client is able to
+         * handle UTC time stamps. The exact effect depends on the server,
+         * but the standard implies that the server is then expected to prefer
+         * UTC over local time stamps.
+         *
+         * The default is FALSE because that was what the server traditionally
+         * had to assume when talking to Funambol C++ based clients due to not
+         * getting any device infos. For modern clients UTC is probably the
+         * better value.
+         */
+        virtual BOOL isUTC() const { return FALSE; }
+        
+        /**
+         * Optionally specifies the content type capabilities of the device
+         * as expected by the SyncML devinfo 1.1 specification. This information
+         * describes which properties and which values the client can store.
+         * devinfo 1.1 separates this information from specific sync sources.
+         *
+         * The standard only suggests that this information SHOULD be provided,
+         * but does not require it (5.1 CTCap). Not sending this information
+         * might be treated as a sign that the client supports the full range of
+         * properties, thus clients with limited capabilities really should indicate
+         * that by sending valid information.
+         *
+         * @return a valid XML fragment starting with <CTCap> and ending in </CTCap>
+         *         or NULL if the client does not which to send this information
+         *
+         * Not currently implemented.
+         */
+        /* virtual const BCHAR *getCapabilities() { return NULL; } */
+
+
+      protected:
+        /**
+         * A callback into a derived class which is called after
+         * reading the SyncML configuration and before creating sources.
+         * Not used by the sync(SyncSource**) call.
+         *
+         * @param config   a copy of the SyncML and client configuration
+         * @param node     a config node handle that can be used to read
+         *                 client specific properties (only valid during
+         *                 this call)
+         * @return 0 for success, an error code otherwise - an error code
+         *         aborts the whole synchronization
+         */
+        virtual int prepareSync(const AccessConfig &config,
+                                ManagementNode &node) {
+            return ERR_NONE;
+        }
+
+        /**
+         * A factory method that is used by the sync() call to create
+         * the sync sources that are to be synchronized. Not used by the
+         * sync(SyncSource**) call.
+         *
+         * @param name     name of the sync source
+         * @param config   a copy of the source's configuration: this
+         *                 includes all properties that the client library
+         *                 knows and uses itself (only valid during this call)
+         * @param node     a config node handle that can be used
+         *                 to read client specific properties (only valid
+         *                 during this call)
+         * @retval source  the sync source created by the client or NULL if
+         *                 there is no sync source currently associated with
+         *                 the config or it is inactive; instance is owned
+         *                 by the creator and has to be freed after the sync
+         * @return 0 for success, an error code otherwise - an error code
+         *         aborts the whole synchronization and the value of *source is
+         *         ignored
+         */
+        virtual int createSyncSource(const char *name,
+                                     const SyncSourceConfig &config,
+                                     ManagementNode &node,
+                                     SyncSource **source) {
+            *source = NULL;
+            return ERR_UNSPECIFIED;
+        }
+
+        /**
+         * Callback invoked after creating all sources.
+         * @return 0 for success, an error code otherwise - an error code stops
+         *         immediately
+         */
+        virtual int beginSync() {
+            return ERR_NONE;
+        }
+
+      private:
+        // fallback error handler which is used if no custom handler gets installed
+        ErrorHandler *defaultErrorHandler;
+        // custom error handler which overrides the default one
+        ErrorHandler *customErrorHandler;
+        // configuration of this client, set by setDMConfig()
+        DMTClientConfig *config;
+        // depending on how it was set, the config has to be saved and freed or not
+        BOOL isOurConfig;
+    };
+
+
+    /**
+     * This is the legacy API. It uses the singleton pattern to make
      * sure that only one instance of the client is active on the client
      * program. 
      */
-    class Sync4jClient {
+     class Sync4jClient : public SyncClient {
 
         public:
             // get and release singleton instance
             static Sync4jClient& getInstance();
             static void dispose();
-            // set the default client configuration (using context root)
-            void setDMConfig(const BCHAR* root);
-            // set a client-provided DMTree config
-            void setDMConfig(DMTClientConfig& c);
-
-            // get the defined error handler
-            ErrorHandler& getErrorHandler();
-            // set a custom error handler
-            void setErrorHandler(ErrorHandler& e);
-
-            /*
-             * Start a synchronization on the specified sources.
-             *
-             * @param sources - NULL terminated array of sources to sync.
-             *
-             * @return - 0 on success, an error otherwise
-             */
-            int sync(SyncSource** sources);
-
-            /*
-             * Used to start the sync process. The argument is an array of SyncSource
-             * that have to be synched
-             *
-             * @param sources the SyncSource& array
-             */
-            int sync(ArrayList& sources);
 
         private:
 
             static Sync4jClient* instance;
 
-            SyncManager* syncManager;
-            ErrorHandler* errorHandler;
-
             // private constructor and destructor
             Sync4jClient();
             ~Sync4jClient();
--- native/src/include/common/http/TransportAgent.h~devinfo
+++ native/src/include/common/http/TransportAgent.h
@@ -73,52 +73,52 @@
          *
          * @param url the new target url
          */
-        void setURL(URL& newURL) EXTRA_SECTION_03;
+        virtual void setURL(URL& newURL) EXTRA_SECTION_03;
 
         /*
          * Returns the url.
          */
-        URL& getURL() EXTRA_SECTION_03;
+        virtual URL& getURL() EXTRA_SECTION_03;
 
         /**
          * Sets the connection timeout
          *
          * @param t the new timeout in seconds
          */
-        void setTimeout(unsigned int t) EXTRA_SECTION_03;
+        virtual void setTimeout(unsigned int t) EXTRA_SECTION_03;
 
         /**
          * Returns the connection timeout
          */
-        unsigned int getTimeout() EXTRA_SECTION_03;
+        virtual unsigned int getTimeout() EXTRA_SECTION_03;
         
         /**
          * Sets the max msg size
          *
          * @param t the new msx msg size in bytes
          */
-        void setMaxMsgSize(unsigned int t) EXTRA_SECTION_03;
+        virtual void setMaxMsgSize(unsigned int t) EXTRA_SECTION_03;
          
         /**
          * Returns the max msg size
          */
-        unsigned int getMaxMsgSize()EXTRA_SECTION_03;
+        virtual unsigned int getMaxMsgSize()EXTRA_SECTION_03;
 
         /**
          * Sets the buffer size
          *
          * @param t the buffer size size in bytes
          */
-        void setReadBufferSize(unsigned int t) EXTRA_SECTION_03;
+        virtual void setReadBufferSize(unsigned int t) EXTRA_SECTION_03;
         
-        void setUserAgent(BCHAR* ua);
+        virtual void setUserAgent(BCHAR* ua);
 
-        BCHAR* getUserAgent();
+        virtual BCHAR* getUserAgent();
 
         /**
          * Returns the buffer size
          */
-        unsigned int getReadBufferSize()EXTRA_SECTION_03;
+        virtual unsigned int getReadBufferSize()EXTRA_SECTION_03;
 
 
         /*
--- native/src/include/common/spdm/constants.h~devinfo
+++ native/src/include/common/spdm/constants.h
@@ -45,6 +45,7 @@
 #define PROPERTY_SOURCE_TYPE           T("type"             )
 #define PROPERTY_SOURCE_SYNC           T("sync"             )
 #define PROPERTY_SOURCE_LAST_SYNC      T("last"             )
+#define PROPERTY_SOURCE_DEVINF_HASH    T("devInfHash"       )
 #define PROPERTY_SERVER_NONCE          T("serverNonce"      ) 
 #define PROPERTY_CLIENT_NONCE          T("clientNonce"      )
 #define PROPERTY_SERVER_ID             T("serverID"         )
@@ -90,6 +91,7 @@
 #define DIRTY_SERVERPWD                0x08000 
 #define DIRTY_CLIENTAUTHTYPE           0x10000 
 #define DIRTY_SERVERAUTH_REQUIRED      0x20000
+#define DIRTY_DEV_INF_HASH             0x40000
 
 
 #endif
--- native/src/include/common/spdm/ManagementNode.h~devinfo
+++ native/src/include/common/spdm/ManagementNode.h
@@ -106,6 +106,11 @@
          */
         virtual BCHAR *getFullName();
 
+        /**
+         * Returns the node name itself without the context.
+         */
+        virtual const BCHAR *getName();
+
         // ---------------------------------------------------- Abstract methods
 
         /*
--- native/src/include/common/spds/AccessConfig.h~devinfo
+++ native/src/include/common/spds/AccessConfig.h
@@ -33,6 +33,7 @@
         BCHAR*        proxyUsername    ;
         BCHAR*        proxyPassword    ;
         BCHAR*        syncURL          ;
+        BCHAR*        devInfHash       ;
         unsigned long beginTimestamp   ;
         unsigned long endTimestamp     ;
         SyncMode      firstTimeSyncMode;
@@ -76,7 +77,7 @@
          *         the memory itself.
          *
          */
-        const BCHAR* getUsername(const BCHAR* buf = NULL) EXTRA_SECTION_02;
+        const BCHAR* getUsername(const BCHAR* buf = NULL) const EXTRA_SECTION_02;
 
         /**
          *  Sets the username value. The given data are copied in an internal
@@ -90,7 +91,7 @@
         /**
          * Returns the password value.
          */
-        const BCHAR* getPassword(const BCHAR* buf = NULL) EXTRA_SECTION_02;
+        const BCHAR* getPassword(const BCHAR* buf = NULL) const EXTRA_SECTION_02;
 
         /**
          * Sets a new password value. The given data are copied in an internal
@@ -104,7 +105,7 @@
         /**
          * Returns the deviceId value.
          */
-        const BCHAR* getDeviceId(const BCHAR* buf = NULL) EXTRA_SECTION_02;
+        const BCHAR* getDeviceId(const BCHAR* buf = NULL) const EXTRA_SECTION_02;
 
         /**
          * Sets a new  deviceId value. The given data are copied in an internal
@@ -119,7 +120,7 @@
          * Returns the SyncMode that the sync engine should your the first time
          * a source is synced
          */
-        SyncMode getFirstTimeSyncMode() EXTRA_SECTION_02;
+        SyncMode getFirstTimeSyncMode() const EXTRA_SECTION_02;
 
         /**
          * Sets the SyncMode that the sync engine should your the first time
@@ -132,7 +133,7 @@
         /**
          * Should the sync engine use a HTTP proxy?
          */
-        BOOL getUseProxy() EXTRA_SECTION_02;
+        BOOL getUseProxy() const EXTRA_SECTION_02;
 
         /**
          * Sets if the sync engine should use a HTTP proxy to access the server.
@@ -144,7 +145,7 @@
         /**
          * Returns the proxyHost value.
          */
-        const BCHAR* getProxyHost(const BCHAR* buf = NULL) EXTRA_SECTION_02;
+        const BCHAR* getProxyHost(const BCHAR* buf = NULL) const EXTRA_SECTION_02;
 
         /**
          * Sets a new proxyHost value.
@@ -156,7 +157,7 @@
         /**
          * Returns the proxyUsername value.
          */
-        BCHAR* getProxyUsername(const BCHAR* buf = NULL) EXTRA_SECTION_02;
+        BCHAR* getProxyUsername(const BCHAR* buf = NULL) const EXTRA_SECTION_02;
 
         /**
          * Sets a new proxyUsername value.
@@ -168,7 +169,7 @@
         /**
          * Returns the proxyPassword value.
          */
-        BCHAR* getProxyPassword(const BCHAR* buf = NULL) EXTRA_SECTION_02;
+        BCHAR* getProxyPassword(const BCHAR* buf = NULL) const EXTRA_SECTION_02;
 
         /**
          * Sets a new proxyPassword value.
@@ -182,7 +183,7 @@
          * (or HTTP://) or https:// (or HTTPS://), http:// is prepended to the
          * given string.
          */
-        const BCHAR* getSyncURL(const BCHAR* buf = NULL) EXTRA_SECTION_02;
+        const BCHAR* getSyncURL(const BCHAR* buf = NULL) const EXTRA_SECTION_02;
 
         /**
          * Sets a new the syncURL value. The given data are copied in an internal
@@ -203,7 +204,7 @@
         /**
          * Returns the beginSync timestamp
          */
-        unsigned long getBeginSync() EXTRA_SECTION_02;
+        unsigned long getBeginSync() const EXTRA_SECTION_02;
 
         /**
          * Sets the new "endSync" timestamp.
@@ -215,56 +216,59 @@
         /**
          * Returns the endSync timestamp
          */
-        unsigned long getEndSync() EXTRA_SECTION_02;
+        unsigned long getEndSync() const EXTRA_SECTION_02;
 
-        BOOL getServerAuthRequired() EXTRA_SECTION_02;
+        const BCHAR* getDevInfHash() const EXTRA_SECTION_02;
+        void setDevInfHash(const BCHAR *devInfHash) EXTRA_SECTION_02;
+
+        BOOL getServerAuthRequired() const EXTRA_SECTION_02;
 
         void setServerAuthRequired(BOOL v) EXTRA_SECTION_02;
 
-        const BCHAR* getClientAuthType(const BCHAR* buf = NULL) EXTRA_SECTION_02;
+        const BCHAR* getClientAuthType(const BCHAR* buf = NULL) const EXTRA_SECTION_02;
 
         void setClientAuthType(const BCHAR* v) EXTRA_SECTION_02;
 
-        const BCHAR* getServerAuthType(const BCHAR* buf = NULL) EXTRA_SECTION_02;
+        const BCHAR* getServerAuthType(const BCHAR* buf = NULL) const EXTRA_SECTION_02;
 
         void setServerAuthType(const BCHAR* v) EXTRA_SECTION_02;
 
-        const BCHAR* getServerPWD(const BCHAR* buf = NULL) EXTRA_SECTION_02;
+        const BCHAR* getServerPWD(const BCHAR* buf = NULL) const EXTRA_SECTION_02;
 
         void setServerPWD(const BCHAR* v) EXTRA_SECTION_02;
 
-        const BCHAR* getServerID(const BCHAR* buf = NULL) EXTRA_SECTION_02;
+        const BCHAR* getServerID(const BCHAR* buf = NULL) const EXTRA_SECTION_02;
 
         void setServerID(const BCHAR* v) EXTRA_SECTION_02;
 
-        const BCHAR* getServerNonce(const BCHAR* buf = NULL) EXTRA_SECTION_02;
+        const BCHAR* getServerNonce(const BCHAR* buf = NULL) const EXTRA_SECTION_02;
 
         void setServerNonce(const BCHAR* v) EXTRA_SECTION_02;
 
-        const BCHAR* getClientNonce(const BCHAR* buf = NULL) EXTRA_SECTION_02;
+        const BCHAR* getClientNonce(const BCHAR* buf = NULL) const EXTRA_SECTION_02;
 
         void setClientNonce(const BCHAR* v) EXTRA_SECTION_02;
 
         void setMaxMsgSize(unsigned long msgSize) EXTRA_SECTION_02;
 
-        unsigned long getMaxMsgSize() EXTRA_SECTION_02;
+        unsigned long getMaxMsgSize() const EXTRA_SECTION_02;
 
         void setMaxModPerMsg(unsigned long msgSize) EXTRA_SECTION_02;
 
-        unsigned long getMaxModPerMsg() EXTRA_SECTION_02;
+        unsigned long getMaxModPerMsg() const EXTRA_SECTION_02;
         
         void setReadBufferSize(unsigned long bufferSize);
 
-        unsigned long getReadBufferSize();
+        unsigned long getReadBufferSize() const EXTRA_SECTION_02;
 
-        const BCHAR* getUserAgent();
+        const BCHAR* getUserAgent() const EXTRA_SECTION_02;
 
-        void setUserAgent(const BCHAR* v);
+        void setUserAgent(const BCHAR* v) EXTRA_SECTION_02;
 
         /**
          * Has some of this values changed?
          */
-        unsigned int getDirty() EXTRA_SECTION_02;
+        unsigned int getDirty() const EXTRA_SECTION_02;
 
         /**
          * Sets the values of this object with with the values from the given
@@ -277,7 +281,7 @@
         /**
          * Should the sync engine use a HTTP proxy?
          */
-        BOOL getEncryption() EXTRA_SECTION_02;
+        BOOL getEncryption() const EXTRA_SECTION_02;
 
         /**
          * Sets if the sync engine should use a HTTP proxy to access the server.
--- native/src/include/common/spds/SyncManager.h~devinfo
+++ native/src/include/common/spds/SyncManager.h
@@ -29,8 +29,6 @@
 #include "spds/CredentialHandler.h"
 #include "spds/CredentialHandler.h"
 
-
-
 typedef enum {
                 STATE_START        = 0,
                 STATE_PKG1_SENDING = 1,
@@ -41,14 +39,28 @@
                 STATE_PKG5_SENT    = 6
              } SyncManagerState ;
 
-
+//
+// This is the core class which encodes the flow of messages between
+// client and server throughout a session. It is configured via the
+// DMTClientConfig with which it is constructed by the
+// SyncClient::setDMConfig() and the (optional) DevInf provided
+// to it by the client.
+//
 class SyncManager {
 
     public:
-        SyncManager(SyncManagerConfig* config) EXTRA_SECTION_01;
-        SyncManager(SyncManagerConfig& config) EXTRA_SECTION_01;
+        /**
+         * Initialize a new sync manager. Parameters provided to it
+         * have to remain valid while this sync manager exists.
+         *
+         * @param config     required configuration
+         * @param devinf     optional device information which will
+         *                   be sent to the server if it has changed or
+         *                   the server asks for it
+         */
+        SyncManager(SyncManagerConfig& config, DevInf *devinf = NULL) EXTRA_SECTION_01;
         ~SyncManager() EXTRA_SECTION_01;
-        
+
         int prepareSync(SyncSource** sources) EXTRA_SECTION_01;
         
         int sync() EXTRA_SECTION_01;
@@ -65,7 +77,9 @@
             BCHAR* dataType;
         };
 
+        DevInf* devInf;
         SyncManagerConfig& config;
+
         CredentialHandler credentialHandler;
         SyncMLBuilder syncMLBuilder;
         SyncMLProcessor syncMLProcessor;
@@ -84,7 +98,6 @@
         
         BCHAR syncURL [512];
         BCHAR deviceId[32];  
-        BCHAR userAgent[128];        
         unsigned int maxMsgSize;    // the max message size. If 0 it is not set
         unsigned int maxModPerMsg;  // the max modification per message
         unsigned int readBufferSize; // the size of the buffer to store chunk of incoming stream.
--- native/src/include/common/spds/SyncMLBuilder.h~devinfo
+++ native/src/include/common/spds/SyncMLBuilder.h
@@ -104,7 +104,18 @@
         * Prepare the status for Sync command
         */
         Status*  prepareSyncStatus(SyncSource& source, Sync* sync) EXTRA_SECTION_01;
-                        
+
+        /**
+         * Prepare the status for an arbitrary command
+         */
+        Status* prepareCmdStatus(AbstractCommand &cmd, int status) EXTRA_SECTION_01;
+
+        /**
+         * Prepare either a Result with the device infos (if command given) or
+         * a Put.
+         */
+        AbstractCommand *prepareDevInf(AbstractCommand *cmd, DevInf &devInf) EXTRA_SECTION_01;
+        
         /*
         * Prepare the Sync object. It doesn't contain any items. It is to prepare the insert of items
         */
--- native/src/include/common/spds/SyncSourceConfig.h~devinfo
+++ native/src/include/common/spds/SyncSourceConfig.h
@@ -45,11 +45,6 @@
         SyncSourceConfig() EXTRA_SECTION_02;
 
         /*
-         * Constructs a new SyncSourceConfig object from an other.
-         */
-        SyncSourceConfig(SyncSourceConfig& c) EXTRA_SECTION_02;
-
-        /*
          * Destructor
          */
         ~SyncSourceConfig() EXTRA_SECTION_02;
@@ -57,7 +52,7 @@
         /*
          * Returns the SyncSource name.
          */
-        const BCHAR* getName(BCHAR* buf = NULL) const EXTRA_SECTION_02;
+        const BCHAR* getName() const EXTRA_SECTION_02;
 
         /*
          * Sets the SyncSource name
@@ -70,7 +65,7 @@
         /*
          * Returns the SyncSource URI (used in SyncML addressing).
          */
-        const BCHAR* getURI(BCHAR* buf = NULL) const EXTRA_SECTION_02;
+        const BCHAR* getURI() const EXTRA_SECTION_02;
 
         /*
          * Sets the SyncSource URI (used in SyncML addressing).
@@ -83,8 +78,7 @@
          * Returns a comma separated list of the possible syncModes for the
          * SyncSource.
          */
-
-        const BCHAR* getSyncModes(BCHAR* buf = NULL) const EXTRA_SECTION_02;
+        const BCHAR* getSyncModes() const EXTRA_SECTION_02;
 
         /*
          * Sets the available syncModes for the SyncSource as comma separated
@@ -101,13 +95,8 @@
 
         /*
          * Returns the mime type of the items handled by the sync source.
-         * If type is null, the internal buffer is returned, otherwise the
-         * value is copied into the given buffer (that must be DIM_SYNC_MIME_TYPE
-         * big).
-         *
-         * @param t the buffer were the mime type will be copied into (if not null)
          */
-        const BCHAR* getType(BCHAR* buf = NULL) const EXTRA_SECTION_02;
+        const BCHAR* getType() const EXTRA_SECTION_02;
 
         /*
          * Sets the mime type of the items handled by the sync source.
@@ -117,11 +106,9 @@
         void setType(const BCHAR* t) EXTRA_SECTION_02;
 
         /*
-         * Sets the default syncMode as one of the strings listed in setSyncModes.
-         *
-         * @param s the sync mode
+         * Gets the default syncMode as one of the strings listed in setSyncModes.
          */
-        const BCHAR* getSync(BCHAR* buf = NULL) const EXTRA_SECTION_02;
+        const BCHAR* getSync() const EXTRA_SECTION_02;
 
         /*
          * Returns the default syncMode as one of the strings above.
@@ -132,9 +119,8 @@
          * Sets the encodings to use to format the content of the items
          * generated by the sync source..
          *
-         * @param buf the sync mode
          */
-        const BCHAR* getEncoding(BCHAR* buf = NULL) const EXTRA_SECTION_02;
+        const BCHAR* getEncoding() const EXTRA_SECTION_02;
         
         /*
          * Returns the default syncMode as one of the strings above.
@@ -159,7 +145,10 @@
          * @pram sc the source config object
          */
         void assign(const SyncSourceConfig& sc);
-
+        SyncSourceConfig& operator = (const SyncSourceConfig& sc) {
+            assign(sc);
+            return *this;
+        }
     };
 
 #endif
--- native/src/include/common/spds/SyncSource.h~devinfo
+++ native/src/include/common/spds/SyncSource.h
@@ -26,18 +26,17 @@
 #include "spds/constants.h"
 #include "spds/SyncItem.h"
 #include "spds/SyncStatus.h"
+#include "spds/SyncSourceConfig.h"
 
 class SyncSource : public ArrayElement {
 
 private:
+    SyncSourceConfig config;
     SyncMode      syncMode;
     unsigned long lastSync;
     unsigned long nextSync;
     wchar_t*      name;
-    wchar_t*      remoteURI;
-    wchar_t*      encoding;
 
-    BCHAR type[DIM_MIME_TYPE];
     BCHAR next[DIM_ANCHOR];
     BCHAR last[DIM_ANCHOR];
 
@@ -50,9 +49,10 @@
     /**
      * Constructor: create a SyncSource with the specified name
      *
-     * @param name - the name of the SyncSource
+     * @param name   the name of the SyncSource
+     * @param sc     optional configuration for the sync source
      */
-    SyncSource(const wchar_t* name) EXTRA_SECTION_01;
+    SyncSource(const wchar_t* name, const SyncSourceConfig* sc = NULL) EXTRA_SECTION_01;
 
     // Destructor
     virtual ~SyncSource() EXTRA_SECTION_01;
@@ -66,39 +66,55 @@
      */
     const wchar_t *getName() EXTRA_SECTION_01;
 
-    /*
-     * Get & Set remoteURI attribute.
-     */
-    void setRemoteURI(const wchar_t* uri) EXTRA_SECTION_01;
-    const wchar_t* getRemoteURI() EXTRA_SECTION_01;
+    /**********************************************************
+     * Most of the configurable properties are read
+     * by the client library from the config (in
+     * SyncClient::setDMConfig()) and then copied into the
+     * sync source.
+     *
+     * These properties are stored in a local copy which will not be
+     * written back into the permanent config, with a few exceptions:
+     * properties related to mananging sync sessions like lastAnchor
+     * are written back into the config by the library afer a
+     * successful synchronization.
+     *
+     * A client developer is not required to modify these calls,
+     * but he can use and/or update the properties before the
+     * synchronization starts.
+     *********************************************************/
+
+    // read-only access to configuration
+    const SyncSourceConfig& getConfig() const EXTRA_SECTION_01 {
+        return config;
+    }
+    // read-write access to configuration
+    SyncSourceConfig& getConfig() EXTRA_SECTION_01 {
+        return config;
+    }
+    // initialize sync source from complete configuration
+    void setConfig(const SyncSourceConfig& sc) EXTRA_SECTION_01;
 
     /*
      * Get & Set the preferred synchronization mode for the SyncSource.
+     *
+     * Taken initially from the configuration by setConfig(), it can then
+     * be modified by the client. The code synchronization code itself
+     * reads this value, but it doesn't modify it.
      */
     SyncMode getPreferredSyncMode() EXTRA_SECTION_01;
     void setPreferredSyncMode(SyncMode syncMode) EXTRA_SECTION_01;
 
     /*
      * Get & Sets the server imposed synchronization mode for the SyncSource.
+     *
+     * Agreed upon with the server during the initial exchange with the server.
+     * The SyncSource can react to it in beginSync(), in particular it must wipe
+     * its local data during a refresh from server.
      */
     SyncMode getSyncMode() EXTRA_SECTION_01;
     void setSyncMode(SyncMode syncMode) EXTRA_SECTION_01;
 
     /*
-     * Sets the mime type standard for the source items
-     *
-     * @param type the mime type
-     */
-    void setType(const BCHAR* type) EXTRA_SECTION_01;
-    /*
-     * Gets the standard mime type for the source items.
-     *
-     * @return - the source name (a pointer to the object buffer,
-     *           will be released at object destruction)
-     */
-    const BCHAR* getType() EXTRA_SECTION_01;
-
-    /*
      * Get & Set the timestamp in milliseconds of the last synchronization.
      * The reference time of the timestamp is platform specific.
      */
@@ -125,12 +141,6 @@
     void setNextAnchor(const BCHAR* next) EXTRA_SECTION_01;
     
     /*
-     * Get & Set encoding attribute.
-     */
-    void setEncoding(const wchar_t* enc) EXTRA_SECTION_01;
-    const wchar_t* getEncoding() EXTRA_SECTION_01;
-
-    /*
     * Gets filter
     *
     * @return  the current filter's value
@@ -146,28 +156,48 @@
     */
     void setFilter(SourceFilter* f);
 
-
+    /******************************************************
+     * The following methods are virtual because a
+     * derived SyncSource is expected to override or
+     * implement them. Only the pure virtual methods
+     * really have to be implemented, the others have
+     * reasonable defaults.
+     *****************************************************/
+    
     /*
-     * Called by the engine at the begin of the sync.
+     * Called by the engine from inside SyncClient::sync()
+     * at the begin of the sync.
+     *
      * The SyncSource can do every initialization it needs.
+     * The server has been contacted, so in particular
+     * getSyncMode() can now be used to find out what
+     * the sync mode for this synchronization run will be.
+     * After this call the iterators for SyncItems must return
+     * valid results for the current sync mode.
+     *
      * The synchronization stops if this function return a non-zero value.
      * 
      * @return - 0 on success, an error otherwise
      */
-    virtual int beginSync() = 0 EXTRA_SECTION_01;
+    virtual int beginSync() EXTRA_SECTION_01;
     
     /*
-     * Called by the engine at the begin of the sync.
-     * The SyncSource can do any needed commit action to save the state of
-     * the items.
-     * The engine commits to the server the changes applied in the transaction 
-     * only if this function return 0
+     * Called by the engine from inside SyncClient::sync()
+     * at the end of the sync.
+     *
+     * The SyncSource can do any needed commit action to save
+     * the state of the items. The engine commits to the server
+     * the changes applied in the transaction only if this function
+     * return 0.
+     *
+     * FIXME: the return code is currently ignored by the sync engine
      * 
      * @return - 0 on success, an error otherwise
      */
-    virtual int endSync() = 0 EXTRA_SECTION_01;
+    virtual int endSync() EXTRA_SECTION_01;
         
     virtual void setItemStatus(const wchar_t* key, int status) = 0 EXTRA_SECTION_01;
+
     /*
      * Return the key of the first SyncItem of all.
      * It is used in case of refresh sync 
@@ -260,7 +290,56 @@
      * ArrayElement implementation
      */
     virtual ArrayElement* clone() EXTRA_SECTION_01 = 0;
-                                         
+
+    /****************** meta information about SyncSource ****************/
+
+    /**
+     * Return information about preferred types for item during send
+     * and receive.
+     *
+     * The default implementation assumes that the configured
+     * type (getConfig().getType()) is also the preferred one for
+     * both direction. However, it has to determine the version to
+     * comply with the SyncML specs and this only works for:
+     * - text/x-vcard -> 2.1
+     * - text/vcard -> 3.0
+     * - text/x-calendar -> 1.0
+     * - text/calendar -> 2.0
+     *
+     * For all other, unknown types the version is set to an empty string.
+     *
+     * These values are all required. Returning NULL for any of them prevents
+     * sending of device infos.
+     *
+     * @retval recvType     preferred item type for receiving information
+     * @retval recvVersion  version string corresponding to recvType
+     * @retval sendType     preferred item type for sending information
+     * @retval sendVersion  version string corresponding to sendType
+     */
+    virtual void getPreferredTypes(const BCHAR*& recvType,
+                                   const BCHAR*& recvVersion,
+                                   const BCHAR*& sendType,
+                                   const BCHAR*& sendVersion) EXTRA_SECTION_01;
+
+    /**
+     * Return information about all supported types for sending
+     * items (optional).
+     *
+     * The default implementation returns the preferred type as the
+     * only available type.
+     *
+     * @return NULL if not further specified, otherwise a NULL terminated
+     *         array with type/version pairs for each supported type:
+     *         { "text/x-vcard", "2.1",
+     *           "text/vcard", "3.0",
+     *           NULL }
+     */
+    virtual const BCHAR** getSendTypes() EXTRA_SECTION_01 { return NULL; }
+
+    /**
+     * Same as getSendTypes() for receiving items.
+     */
+    virtual const BCHAR** getRecvTypes() EXTRA_SECTION_01 { return NULL; }
 };
 
 #endif
--- native/src/include/common/syncml/core/ContentTypeInfo.h~devinfo
+++ native/src/include/common/syncml/core/ContentTypeInfo.h
@@ -49,7 +49,7 @@
          *                specification - NOT NULL
          *
          */
-        ContentTypeInfo(BCHAR* ctType, BCHAR* verCT);
+        ContentTypeInfo(const BCHAR* ctType, const BCHAR* verCT);
 
         /**
          * Gets the content type properties
@@ -63,7 +63,7 @@
          *
          * @param ctType the content type properties
          */
-        void setCTType(BCHAR* ctType);
+        void setCTType(const BCHAR* ctType);
 
         /**
          * Gets the version of the content type
@@ -77,7 +77,7 @@
          *
          * @param verCT the version of the content type
          */
-        void setVerCT(BCHAR* verCT);
+        void setVerCT(const BCHAR* verCT);
 
         ArrayElement* clone();
 };
--- native/src/include/common/syncml/core/CTPropParam.h~devinfo
+++ native/src/include/common/syncml/core/CTPropParam.h
@@ -35,7 +35,9 @@
         BCHAR*   dataType;
         int size;
         ArrayList* ctParameters; //ContentTypeParameter[]
-    
+
+        void initialize();
+        
     // ---------------------------------------------------------- Protected data    
     public:
         CTPropParam();
--- native/src/include/common/syncml/core/CTTypeSupported.h~devinfo
+++ native/src/include/common/syncml/core/CTTypeSupported.h
@@ -31,7 +31,9 @@
     private:
     BCHAR* ctType;
     ArrayList* ctPropParams;    // CTPropParam[]   
-        
+
+    void initialize();
+    
     public:
         
     CTTypeSupported();
--- native/src/include/common/syncml/core/DevInf.h~devinfo
+++ native/src/include/common/syncml/core/DevInf.h
@@ -78,21 +78,21 @@
          *
          */
         DevInf(VerDTD* verDTD,
-                    BCHAR* man,
-                    BCHAR* mod,
-                    BCHAR* oem,
-                    BCHAR* fwV,
-                    BCHAR* swV,
-                    BCHAR* hwV,
-                    BCHAR* devID,
-                    BCHAR* devTyp,
-                    ArrayList* dataStores,
-                    ArrayList* ctCap,
-                    ArrayList* ext,
-                    BOOL utc,
-                    BOOL supportLargeObjs,
-                    BOOL supportNumberOfChanges,
-                    SyncCap* syncCap);
+               const  BCHAR* man,
+               const BCHAR* mod,
+               const BCHAR* oem,
+               const BCHAR* fwV,
+               const BCHAR* swV,
+               const BCHAR* hwV,
+               const BCHAR* devID,
+               const BCHAR* devTyp,
+               ArrayList* dataStores,
+               ArrayList* ctCap,
+               ArrayList* ext,
+               BOOL utc,
+               BOOL supportLargeObjs,
+               BOOL supportNumberOfChanges,
+               SyncCap* syncCap);
 
         // ---------------------------------------------------------- Public methods
         /**
@@ -122,7 +122,7 @@
          * @param man the device manufacturer property
          *
          */
-        void setMan(BCHAR* man);
+        void setMan(const BCHAR* man);
 
         /**
          * Gets the model name of device
@@ -137,7 +137,7 @@
          * @param mod the device model property
          *
          */
-        void setMod(BCHAR* mod);
+        void setMod(const BCHAR* mod);
 
         /**
          * Gets the Original Equipment Manufacturer of the device
@@ -152,7 +152,7 @@
          * @param oem the Original Equipment Manufacturer of the device
          *
          */
-        void setOEM(BCHAR* oem);
+        void setOEM(const BCHAR* oem);
 
         /**
          * Gets the firmware version property
@@ -167,7 +167,7 @@
          * @param fwV the firmware version property
          *
          */
-        void setFwV(BCHAR* fwV);
+        void setFwV(const BCHAR* fwV);
 
         /**
          * Gets the software version property
@@ -182,7 +182,7 @@
          * @param swV the software version property
          *
          */
-        void setSwV(BCHAR* swV);
+        void setSwV(const BCHAR* swV);
 
         /**
          * Gets the hardware version property
@@ -197,7 +197,7 @@
          * @param hwV the hardware version property
          *
          */
-        void setHwV(BCHAR* hwV);
+        void setHwV(const BCHAR* hwV);
 
         /**
          * Gets the device identifier
@@ -212,7 +212,7 @@
          * @param devID the device identifier
          *
          */
-        void setDevID(BCHAR* devID);
+        void setDevID(const BCHAR* devID);
 
         /**
          * Gets the device type
@@ -227,7 +227,7 @@
          * @param devTyp the device type
          *
          */
-        void setDevTyp(BCHAR* devTyp);
+        void setDevTyp(const BCHAR* devTyp);
 
         /**
          * Gets the array of datastore
--- native/src/include/common/syncml/core/Put.h~devinfo
+++ native/src/include/common/syncml/core/Put.h
@@ -66,7 +66,7 @@
          * @return the preferred language
          *
          */
-        BCHAR* getLang(BCHAR* retLang);
+        BCHAR* getLang(BCHAR* retLang = NULL);
     
         /**
          * Sets the preferred language
--- native/src/include/common/syncml/core/StringElement.h~devinfo
+++ native/src/include/common/syncml/core/StringElement.h
@@ -39,7 +39,7 @@
     // ---------------------------------------------------------- Protected data    
     public:
                 
-        StringElement(BCHAR* value);
+        StringElement(const BCHAR* value);
         ~StringElement();
 
 
@@ -58,7 +58,7 @@
          * @param value the value of experimental meta information
          *
          */
-        void setValue(BCHAR* value);
+        void setValue(const BCHAR* value);
         
         ArrayElement* clone();
 
--- native/src/include/common/syncml/core/TagNames.h~devinfo
+++ native/src/include/common/syncml/core/TagNames.h
@@ -88,7 +88,7 @@
 #define SUPPORT_NUMBER_OF_CHANGES T("SupportNumberOfChanges")
 #define NUMBER_OF_CHANGES   T("NumberOfChanges")
 #define SUPPORT_LARGE_OBJECT T("LargeObject"              )
-#define UTC                 T("Utc"              )
+#define UTC                 T("UTC"              )
 #define DATA_STORE          T("DataStore"        )
 #define MAN                 T("Man"              )
 #define MOD                 T("Mod"              )
@@ -96,7 +96,7 @@
 #define FWV                 T("FwV"              )
 #define SWV                 T("SwV"              )
 #define HWV                 T("HwV"              )
-#define DEV_ID              T("DevId"            )
+#define DEV_ID              T("DevID"            )
 #define DEV_TYP             T("DevTyp"           )
 #define DEV_INF             T("DevInf"           )
 #define DISPLAY_NAME        T("DisplayName"      )
@@ -121,8 +121,12 @@
 #define SOURCE_PARENT       T("SourceParent"     )
 
 // parameters 
-#define METINFO             T("xmlns='syncml:metinf'")
+#define METINFO             T("xmlns=\"syncml:metinf\"")
+#define DEVINF              T("xmlns=\"syncml:devinf\"")
 
+// special values
+#define DEVINF_URI          T("./devinf11")
+#define DEVINF_FORMAT       T("application/vnd.syncml-devinf+xml")
 
 // Commands
 #define ALERT               T("Alert"            )
--- native/src/include/posix/http/CurlTransportAgent.h~devinfo
+++ native/src/include/posix/http/CurlTransportAgent.h
@@ -55,6 +55,7 @@
         ~CurlTransportAgent();
 
         char* sendMessage(const char* msg);
+        void setUserAgent(BCHAR* ua);
 
     };
 
